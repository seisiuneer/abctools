<!DOCTYPE html>
<html lang="en">

  <head>

  <meta charset="UTF-8">
  <title>ABC Transcription Tools - Custom Instrument Builder</title>
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ABC Transcription Tools - Custom Instrument Builder" />
  <meta property="og:description" content="Utility for creating custom instruments for the ABC Transcription Tools." />
  <meta property="og:url" content="https://michaeleskin.com/tools/custom_instrument_builder.html" />
  <meta property="og:site_name" content="ABC Transcription Tools - Custom Instrument Builder" />
  <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
  <meta name="viewport" content="width=860">
  <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">

  <script type="text/javascript" src="jszip-min.js?v=17"></script>
  <script type="text/javascript" src="filesaver-min.js?v=17"></script>
  <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=17"></script>
  
  <style>

    body {
      background: #fafafa;
      color: #222;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 12.5px auto;               
      padding: 0 19px;                   
      line-height: 1.47;                 
    }

    h1 {
      margin-top: 14.5px;                
      font-size: 1.73em;                 
      margin-bottom: .47em;              
      color: #000;
      text-align: center;
    }

    h2 {
      font-size: 1.5em;
      margin-top: .3em;
      margin-bottom: .47em;
      color: #000;
      text-align: center;
    }

    h4 {
      font-size: 1.15em;                 
      margin-top: .75em;
      margin-bottom: .47em;
      color: #000;
      text-align: center;
    }

    p { font-size: 1.0em; }              

    label {
      font-size: 1.0em;                  
      display: block;
      margin-top: .6em;                
      font-weight: 600;
    }

    input[type="file"], input[type="number"] {
      margin-top: 0.26em;
      font-size: 1.0em;
      padding: 0.37em 0.52em;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="file"] {
      font-size: 1em;
      padding: 0.3em 0;         /* was 0.5em, reduced so the inner button won’t clip */
      height: 2.2em;            /* was 2.6em, now shorter */
      line-height: 1.2;         /* aligns better with button text */
      border-radius: 4px;
      box-sizing: border-box;
    }

    /* Modern browsers */
    input[type="file"]::file-selector-button {
      -webkit-appearance: none;
      appearance: none;
      margin-right: 0.5em;
      padding: 0.3em 0.8em;     /* slightly reduced vertical padding */
      border-radius: 5px;
      border: 1px solid #005aad;
      background: #005aad;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      cursor: pointer;
      line-height: 1.2;
    }

    input[type="file"]::file-selector-button:hover {
      background: #0a6bd1;
      border-color: #0a6bd1;
    }
    input[type="file"]::file-selector-button:active {
      background: #0a5db6;
      border-color: #0a5db6;
    }
    input[type="file"]::file-selector-button:focus,
    input[type="file"]:focus-visible::file-selector-button {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0,90,173,0.25);
    }

    /* Safari / iOS fallback */
    input[type="file"]::-webkit-file-upload-button {
      -webkit-appearance: none;
      margin-right: 0.5em;
      padding: 0.3em 0.8em;     /* reduced vertical padding */
      border-radius: 5px;
      border: 1px solid #005aad;
      background: #005aad;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      cursor: pointer;
      line-height: 1.2;
    }
    input[type="file"]::-webkit-file-upload-button:hover {
      background: #0a6bd1;
      border-color: #0a6bd1;
    }
    input[type="file"]::-webkit-file-upload-button:active {
      background: #0a5db6;
      border-color: #0a5db6;
    }
    input[type="file"]:focus-visible::-webkit-file-upload-button {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0,90,173,0.25);
    }

    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;

      margin-top: 0.26em;
      font-size: 1.0em;
      width: 100%;
      box-sizing: border-box;
      padding-block: 0.4em;
      padding-inline: 0.52em;

      color: #222;             /* force text color */
      background-color: #fff;  /* ensure white background */
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    select:focus {
      border-color: #005aad;
      box-shadow: 0 0 0 2px rgba(0,90,173,0.25);
      outline: none;
    }

    #fileList {
      margin-top: .47em;                 
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.84em;                   
      max-height: 32vh;
      overflow-y: auto;
    }

    .file-item {
      padding: 0.1em 0.9em;
      margin-bottom: 0.3em;
      background: #f5f5f5;
      border: 1px solid #e1e1e1;
      border-radius: 3px;
      display: flex;
      align-items: center;
      gap: 7px;
      font-size: 0.97em;
    }

    .file-item.real { cursor: grab; }
    .file-item.drag-over { background: #e6f7ff; border-color: #91d5ff; }

    .file-item > span { align-self: center; line-height: 1.24; }
    .file-item > span:first-child { flex: 1 1 auto; }

    .file-item:not(.real) { min-height: 1.6em; padding: 0.1em 0.9em; }

    .proposed {
      color: #555;
      font-style: italic;
      margin-left: auto;
      flex-shrink: 0;
      align-self: center;
    }

    .controls { display: flex; align-items: center; justify-content: flex-end; margin-left: 8.5px; }

    .preview-btn {
      -webkit-appearance: none;
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
      gap: 6.3px;
      line-height: 1.05;
      padding: .37em .74em;
      border-radius: 6px;
      border: 1px solid #0d6efd;
      background: #0d6efd;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      user-select: none;
      transform: translateY(-11.5px);
    }
    .preview-btn:active { background: #d32f2f; border-color: #b71c1c; }
    .placeholder-label { color: #888; font-style: italic; }

    .gap-controls { margin-top: 7.3px; }

    input[type="file"] { font-size: 1.1em; padding: 0.5em 0em; height: 2.6em; line-height: 1.3; }

    button {
      margin-top: 1.68em;
      padding: 0.63em 1.05em;
      font-size: 1.0em;
      background: #005aad;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: green }

    .preview-btn.is-playing {
      background: #d32f2f !important;
      border-color: #b71c1c !important;
      color: #fff;
      box-shadow: 0 0 0 2px rgba(211,47,47,.15) inset;
    }
    .preview-btn:hover:not(.is-playing) { background: #81c784; border-color: #388e3c; }

    #fileList.drag-disabled { user-select: none; }
    #fileList.drag-disabled .file-item.real { cursor: default; opacity: 0.9; }

    .accordion {
      font-size: 12.1pt !important;
      font-family: "Helvetica" !important;
      background-color: #eee;
      color: #000 !important;
      cursor: pointer !important;
      padding: 7.3px 8.4px !important;
      width: 100% !important;
      text-align: center !important;
      border: .53px solid #000 !important;
      outline: none !important;
      margin-bottom: 7.3px;
      margin-top: 0px;
    }
    .accordion:hover { background: #88FF88; }

    .form-row { display: flex; gap: 10.5px; align-items: flex-end; flex-wrap: wrap; }
    .form-row > label { flex: 1 1 230px; margin-top: .7em; }
    .form-row > label > select, .form-row > label > input[type="number"] { width: 100%; }

    .active { background-color: #eee; }

    .apply-status { margin-left: 8px; font-size: 1em; color: #2e7d32; opacity: 0; transform: translateY(2px); transition: opacity 220ms ease, transform 220ms ease; }
    .apply-status.show { opacity: 1; transform: translateY(2px); }

    .expandall {
      font-size: 11.55pt !important; font-family:"Helvetica" !important; width:126px !important; height:42px !important;
      padding:7.3px !important; border-radius:4.2px !important; border:.53px solid #000 !important; color:black !important; background-color: #eee;
    }

    .modal_flat_background { background-color: #000; opacity: 0.4; }
    .modal_flat_main { border: 1px solid #333; box-shadow: 0px 0px 15.5px -2px rgba(0, 0, 0, 0.75); }
    .modal_flat_main, .modal_flat_main input, .modal_flat_main button { font-size: 16.8px; }
    .modal_flat_main input, .modal_flat_main button { padding: 5.25px; box-sizing: border-box; }
    .modal_flat_inner { padding: 20px; background: #fff; color: #000; }
    .modal_flat_content { font-family: "Helvetica"; margin: 21px 0px; }
    .modal_flat_input { margin: 21px 0px; }
    .modal_flat_buttons { text-align: center; margin-top: 20px; margin-bottom: 20px; }
    .modal_flat_main button { background-color: #ccc; color: #000; padding: 10.5px 21px; border: 0px; cursor: pointer; outline: none; width: 105px; }

    .modal_flat_cancel { margin-left: 5.25px; }

    .instr-modal { text-align: left; background-color: #f5ffff; max-height: 70vh; overflow: auto; padding: 12px; border: 1px solid #e1e1e1; border-radius: 4px; }
    .instr-modal p { margin: 0 0 12px 0; }

    .range-controls {
      display: none;
      margin-top: 7.3px;
      padding: 8px;
      padding-top:0px;
      background: #f8f8ff;
      border: 1px solid #e1e1f0;
      border-radius: 4px;
    }
    .range-controls .row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .range-controls label { margin-top: 0.2em; }

    .action-row { display: flex; justify-content: center; gap: 10px; }

    #exportZip {
      margin-left:24px;
      margin-top:12px;
    }

    #importZipBtn {
      background-color: #471268; 
      border-color: #471268;
      margin-right:24px;
      margin-top:12px;
    }

    #importZipBtn:hover {
      background-color: green; 
      border-color: green;
    }

  </style>
    
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>

  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VM0N9HL3MK');
  </script>

  </head>

  <body>
  
    <h1>ABC Transcription Tools&nbsp;-&nbsp;Custom Instrument Builder</h1>

    <button id="instructionsBtn" class="accordion" title="Show Instructions">Show Instructions</button>

    <label>Import audio sample files in .wav or .mp3 format:
      <input type="file" id="fileInput" accept=".wav,.mp3" multiple>
    </label>

    <div class="form-row">
      <label>Default instrument volume scale:
        <input type="number" id="volumeScale" step="0.1" min="0" value="1.0" inputmode="decimal">
      </label>

      <label>Default instrument release fade time (ms):
        <input type="number" id="fadeTime" step="5" min="0" value="100" inputmode="numeric">
      </label>
    </div>

    <div class="form-row">
      <label>Starting Octave Number:
        <select id="startNumber">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
        </select>
      </label>

      <label>Starting Scale Note:
        <select id="startNote">
          <option value="0">C</option>
          <option value="1">Db</option>
          <option value="2">D</option>
          <option value="3">Eb</option>
          <option value="4">E</option>
          <option value="5">F</option>
          <option value="6">Gb</option>
          <option value="7">G</option>
          <option value="8">Ab</option>
          <option value="9">A</option>
          <option value="10">Bb</option>
          <option value="11">B</option>
        </select>
      </label>
    </div>

    <!-- force mono WAV export -->
    <div class="form-row">
      <label style="flex:0 0 auto;">
        <input type="checkbox" id="forceMonoWav">
        Encode all exported files as mono .wav
      </label>
    </div>

    <!-- Trimming UI -->
    <div class="form-row">
      <label style="flex:0 0 auto;">
        <input type="checkbox" id="trimSilence">
        Trim leading silence
      </label>
    </div>

    <div id="thresholdControls" style="display:none; margin-top:6px;">
      <label title="Samples below this absolute dB are considered silence. Typical: -40 dB" style="display:flex;align-items:center;gap:6px;">
        <span>Silence threshold (dB):</span>
        <input type="number" id="silenceDb" step="0.5" max="0" min="-120" value="-40" inputmode="numeric" style="flex:0 0 90px;">
        <button type="button" id="applyThresholdBtn" style="margin:0;margin-left:4px;padding:0.3em 0.7em;font-size:0.9em;transform: translateY(2px);">Apply</button>
        <span id="applyStatus" class="apply-status" role="status" aria-live="polite" aria-atomic="true"></span>
      </label>
    </div>

    <div class="form-row">
      <label>
        <input type="checkbox" id="autoSort" checked>
        Automatically sort files by scale order (C, Db, D, Eb, E, ...)
      </label>
    </div>

    <!-- Range Expander toggle (available only when Auto Sort is on) -->
    <div class="form-row" id="rangeExpanderRow">
      <label>
        <input type="checkbox" id="rangeExpander">
        Range Expander (set lowest & highest desired notes)
      </label>
    </div>

    <!-- Range Expander controls -->
    <div id="rangeControls" class="range-controls">
      <div class="row">
        <label style="flex:1 1 220px;">Lowest desired octave:
          <select id="lowOct">
            <option>0</option><option>1</option><option>2</option><option>3</option>
            <option>4</option><option>5</option><option>6</option><option>7</option>
            <option>8</option>
          </select>
        </label>
        <label style="flex:1 1 220px;">Lowest desired note:
          <select id="lowNote">
            <option value="0">C</option>
            <option value="1">Db</option>
            <option value="2">D</option>
            <option value="3">Eb</option>
            <option value="4">E</option>
            <option value="5">F</option>
            <option value="6">Gb</option>
            <option value="7">G</option>
            <option value="8">Ab</option>
            <option value="9">A</option>
            <option value="10">Bb</option>
            <option value="11">B</option>
          </select>
        </label>
      </div>
      <div class="row">
        <label style="flex:1 1 220px;">Highest desired octave:
          <select id="highOct">
            <option>0</option><option>1</option><option>2</option><option>3</option>
            <option>4</option><option>5</option><option>6</option><option>7</option>
            <option>8</option>
          </select>
        </label>
        <label style="flex:1 1 220px;">Highest desired note:
          <select id="highNote">
            <option value="0">C</option>
            <option value="1">Db</option>
            <option value="2">D</option>
            <option value="3">Eb</option>
            <option value="4">E</option>
            <option value="5">F</option>
            <option value="6">Gb</option>
            <option value="7">G</option>
            <option value="8">Ab</option>
            <option value="9">A</option>
            <option value="10">Bb</option>
            <option value="11">B</option>
          </select>
        </label>
      </div>
      <p style="margin:8px 2px 0;color:#444;font-size:0.95em;">
        Files are transposed by <em>Starting Octave/Note</em> before expansion. Output is clamped to this range.
      </p>
    </div>

    <div id="gapOptions" class="gap-controls">
      Missing Note Handling:
      <select id="gapMode">
        <option value="synth">Synthesize (pitch-shift) missing notes</option>
        <option value="silent">Fill gaps with silent WAVs</option>
      </select>
    </div>

    <p id="dragMessage" style="margin-bottom:8px;display:none;"><strong>Drag the notes into the note scale order you want:</strong></p>

    <div id="fileList"></div>

    <div id="exportStatus" role="status" aria-live="polite" style="margin-top:6px; min-height:1.2em; text-align:center; font-size:0.95em; color:#333;"></div>

    <div class="action-row">
      <button id="importZipBtn" title="Load and edit an ABC Transcription Tools existing custom instrument .zip file">Import Custom Instrument (.zip)</button>
      <button id="exportZip" title="Export an ABC Transcription Tools custom instrument .zip file">Export Custom Instrument</button>
    </div>

    <!-- Hidden file inputs for controlled flows -->
    <input type="file" id="importZipInput" accept=".zip" style="display:none;">

    <script>
      function DoStartup() {
        const notes = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        let files = [];
        let originalFiles = [];

        const fileInput = document.getElementById('fileInput');
        const startNumber = document.getElementById('startNumber');
        const startNote = document.getElementById('startNote');
        const fileList = document.getElementById('fileList');
        const exportZipBtn = document.getElementById('exportZip');
        const importZipBtn = document.getElementById('importZipBtn');
        const importZipInput = document.getElementById('importZipInput');

        const autoSortCheckbox = document.getElementById('autoSort');
        const gapOptions = document.getElementById('gapOptions');
        const gapMode = document.getElementById('gapMode');
        const dragMessage = document.getElementById('dragMessage');

        const volumeScaleInput = document.getElementById('volumeScale');
        const fadeTimeInput = document.getElementById('fadeTime');

        const trimSilenceCheckbox = document.getElementById('trimSilence');
        const silenceDbInput = document.getElementById('silenceDb');
        const thresholdControls = document.getElementById('thresholdControls');
        const applyThresholdBtn = document.getElementById('applyThresholdBtn');
        const instructionsBtn = document.getElementById('instructionsBtn');

        const forceMonoWavCheckbox = document.getElementById('forceMonoWav');

        // Range Expander UI
        const rangeExpanderRow = document.getElementById('rangeExpanderRow');
        const rangeExpanderCheckbox = document.getElementById('rangeExpander');
        const rangeControls = document.getElementById('rangeControls');
        const lowOct = document.getElementById('lowOct');
        const lowNote = document.getElementById('lowNote');
        const highOct = document.getElementById('highOct');
        const highNote = document.getElementById('highNote');

        const exportStatusEl = document.getElementById('exportStatus');
        function setExportStatus(msg){ if (exportStatusEl) exportStatusEl.textContent = msg; }
        function clearExportStatus(){ if (exportStatusEl) exportStatusEl.textContent = ''; }

        // tiny yield to let UI update between heavy steps
        const tick = () => new Promise(r => setTimeout(r, 0));

        var gFileSaveName = "custom_instrument.zip";

        /* --- Preview playback state --- */
        let gPrevCtx = null;
        let gPrevSource = null;
        let gPrevGain = null;
        let gPrevBtn = null;
        let gPrevPlayId = 0;
        let gIsPlaying = false;

        // Absolute effective PI for first row
        let gRenderMinPI = 0;

        function getPreviewContext() {
          if (!gPrevCtx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            gPrevCtx = new AC();
          }
          return gPrevCtx;
        }

        function markPlaying(btn, on) {
          if (btn) {
            btn.classList.toggle('is-playing', !!on);
            btn.setAttribute('aria-pressed', on ? 'true' : 'false');
          }
          gIsPlaying = !!on;
          updateDragInteractivity();
        }

        function stopCurrentPreview() {
          try {
            if (gPrevSource) {
              gPrevSource.onended = null;
              gPrevSource.stop(0);
              gPrevSource.disconnect();
            }
            if (gPrevGain) gPrevGain.disconnect();
          } catch(e) {}
          gPrevSource = null;
          gPrevGain = null;

          if (gPrevBtn) markPlaying(gPrevBtn, false);
          gPrevBtn = null;
        }

        async function playBufferWithScale(buffer, btn) {
          const ctx = getPreviewContext();
          try { await ctx.resume(); } catch(e) {}

          const playId = ++gPrevPlayId;

          const source = ctx.createBufferSource();
          source.buffer = buffer;

          const gain = ctx.createGain();
          const scale = Math.max(0, parseFloat(volumeScaleInput.value) || 0);
          gain.gain.value = scale;

          source.connect(gain);
          gain.connect(ctx.destination);

          stopCurrentPreview();
          gPrevSource = source;
          gPrevGain = gain;
          gPrevBtn = btn;
          markPlaying(btn, true);

          source.onended = () => {
            if (playId !== gPrevPlayId) return;
            stopCurrentPreview();
          };

          source.start(0);
        }

        volumeScaleInput.addEventListener('input', () => {
          if (gPrevGain) {
            const scale = Math.max(0, parseFloat(volumeScaleInput.value) || 0);
            gPrevGain.gain.value = scale;
          }
        });

        async function previewFile(file, btn) {
          try {
            if (gPrevBtn === btn && gPrevSource) { stopCurrentPreview(); return; }
            let buf = await decodeFileToAudioBuffer(file);
            if (forceMonoWavCheckbox.checked) {
              buf = mixToMono(buf);
            }
            if (trimSilenceCheckbox.checked) {
              const thr = dbToLinear(Number(silenceDbInput.value));
              buf = trimLeadingSilenceFromBuffer(buf, thr);
            }
            await playBufferWithScale(buf, btn);
          } catch (e) {
            console.error(e);
            stopCurrentPreview();
          }
        }

        // Hashed filename detection
        let gHasHashedNames = false;
        function stripExtension(name) { const i = name.lastIndexOf('.'); return i >= 0 ? name.slice(0, i) : name; }
        const HASHLIKE_RE = /(?:^|[_\-])([0-9a-fA-F]{16,})(?:$|\b)/;
        function hasHashedFilenames(list){ return list.some(f=>HASHLIKE_RE.test(stripExtension(f.name))); }
        function applyHashedModeUIState(){ autoSortCheckbox.checked=false; gapOptions.style.display='none'; dragMessage.style.display='block'; }
        function clearHashedModeUIState(){ gapOptions.style.display=autoSortCheckbox.checked?'block':'none'; dragMessage.style.display=autoSortCheckbox.checked?'none':'block'; }

        // Pitch parsing
        const sharpToFlat = {"C#":"Db","D#":"Eb","F#":"Gb","G#":"Ab","A#":"Bb","Cs":"Db","Ds":"Eb","Fs":"Gb","Gs":"Ab","As":"Bb","CS":"Db","DS":"Eb","FS":"Gb","GS":"Ab","AS":"Bb"};
        const noteOrder = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
        const noteRegex = /([A-G][#bsS]?)(\d+)/i;
        function parsePitchFromName(name){
          const m = name.match(noteRegex); if(!m) return null;
          let note = m[1]; const octave = parseInt(m[2],10);
          note = note.charAt(0).toUpperCase()+(note.slice(1)||""); note = sharpToFlat[note] || note;
          const idx = noteOrder.indexOf(note); if (idx<0 || isNaN(octave)) return null;
          return { noteIdx: idx, octave, pitchIndex: octave*12+idx };
        }

        function detectAndApplyLowestPitch() {
          let minPI = Infinity, minNoteIdx=0, minOct=0;
          for (const f of files){ const p=parsePitchFromName(f.name); if(p && p.pitchIndex<minPI){minPI=p.pitchIndex;minNoteIdx=p.noteIdx;minOct=p.octave;} }
          if (minPI!==Infinity){ startNote.value=String(minNoteIdx); startNumber.value=String(Math.max(0,Math.min(9,minOct))); }
        }

        function sortFilesIfNeeded() {
          if (autoSortCheckbox.checked) {
            files.sort((a, b) => {
              const A = a.name.match(noteRegex), B = b.name.match(noteRegex);
              if (A && B) {
                let nA = A[1].charAt(0).toUpperCase() + (A[1].slice(1) || "");
                let nB = B[1].charAt(0).toUpperCase() + (B[1].slice(1) || "");
                nA = sharpToFlat[nA] || nA;
                nB = sharpToFlat[nB] || nB;
                const oA = parseInt(A[2], 10), oB = parseInt(B[2], 10);
                if (oA !== oB) return oA - oB;
                return noteOrder.indexOf(nA) - noteOrder.indexOf(nB);
              }
              if (A) return -1;
              if (B) return 1;
              return 0;
            });
          }
        }

        // Name for row index i (use effective absolute PI = gRenderMinPI + i)
        function getProposedNameForIndex(i, extIfNotTrim){
          const absPI = gRenderMinPI + i;
          const octave = Math.floor(absPI/12);
          const noteIndex = absPI % 12;

          if (forceMonoWavCheckbox.checked || trimSilenceCheckbox.checked) {
            return `${notes[noteIndex]}${octave}.wav`;
          }
          return `${notes[noteIndex]}${octave}.${extIfNotTrim}`;
        }

        // Desired range from UI
        function getDesiredRangePI(){
          const lo = parseInt(lowOct.value,10)*12 + parseInt(lowNote.value,10);
          const hi = parseInt(highOct.value,10)*12 + parseInt(highNote.value,10);
          if (hi >= lo) return {minPI: lo, maxPI: hi};
          return {minPI: hi, maxPI: lo};
        }

        // Build continuous range; applies Starting Octave/Note as a transpose to source pitches BEFORE expansion.
        function buildContinuousRange(){
          const matched = [], unmatched = [];
          const seen = new Set();
          let hasDuplicatePitch = false;

          for (const f of files){
            const p = parsePitchFromName(f.name);
            if (p){
              if (p.octave > 8){
                DayPilot.Modal.alert(
                  '<p style="text-align:center;font-size:1.1em;"><strong>Note Octave Out-of-Range Detected (Max is 8)</strong><br/><br/>Auto-sort and note range detect will be disabled.</p>',
                  { theme:"modal_flat", top:200 }
                );
                applyHashedModeUIState();
                setTimeout(()=>{ files=[...originalFiles]; safeRenderList(); }, 250);
                return { full:[], unmatched: files.slice(), nameBasePI:0, minPI:0, maxPI:-1 };
              }

              if (seen.has(p.pitchIndex)) hasDuplicatePitch = true;
              else { seen.add(p.pitchIndex); matched.push({ file:f, pitchIndex:p.pitchIndex, ext:f.name.split('.').pop() }); }
            } else {
              unmatched.push(f);
            }
          }

          if (hasDuplicatePitch) {
            DayPilot.Modal.alert(
              '<p style="text-align:center;font-size:1.1em;"><strong>Duplicate Pitch Detected</strong><br/><br/>Two or more files map to the same pitch.<br/><br/>Auto-sort and note range detect have been disabled.</p>',
              { theme:"modal_flat", top:200 }
            );
            applyHashedModeUIState();
            setTimeout(()=>{ files=[...originalFiles]; safeRenderList(); }, 250);
            return { full:[], unmatched: files.slice(), nameBasePI:0, minPI:0, maxPI:-1 };
          }

          if (!matched.length) return { full:[], unmatched, nameBasePI:0, minPI:0, maxPI:-1 };

          matched.sort((a,b)=>a.pitchIndex-b.pitchIndex);
          const actualMinPI = matched[0].pitchIndex;
          const actualMaxPI = matched[matched.length-1].pitchIndex;

          // Starting Octave/Note -> basePI
          const basePI = parseInt(startNumber.value,10)*12 + parseInt(startNote.value,10);
          const transpose = basePI - actualMinPI;

          // Effective pitch map
          const effPitchMap = new Map();
          let effMin = Infinity, effMax = -Infinity;
          for (const m of matched){
            const effPI = m.pitchIndex + transpose;
            effPitchMap.set(effPI, { file: m.file, ext: m.ext });
            if (effPI < effMin) effMin = effPI;
            if (effPI > effMax) effMax = effPI;
          }

          // Final render range
          let finalMinPI = effMin;
          let finalMaxPI = effMax;

          if (rangeExpanderCheckbox.checked) {
            const desired = getDesiredRangePI();
            finalMinPI = desired.minPI;
            finalMaxPI = desired.maxPI;
          }

          const full = [];
          for (let pi = finalMinPI; pi <= finalMaxPI; pi++){
            const m = effPitchMap.get(pi) || null;
            full.push({ file: m ? m.file : null, pitchIndex: pi, ext: m ? m.ext : "wav" });
          }

          return { full, unmatched, nameBasePI: basePI, minPI: finalMinPI, maxPI: finalMaxPI, effMin, effMax, transpose };
        }

        /* ====== Audio utils ====== */
        let gDecodeOffline = null;
        function getDecodeOffline(){
          if (!gDecodeOffline) gDecodeOffline = new OfflineAudioContext(1, 1, 44100);
          return gDecodeOffline;
        }

        const decodeCache = new WeakMap();
        async function decodeFileToAudioBuffer(file){
          if (decodeCache.has(file)) return decodeCache.get(file);
          const p = (async ()=>{
            const offline = getDecodeOffline();
            const arr = await file.arrayBuffer();
            return await offline.decodeAudioData(arr.slice(0));
          })();
          decodeCache.set(file,p);
          return p;
        }

        async function pitchShiftBuffer(srcBuf, semitones){
          const rate = Math.pow(2, semitones/12);
          const outLength = Math.max(1, Math.ceil(srcBuf.length / rate));
          const offline = new OfflineAudioContext(srcBuf.numberOfChannels, outLength, srcBuf.sampleRate);
          const src = offline.createBufferSource();
          src.buffer = srcBuf;
          src.playbackRate.value = rate;
          src.connect(offline.destination);
          src.start();
          return await offline.startRendering();
        }

        function generateSilentWav(durationSec=1, sampleRate=44100){
          const numSamples = Math.floor(durationSec*sampleRate);
          const buffer = new ArrayBuffer(44 + numSamples*2);
          const view = new DataView(buffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          ws(0,"RIFF"); view.setUint32(4, 36+numSamples*2, true); ws(8,"WAVE"); ws(12,"fmt ");
          view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,1,true);
          view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
          view.setUint16(32,2,true); view.setUint16(34,16,true); ws(36,"data");
          view.setUint32(40,numSamples*2,true);
          return new Blob([buffer], {type:"audio/wav"});
        }

        function audioBufferToWav(buffer){
          const numChannels=buffer.numberOfChannels, sampleRate=buffer.sampleRate;
          const length=buffer.length*numChannels*2+44;
          const arrayBuffer=new ArrayBuffer(length); const view=new DataView(arrayBuffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          let pos=0; ws(pos,"RIFF"); pos+=4; view.setUint32(pos,length-8,true); pos+=4;
          ws(pos,"WAVE"); pos+=4; ws(pos,"fmt "); pos+=4; view.setUint32(pos,16,true); pos+=4;
          view.setUint16(pos,1,true); pos+=2; view.setUint16(pos,numChannels,true); pos+=2;
          view.setUint32(pos,sampleRate,true); pos+=4; view.setUint32(pos,sampleRate*numChannels*2,true); pos+=4;
          view.setUint16(pos,numChannels*2,true); pos+=2; view.setUint16(pos,16,true); pos+=2;
          ws(pos,"data"); pos+=4; view.setUint32(pos,length-44,true); pos+=4;
          const channels=[]; for(let i=0;i<numChannels;i++) channels.push(buffer.getChannelData(i));
          for(let i=0;i<buffer.length;i++){
            for(let ch=0; ch<numChannels; ch++){
              let s=channels[ch][i]; s=Math.max(-1,Math.min(1,s));
              view.setInt16(pos, s<0 ? s*0x8000 : s*0x7FFF, true); pos+=2;
            }
          }
          return new Blob([arrayBuffer], {type:"audio/wav"});
        }

        function dbToLinear(db){ return Math.pow(10, db/20); }

        function trimLeadingSilenceFromBuffer(buffer, thresholdLinear){
          const numChannels=buffer.numberOfChannels, length=buffer.length, sr=buffer.sampleRate;
          const preRollSamples = Math.round(sr*0.003);
          const windowSize = Math.max(32, Math.round(sr*0.001));
          let startIndex=0, found=false;
          for (let i=0; i<length; i+=windowSize){
            let maxAbs=0;
            for(let ch=0; ch<numChannels; ch++){
              const data=buffer.getChannelData(ch);
              const end=Math.min(i+windowSize,length);
              for(let s=i; s<end; s++){ const v=Math.abs(data[s]); if(v>maxAbs) maxAbs=v; }
              if (maxAbs>=thresholdLinear) break;
            }
            if (maxAbs>=thresholdLinear){ startIndex=Math.max(0, i-preRollSamples); found=true; break; }
          }
          if (!found){
            const tiny=Math.min(length, Math.round(sr*0.01));
            startIndex=Math.max(0, length-tiny);
          }
          const newLength=Math.max(1, length-startIndex);
          const out=new AudioBuffer({length:newLength, numberOfChannels:numChannels, sampleRate:sr});
          for(let ch=0; ch<numChannels; ch++){
            const src=buffer.getChannelData(ch).subarray(startIndex, startIndex+newLength);
            out.copyToChannel(src, ch, 0);
          }
          return out;
        }

        // RMS-preserving mono (with peak cap)
        function mixToMono(buffer){
          if (buffer.numberOfChannels === 1) return buffer;

          const len = buffer.length;
          const sr  = buffer.sampleRate;
          const chs = buffer.numberOfChannels;

          const mono = new Float32Array(len);

          let sumSquaresOrig = 0;
          for (let i = 0; i < len; i++) {
            let sum = 0;
            let power = 0;
            for (let ch = 0; ch < chs; ch++) {
              const v = buffer.getChannelData(ch)[i];
              sum   += v;
              power += v * v;
            }
            mono[i] = sum;
            sumSquaresOrig += power / chs;
          }

          let sumSquaresMono = 0;
          let peakMono = 0;
          for (let i = 0; i < len; i++) {
            const v = mono[i];
            sumSquaresMono += v * v;
            const av = Math.abs(v);
            if (av > peakMono) peakMono = av;
          }

          const rmsOrig = Math.sqrt(sumSquaresOrig / len);
          const rmsMono = Math.sqrt(sumSquaresMono / len);

          let gain = 1.0;
          if (rmsMono > 0 && rmsOrig > 0) {
            gain = rmsOrig / rmsMono;
          }
          if (peakMono > 0 && peakMono * gain > 1.0) {
            gain = 1.0 / peakMono;
          }

          if (gain !== 1.0) {
            for (let i = 0; i < len; i++) mono[i] *= gain;
          }

          const out = new AudioBuffer({ length: len, numberOfChannels: 1, sampleRate: sr });
          out.copyToChannel(mono, 0, 0);
          return out;
        }

        async function bufferToFinalBlob(buffer){
          if (forceMonoWavCheckbox.checked) {
            buffer = mixToMono(buffer);
          }
          if (trimSilenceCheckbox.checked){
            const thr = dbToLinear(Number(silenceDbInput.value));
            buffer = trimLeadingSilenceFromBuffer(buffer, thr);
          }
          return audioBufferToWav(buffer);
        }

        async function fileToProcessedBlob(file){
          const needsProcessing = trimSilenceCheckbox.checked || forceMonoWavCheckbox.checked;
          if (!needsProcessing) return file;
          const buf = await decodeFileToAudioBuffer(file);
          return bufferToFinalBlob(buf);
        }

        // ---------- Placeholder PREVIEW helpers ----------
        function findNearestSourceIndex(full, targetIdx){
          for (let d=1; d<full.length; d++){
            const lower = targetIdx - d;
            const higher = targetIdx + d;
            if (lower >= 0 && full[lower] && full[lower].file) return lower;
            if (higher < full.length && full[higher] && full[higher].file) return higher;
          }
          return -1;
        }

        async function previewPlaceholderAtIndex(full, idx, btn){
          try {
            if (gPrevBtn === btn && gPrevSource) { stopCurrentPreview(); return; }
            const srcIdx = findNearestSourceIndex(full, idx);
            if (srcIdx < 0) return;
            const srcFile = full[srcIdx].file;
            let buf = await decodeFileToAudioBuffer(srcFile);
            if (forceMonoWavCheckbox.checked) buf = mixToMono(buf);
            if (trimSilenceCheckbox.checked) {
              const thr = dbToLinear(Number(silenceDbInput.value));
              buf = trimLeadingSilenceFromBuffer(buf, thr);
            }
            const semitones = idx - srcIdx;
            const shifted = await pitchShiftBuffer(buf, semitones);
            await playBufferWithScale(shifted, btn);
          } catch (e) {
            console.warn("Placeholder preview failed:", e);
            stopCurrentPreview();
          }
        }

        // ---------- RENDER LIST ----------
        function safeRenderList(){
          if (gPrevSource) return;
          renderList();
        }

        function renderList(){
          fileList.innerHTML='';

          // Manual mode = Auto Sort OFF and Range Expander OFF
          if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked){
            // Anchor manual naming to Starting Octave/Note
            gRenderMinPI = parseInt(startNumber.value,10)*12 + parseInt(startNote.value,10);

            files.forEach((file,i)=>{
              const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=i;
              const ext=file.name.split('.').pop(); const proposedName=getProposedNameForIndex(i,ext);
              const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposedName}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item); fileList.appendChild(item);
            });
            updateDragInteractivity();
            return;
          }

          const built = buildContinuousRange();
          const { full, unmatched, minPI, maxPI } = built;
          if (minPI <= maxPI) gRenderMinPI = minPI;

          if (!full.length){
            files.forEach((file,i)=>{
              const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=i;
              const ext=file.name.split('.').pop(); const proposedName=getProposedNameForIndex(i,ext);
              const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposedName}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item); fileList.appendChild(item);
            });
            updateDragInteractivity();
            return;
          }

          full.forEach((slot,idx)=>{
            const item=document.createElement('div');
            if (slot.file){
              item.className='file-item real'; item.draggable=true; item.dataset.fileName=slot.file.name;
              const originalIndex=files.findIndex(f=>f===slot.file); if (originalIndex>=0) item.dataset.index=String(originalIndex);
              const nameSpan=document.createElement('span'); nameSpan.textContent=slot.file.name;
              const proposed=getProposedNameForIndex(idx,slot.ext);
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposed}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(slot.file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item);
            } else {
              item.className='file-item';
              const proposed=getProposedNameForIndex(idx,"wav");
              const modeLabel=(gapMode.value==='synth')?' (synthesized)':' (silent)';
              const ctrl=document.createElement('div'); ctrl.className='controls';
              if (gapMode.value==='synth'){
                const pbtn=document.createElement('button'); pbtn.className='preview-btn'; pbtn.type='button'; pbtn.textContent='▶︎';
                pbtn.title = 'Preview synthesized placeholder';
                pbtn.addEventListener('click',(e)=>previewPlaceholderAtIndex(full, idx, e.currentTarget));
                ctrl.appendChild(pbtn);
              }
              item.innerHTML=`<span class="placeholder-label">(placeholder)</span><span class="proposed">→ ${proposed}${modeLabel}</span>`;
              item.appendChild(ctrl);
            }
            fileList.appendChild(item);
          });

          if (!rangeExpanderCheckbox.checked && unmatched.length){
            const startIdx=full.length;
            unmatched.forEach((file,j)=>{
              const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=files.findIndex(f=>f===file);
              const ext=file.name.split('.').pop(); const proposed=getProposedNameForIndex(startIdx+j,ext);
              const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposed}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item); fileList.appendChild(item);
            });
          }

          updateDragInteractivity();
        }

        function addDragHandlers(el){
          el.addEventListener('dragstart',(e)=>{
            if (!el.classList.contains('real')){ e.preventDefault(); return; }
            if (fileList.classList.contains('drag-disabled')) { e.preventDefault(); return; }
            e.dataTransfer.setData('text/plain', el.dataset.index);
            el.classList.add('dragging');
            if (gPrevSource) stopCurrentPreview();
          });
          el.addEventListener('dragend',()=>{
            el.classList.remove('dragging');
            const newOrder = Array.from(fileList.children)
              .filter(c=>c.dataset.index!==undefined && c.dataset.index!==null)
              .map(c=>files[Number(c.dataset.index)]);
            if (newOrder.length) files=newOrder;
            safeRenderList();
          });
          el.addEventListener('dragover',(e)=>{
            if (!document.querySelector('.dragging')) return;
            e.preventDefault();
            const dragging=document.querySelector('.dragging');
            const rect=el.getBoundingClientRect();
            const offset=e.clientY-rect.top;
            const parent=el.parentNode;
            if (offset > rect.height/2) parent.insertBefore(dragging, el.nextSibling);
            else parent.insertBefore(dragging, el);
          });
        }

        fileList.addEventListener('dragover',(e)=>{
          const scrollZone=40, scrollSpeed=4;
          const rect=fileList.getBoundingClientRect();
          if (e.clientY<rect.top+scrollZone) fileList.scrollTop-=scrollSpeed;
          else if (e.clientY>rect.bottom-scrollZone) fileList.scrollTop+=scrollSpeed;
        });

        fileList.addEventListener('dragstart', () => { if (gPrevSource) stopCurrentPreview(); });

        function updateDragInteractivity() {
          const realRows = fileList.querySelectorAll('.file-item.real');
          const enableDrag = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked && !gIsPlaying;
          realRows.forEach(row => row.setAttribute('draggable', enableDrag ? 'true' : 'false'));
          fileList.classList.toggle('drag-disabled', !enableDrag);

          const autoMode = autoSortCheckbox.checked || rangeExpanderCheckbox.checked;
          gapOptions.style.display = autoMode ? 'block' : 'none';
          dragMessage.style.display = autoMode ? 'none' : 'block';

          // Range Expander availability depends on Auto Sort
          rangeExpanderRow.style.display = autoSortCheckbox.checked ? 'block' : 'none';
          if (!autoSortCheckbox.checked) {
            rangeExpanderCheckbox.checked = false;
            rangeControls.style.display = 'none';
          } else {
            rangeControls.style.display = rangeExpanderCheckbox.checked ? 'block' : 'none';
          }
        }

        // ===================== Export (ZIP) =====================
        exportZipBtn.addEventListener('click', async ()=>{
          if (gPrevSource) stopCurrentPreview();

          // UI prep
          exportZipBtn.disabled = true;
          setExportStatus('Starting export…');

          async function saveZipFile(fname){
            if (fileList.children.length == 0 || !files.length){
              DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme:"modal_flat", top:200 });
              exportZipBtn.disabled = false;
              clearExportStatus();
              return;
            }

            const zip = new JSZip();

            // Meta
            let volumeScale = parseFloat(volumeScaleInput.value);
            let fadeTimeMs  = parseInt(fadeTimeInput.value, 10);
            if (isNaN(volumeScale)) volumeScale = 1.0;
            if (isNaN(fadeTimeMs))  fadeTimeMs  = 100;
            if (volumeScale < 0) volumeScale = 0;
            if (fadeTimeMs  < 0) fadeTimeMs  = 0;

            const meta = {
              volumeScale,
              fadeTimeMs,
              trimLeadingSilence: !!trimSilenceCheckbox.checked,
              silenceThresholdDb: Number(silenceDbInput.value),
              forceMonoWav: !!forceMonoWavCheckbox.checked,
              rangeExpander: !!rangeExpanderCheckbox.checked,
              desiredRange: rangeExpanderCheckbox.checked ? {
                lowOct: parseInt(lowOct.value,10),
                lowNote: parseInt(lowNote.value,10),
                highOct: parseInt(highOct.value,10),
                highNote: parseInt(highNote.value,10)
              } : null
            };
            zip.file("abctools.json", JSON.stringify(meta,null,2));

            // Progress accounting
            let processedCount = 0;
            let plannedCount   = 0;

            function updateStep(label){
              processedCount++;
              setExportStatus(`Processing ${processedCount} of ${plannedCount}… ${label || ''}`.trim());
            }

            // Figure out how many files we'll write
            (function computePlannedCount(){
              if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked) {
                // manual mode: count visible "real" rows
                plannedCount = Array.from(fileList.children).filter(el => el.classList.contains('real')).length;
              } else {
                const plan = (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) ? buildContinuousRange() : null;
                if (plan && plan.full && plan.full.length) {
                  plannedCount = plan.full.length;
                  if (!rangeExpanderCheckbox.checked && plan.unmatched && plan.unmatched.length) {
                    plannedCount += plan.unmatched.length;
                  }
                } else {
                  plannedCount = files.length;
                }
              }
            })();
            await tick();

            // Build only if needed
            let built = null, full = null;
            if (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) {
              built = buildContinuousRange();
              full  = built.full;
            }

            // ---- Branch: Manual mode ----
            if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked){
              const reordered = Array.from(fileList.children)
                .filter(el => el.classList.contains('real'))
                .map(el => files[Number(el.dataset.index)]);

              for (let i = 0; i < reordered.length; i++){
                const file = reordered[i];
                const ext  = file.name.split('.').pop();
                const newName = getProposedNameForIndex(i, ext);
                const outBlob = await fileToProcessedBlob(file);
                zip.file(newName, outBlob);
                updateStep(newName);
                await tick();
              }

            // ---- Branch: Auto/Range mode ----
            } else {
              const unmatched = built ? built.unmatched : [];

              if (!full || !full.length){
                for (let i = 0; i < files.length; i++){
                  const file = files[i];
                  const ext  = file.name.split('.').pop();
                  const newName = getProposedNameForIndex(i, ext);
                  const outBlob = await fileToProcessedBlob(file);
                  zip.file(newName, outBlob);
                  updateStep(newName);
                  await tick();
                }
              } else {
                // Pre-decode sources for synth where possible
                const haveAtIndex = new Map(); // renderIdx -> file
                full.forEach((slot,i)=>{ if (slot.file) haveAtIndex.set(i, slot.file); });

                const decodedAtIndex = new Map();
                await Promise.all(Array.from(haveAtIndex.entries()).map(async ([i, file])=>{
                  try { decodedAtIndex.set(i, await decodeFileToAudioBuffer(file)); }
                  catch(e){ console.warn("Decode failed:", file.name, e); }
                }));

                function findSourceIndex(targetIdx){
                  for (let d=1; d<full.length; d++){
                    const lower = targetIdx - d, higher = targetIdx + d;
                    if (lower >= 0 && decodedAtIndex.has(lower)) return lower;
                    if (higher < full.length && decodedAtIndex.has(higher)) return higher;
                  }
                  return -1;
                }

                for (let i = 0; i < full.length; i++){
                  const slot = full[i];

                  if (slot.file){
                    const ext = slot.ext;
                    const proposed = getProposedNameForIndex(i, ext);
                    const outBlob = await fileToProcessedBlob(slot.file);
                    zip.file(proposed, outBlob);
                    updateStep(proposed);
                    await tick();

                  } else {
                    const proposed = getProposedNameForIndex(i, "wav");
                    if (gapMode.value === 'silent'){
                      zip.file(proposed, generateSilentWav(1));
                      updateStep(proposed);
                      await tick();
                    } else {
                      const srcIdx = findSourceIndex(i);
                      if (srcIdx >= 0){
                        try{
                          const srcBuf = decodedAtIndex.get(srcIdx);
                          const semitones = i - srcIdx; // effective PI space
                          const shiftedBuf = await pitchShiftBuffer(srcBuf, semitones);
                          const outBlob = await bufferToFinalBlob(shiftedBuf);
                          zip.file(proposed, outBlob);
                        } catch(e){
                          console.warn("Synthesis failed at index", i, e);
                          zip.file(proposed, generateSilentWav(1));
                        }
                      } else {
                        zip.file(proposed, generateSilentWav(1));
                      }
                      updateStep(proposed);
                      await tick();
                    }
                  }
                }

                // Keep strict range when expander is off: append unmatched tail
                if (!rangeExpanderCheckbox.checked && unmatched.length){
                  const startIdx = full.length;
                  for (let j = 0; j < unmatched.length; j++){
                    const file = unmatched[j];
                    const ext  = file.name.split('.').pop();
                    const proposed = getProposedNameForIndex(startIdx + j, ext);
                    const outBlob = await fileToProcessedBlob(file);
                    zip.file(proposed, outBlob);
                    updateStep(proposed);
                    await tick();
                  }
                }
              }
            }

            // Generate final blob with progress
            setExportStatus(`Zipping files… 0%`);
            const blob = await zip.generateAsync(
              { type: "blob" },
              (meta) => {
                const pct = Math.max(0, Math.min(100, Math.round(meta.percent || 0)));
                setExportStatus(`Zipping files… ${pct}%`);
              }
            );

            setExportStatus('Export complete. Saving…');
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fname;
            a.click();
            setTimeout(()=>{ window.URL.revokeObjectURL(a.href); }, 1000);

            clearExportStatus();
            exportZipBtn.disabled = false;
          };

          // Filename prompt
          const thePrompt = "Please enter a filename for your custom instrument file:";
          DayPilot.Modal.prompt(thePrompt, gFileSaveName, { theme:"modal_flat", top:200, autoFocus:true })
          .then(function(args){
            let fname = args.result;
            if (fname == null || fname.length == 0){
              exportZipBtn.disabled = false;
              clearExportStatus();
              return;
            }
            if (!fname.endsWith(".zip")){
              fname = fname.replace(/\..+$/,'');
              fname = fname + ".zip";
            }
            gFileSaveName = fname;
            sortFilesIfNeeded();
            // run export
            return saveZipFile(fname);
          })
          .catch((e)=>{
            console.error(e);
            DayPilot.Modal.alert('<p style="text-align:center">Export failed.</p>', { theme:"modal_flat", top:200 });
          })
          .finally(()=>{
            // safety: ensure UI is usable even if we exited early
            exportZipBtn.disabled = false;
          });
        });


        // ===================== Import Existing Instrument (.zip) =====================
        importZipBtn.addEventListener('click', () => {
          importZipInput.value = "";
          importZipInput.click();
        });

        // Helpers to ignore macOS sidecars and clean names
        function isIgnorableZipEntry(path) {
          if (path.startsWith('__MACOSX/')) return true;
          const base = path.split('/').pop();
          if (!base) return true;
          if (base.startsWith('._')) return true; // AppleDouble like ._A4.wav
          if (base === '.DS_Store' || base === 'Thumbs.db') return true;
          return false;
        }
        function sanitizeBaseName(path) {
          let base = path.split('/').pop() || path;
          if (base.startsWith('./')) base = base.slice(2);
          return base;
        }

        importZipInput.addEventListener('change', async (e) => {
          const zipFile = e.target.files && e.target.files[0];
          if (!zipFile) return;

          try {
            if (gPrevSource) stopCurrentPreview();

            const zip = await JSZip.loadAsync(zipFile);

            // Read abctools.json if present (to apply volumeScale and fadeTimeMs)
            let importedVolumeScale = null;
            let importedFadeTimeMs = null;
            const metaEntry = Object.keys(zip.files).find(n => n.toLowerCase() === "abctools.json");
            if (metaEntry) {
              try {
                const metaText = await zip.file(metaEntry).async("string");
                const meta = JSON.parse(metaText);
                if (meta && typeof meta.volumeScale === "number" && meta.volumeScale >= 0) {
                  importedVolumeScale = meta.volumeScale;
                }
                if (meta && typeof meta.fadeTimeMs === "number" && meta.fadeTimeMs >= 0) {
                  importedFadeTimeMs = meta.fadeTimeMs;
                }
              } catch {}
            }

            // Collect valid audio files, ignoring macOS sidecars and duplicates
            const imported = [];
            const seen = new Set(); // case-insensitive basename dedupe

            const entries = Object.keys(zip.files)
              .filter(n => !zip.files[n].dir)
              .filter(n => /\.(wav|mp3)$/i.test(n));

            for (const path of entries) {
              if (isIgnorableZipEntry(path)) continue;

              const baseName = sanitizeBaseName(path);
              const key = baseName.toLowerCase();
              if (seen.has(key)) continue;
              seen.add(key);

              const blob = await zip.file(path).async("blob");
              const ext = baseName.split('.').pop().toLowerCase();
              const mime = (ext === 'wav') ? 'audio/wav' : (ext === 'mp3' ? 'audio/mpeg' : 'application/octet-stream');

              const f = new File([blob], baseName, { type: mime });
              imported.push(f);
            }

            if (!imported.length) {
              DayPilot.Modal.alert('<p style="text-align:center">No audio files found in .zip</p>', { theme:"modal_flat", top:200 });
              return;
            }

            // Apply requested option changes when importing a .zip
            trimSilenceCheckbox.checked = false;
            thresholdControls.style.display = 'none';
            forceMonoWavCheckbox.checked = false;
            rangeExpanderCheckbox.checked = false;      // UI will hide via updateDragInteractivity()

            if (importedVolumeScale !== null) {
              volumeScaleInput.value = String(importedVolumeScale);
              if (gPrevGain) gPrevGain.gain.value = importedVolumeScale;
            }
            if (importedFadeTimeMs !== null) {
              fadeTimeInput.value = String(importedFadeTimeMs);
            }

            // Replace current file set with imported files
            originalFiles = [...imported];
            files = [...imported];

            // Treat just like normal files from disk
            gHasHashedNames = hasHashedFilenames(files);
            if (gHasHashedNames){
              applyHashedModeUIState();
              DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.</p>', { theme:"modal_flat", top:200 });
            } else {
              clearHashedModeUIState();
              sortFilesIfNeeded();
              if ((autoSortCheckbox.checked || rangeExpanderCheckbox.checked) && !gHasHashedNames) {
                detectAndApplyLowestPitch();
              }
            }

            // Reset Range Expander range like normal file import
            if (autoSortCheckbox.checked) {
              const built = buildContinuousRange();
              if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
                const loOct = Math.floor(built.effMin / 12), loNote = built.effMin % 12;
                const hiOct = Math.floor(built.effMax / 12), hiNote = built.effMax % 12;
                lowOct.value = String(loOct);  lowNote.value = String(loNote);
                highOct.value = String(hiOct); highNote.value = String(hiNote);
              }
            }

            rangeControls.style.display = 'none';

            safeRenderList();
            updateDragInteractivity();

          } catch (err) {
            console.error("Import zip failed:", err);
            DayPilot.Modal.alert('<p style="text-align:center">Failed to import .zip</p>', { theme:"modal_flat", top:200 });
          }
        });


        // ===== UI wiring =====

        fileInput.addEventListener('change',(e)=>{
          originalFiles=Array.from(e.target.files);
          files=[...originalFiles];

          gHasHashedNames=hasHashedFilenames(files);
          if (gHasHashedNames){
            applyHashedModeUIState();
            DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.</p>', { theme:"modal_flat", top:200 });
          } else { clearHashedModeUIState(); }

          sortFilesIfNeeded();

          if ((autoSortCheckbox.checked || rangeExpanderCheckbox.checked) && !gHasHashedNames) {
            detectAndApplyLowestPitch();
          }

          // Initialize Range Expander desired range to EFFECTIVE range (after transpose)
          if (autoSortCheckbox.checked) {
            const built = buildContinuousRange();
            if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
              const loOct = Math.floor(built.effMin/12), loNote = built.effMin%12;
              const hiOct = Math.floor(built.effMax/12), hiNote = built.effMax%12;
              lowOct.value = String(loOct); lowNote.value = String(loNote);
              highOct.value = String(hiOct); highNote.value = String(hiNote);
            }
          }

          safeRenderList();
          updateDragInteractivity();
        });

        function handleStartingControlsChange() {
          if (gPrevSource) stopCurrentPreview();
          safeRenderList();
          updateDragInteractivity();
        }

        startNumber.addEventListener('change', handleStartingControlsChange);
        startNote.addEventListener('change', handleStartingControlsChange);

        autoSortCheckbox.addEventListener('change', ()=>{
          if (!autoSortCheckbox.checked) {
            rangeExpanderCheckbox.checked = false;
            rangeControls.style.display = 'none';
          }
          sortFilesIfNeeded();
          if (autoSortCheckbox.checked && !gHasHashedNames) detectAndApplyLowestPitch();

          if (autoSortCheckbox.checked) {
            const built = buildContinuousRange();
            if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
              const loOct = Math.floor(built.effMin/12), loNote = built.effMin%12;
              const hiOct = Math.floor(built.effMax/12), hiNote = built.effMax%12;
              lowOct.value = String(loOct); lowNote.value = String(loNote);
              highOct.value = String(hiOct); highNote.value = String(hiNote);
            }
          }

          safeRenderList();
          updateDragInteractivity();
        });

        gapMode.addEventListener('change', () => {
          stopPreviewIfPlaying();   // stop any current audition
          safeRenderList();         // re-render rows for the new mode
        });

        // Trim UI
        trimSilenceCheckbox.checked=false;
        thresholdControls.style.display='none';

        trimSilenceCheckbox.addEventListener('change', ()=>{
          stopPreviewIfPlaying();   // <-- stop current audition
          thresholdControls.style.display = trimSilenceCheckbox.checked ? 'block' : 'none';
          safeRenderList();
        });

        // For the "Force mono .wav" checkbox
        forceMonoWavCheckbox.addEventListener('change', () => {
          stopPreviewIfPlaying();   // <-- stop current audition
          safeRenderList();
        });

        applyThresholdBtn.addEventListener('click', () => {
          safeRenderList();
          const status = document.getElementById('applyStatus');
          status.textContent = 'Applied';
          status.classList.add('show');
          applyThresholdBtn.disabled = true;
          setTimeout(() => {
            status.classList.remove('show');
            applyThresholdBtn.disabled = false;
          }, 1200);
        });

        silenceDbInput.addEventListener('input', () => {
          const status = document.getElementById('applyStatus');
          status.classList.remove('show');
        });

        // Range Expander wiring
        function stopPreviewIfPlaying(){ if (gPrevSource) stopCurrentPreview(); }

        function updateRangeExpanderUI(){

          stopPreviewIfPlaying(); 
  
          const on = rangeExpanderCheckbox.checked;
          if (!autoSortCheckbox.checked) {
            rangeExpanderCheckbox.checked = false;
          }
          rangeControls.style.display = (on && autoSortCheckbox.checked) ? 'block' : 'none';

          sortFilesIfNeeded();
          safeRenderList();
          updateDragInteractivity();
        }

        rangeExpanderCheckbox.addEventListener('change', updateRangeExpanderUI);
        const handleRangeValueChange = () => { stopPreviewIfPlaying(); safeRenderList(); };
        lowOct.addEventListener('change', handleRangeValueChange);
        lowNote.addEventListener('change', handleRangeValueChange);
        highOct.addEventListener('change', handleRangeValueChange);
        highNote.addEventListener('change', handleRangeValueChange);

        // Instructions modal
        instructionsBtn.addEventListener('click', async () => {
          const html = `
            <div class="instr-modal">
             <h2>Instructions</h2>
              <p>This tool is used to create an ABC Transcription Tools custom instrument from a directory of per-note instrument audio sample files.</p>
              <p>The files should be in .wav or .mp3 format. The samples must all be in the same directory.</p>
              <p><strong>1)</strong> Click <strong>Choose Files</strong> (<strong>Browse...</strong> on Firefox) to import your audio sample files.</p>
              <p>You can import an existing custom instrument by clicking <strong>Import Custom Instrument (.zip)</strong>.</p>
              <p>The note output filename for each audio sample is displayed to the right of each note.</p>
              <p><strong>2)</strong> Select the default volume scale and fade time for the instrument.</p>
              <p>These values will be applied to the instrument when used in the <strong>ABC Transcription Tools</strong>.</p>
              <p><strong>3)</strong> Choose the starting octave number for the instrument notes.</p>
              <p><strong>4)</strong> Choose the starting scale note for the file names.</p>
              <p><strong>5)</strong> If your files have filenames that contain note names, check <strong>Automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> to align the sample file list with the note names (checked by default).</p>
              <p><strong>6)</strong> When automatically sorting by scale order, if there are scale gaps found, select between either synthesizing (pitch shifting) the missing note samples in the scale from other available notes or just replacing them with placeholder silent files.</p>
              <p><strong>7)</strong> <em>Optional:</em> Turn on the <strong>Range Expander</strong> (available only with Auto Sort) to set a lowest and highest desired note. The ends of the list will match your requested notes exactly, while the lowest <em>actual</em> input sample keeps the label set by “Starting Octave/Note”.</p>
              <p><strong>8)</strong> If not automatically sorting files by scale order, you can drag-and-drop the items in the list into the scale note order you want. This can be useful for loops/stems or non-pitched percussion instruments.</p>
              <p><strong>9)</strong> <em>Optional:</em> Enable <strong>Trim leading silence</strong> and set a <strong>Silence threshold (dB)</strong> to remove silence at the start of each file. Smaller dB values are more sensitive (e.g., -40 to -50 dB is typical). Click <strong>Apply</strong> to apply the update the silence trimming to all the samples.</p>
              <p><strong>10)</strong> <em>Optional:</em> Enable <strong>Encode all exported files as mono .wav</strong> to force every exported file to mono .wav format, regardless of input type.</p>
              <p>This applies to both normal export and silence-trimmed files and may reduce the custom instrument size if the original samples were stereo .wav files.</p>
              <p><strong>11)</strong> Click the ▶︎ buttons to audition the notes with the current volume scale, silence trimming, and stereo-to-mono conversion settings.</p>
              <p><strong>12)</strong> Click <strong>Export Custom Instrument</strong> to export the final custom instrument.</p>
              <p>The .zip file is saved to your browser’s default <strong>Downloads</strong> folder.</p>
              <hr>
              <h4>Additional Resources</h4>
              <p style="text-align:center;margin-top:12px;">User Guide Information on Custom Instrument Creation</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/userguide.html#creating_custom_midi_instruments" target="_blank">ABC Transcription Tools User Guide: Custom Instruments</a></p>
              <p style="text-align:center;margin-top:12px;">UltraBox Utility for Extracting Samples from .sf2 Soundfonts</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/tools/UltraBox/UltraBox_Sample_Extractor.html" target="_blank">UltraBox Sample Extractor</a></p>
              <hr>
              <h4>Credits</h4>
              <p style="text-align:center;">This tool uses several open-source Javascript libraries, credits can be found here:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/credits.html" target="_blank">Credits</a></p>
              <hr>
              <h4>Tip Jars</h4>
              <p style="text-align:center;">This tool was created by <a href="https://michaeleskin.com" target="_blank">Michael Eskin</a>.</p>
              <p style="text-align:center;">If you find it useful, please consider making a contribution via my online tip jars:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/tipjars.html" target="_blank">Tip Jars</a></p>
            </div>
          `;
          await DayPilot.Modal.alert(html, { theme: "modal_flat", top: 25, width: 780 });
        });

        // Range defaults
        lowOct.value = "3";  lowNote.value = "0";    // C3
        highOct.value = "6"; highNote.value = "0";   // C6

        updateDragInteractivity();
      }

      // Utility: MIME guess (kept simple)
      function guessMimeByExt(name){
        const ext = (name.split('.').pop()||'').toLowerCase();
        if (ext==='wav') return 'audio/wav';
        if (ext==='mp3') return 'audio/mpeg';
        return 'application/octet-stream';
      }

      function WaitForReady(fn){
        if (document.readyState!=='loading'){ fn(); return; }
        document.addEventListener('DOMContentLoaded', fn);
      }

      WaitForReady(DoStartup);

    </script>

  </body>

</html>
