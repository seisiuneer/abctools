<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="UTF-8">
    <title>ABC Transcription Tools - Custom Instrument Builder</title>
    <script type="text/javascript" src="jszip-min.js?v=3"></script>
    <script type="text/javascript" src="filesaver-min.js?v=3"></script>
    <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=3"></script>
    
    <style>
    body {
      background: #fafafa;
      color: #222;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 12.5px auto;               
      padding: 0 19px;                   
      line-height: 1.47;                 
    }

    h1 {
      margin-top: 14.5px;                
      font-size: 1.73em;                 
      margin-bottom: .47em;              
      color: #000;
      text-align: center;
    }

    h4 {
      font-size: 1.15em;                 
      margin-bottom: .74em;              
      color: #000;
    }

    p { font-size: 1.0em; }              

    label {
      font-size: 1.0em;                  
      display: block;
      margin-top: .6em;                
      font-weight: 600;
    }

    /* Base controls (not selects) */
    input[type="file"], input[type="number"] {
      margin-top: 0.26em;
      font-size: 1.0em;
      padding: 0.37em 0.52em;
      width: 100%;
      box-sizing: border-box;
    }

    /* Safari-friendly select sizing */
    select {
      margin-top: 0.26em;
      font-size: 1.0em;
      width: 100%;
      box-sizing: border-box;
      padding-block: 0.4em;   /* top/bottom */
      padding-inline: 0.52em; /* left/right to align with inputs */
    }

    #fileList {
      margin-top: .47em;                 
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.84em;                   
      max-height: 34vh;                  
      overflow-y: auto;
    }

    /* File rows */
    .file-item {
      padding: 0.0em 0.60em;            
      margin-bottom: 0.25em;
      background: #f5f5f5;
      border: 1px solid #e1e1e1;
      border-radius: 3px;
      display: flex;
      align-items: center;
      gap: 7px;
      font-size: 0.97em;
    }
    .file-item.real { cursor: grab; }
    .file-item.drag-over { background: #e6f7ff; border-color: #91d5ff; }

    .file-item > span {
      align-self: center;
      line-height: 1.24;
    }
    .file-item > span:first-child { flex: 1 1 auto; }

    .file-item:not(.real) {
      min-height: 2.1em;
      padding: 0.60em 0.60em;
    }

    .proposed {
      color: #555;
      font-style: italic;
      margin-left: auto;
      flex-shrink: 0;
      align-self: center;
    }

    .controls {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-left: 8.5px;
    }

    .preview-btn {
      -webkit-appearance: none;
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
      gap: 6.3px;
      line-height: 1.05;
      padding: .37em .74em;
      border-radius: 6px;
      border: 1px solid #0d6efd;
      background: #0d6efd;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      user-select: none;
      transform: translateY(-11.5px);
    }
    .preview-btn:active {
      background: #d32f2f;
      border-color: #b71c1c;
    }
    .placeholder-label {
      color: #888;
      font-style: italic;
    }

    .gap-controls { margin-top: 7.3px; }

    input[type="file"] {
      font-size: 1.1em;
      padding: 0.5em 0em;
      height: 2.6em;
      line-height: 1.3;
    }

    button {
      margin-top: 1.68em;
      padding: 0.63em 1.05em;
      font-size: 1.0em;
      background: #005aad;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: green; }

    .preview-btn.is-playing {
      background: #d32f2f !important;
      border-color: #b71c1c !important;
      color: #fff;
      box-shadow: 0 0 0 2px rgba(211,47,47,.15) inset;
    }

    .preview-btn:hover:not(.is-playing) {
      background: #81c784;
      border-color: #388e3c;
    }
    @media (hover: hover) and (pointer: fine) {
      .preview-btn:hover:not(.is-playing) {
        background: #81c784;
        border-color: #388e3c;
      }
    }

    .accordion {
      font-size: 12.1pt !important;
      font-family: "Helvetica" !important;
      background-color: #eee;
      color: #000 !important;
      cursor: pointer !important;
      padding: 7.3px 8.4px !important;
      width: 100% !important;
      text-align: center !important;
      border: .53px solid #000 !important;
      outline: none !important;
      margin-bottom:7.3px;
      margin-top:0px;
    }

    .form-row {
      display: flex;
      gap: 10.5px;
      align-items: flex-end;
      flex-wrap: wrap;
    }
    .form-row > label {
      flex: 1 1 230px;
      margin-top: .84em;
    }
    .form-row > label > select,
    .form-row > label > input[type="number"] {
      width: 100%;
    }

    .active { background-color: #eee; }

    @media (hover: hover) and (pointer: fine) {
      .accordion:hover { background-color: #9f9; }
      .expandall:hover { background-color: #9f9; }
    }
    @media (hover: none), (pointer: coarse) {
      .accordion:hover,
      .expandall:hover {
        background-color: inherit;
      }
    }

    /* Applied status bubble */
    .apply-status {
      margin-left: 8px;
      font-size: 1em;
      color: #2e7d32;          
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 220ms ease, transform 220ms ease;
    }
    .apply-status.show {
      opacity: 1;
      transform: translateY(2px);
    }

    .expandall {
      font-size: 11.55pt !important;
      font-family:"Helvetica" !important;
      width:126px !important;
      height:42px !important;
      padding:7.3px !important;
      border-radius:4.2px !important;
      border:.53px solid #000 !important;
      color:black !important;
      background-color: #eee;
    }

    .tocpanel { 
      padding: 8.4px !important;
      display: none; 
      overflow: hidden !important; 
    }

    .modal_flat_background { 
      background-color: #000; 
      opacity: 0.4; 
    }

    .modal_flat_main { 
      border: 1px solid #333; 
      box-shadow: 0px 0px 15.5px -2px rgba(0,0,0,0.75);
    }

    .modal_flat_main,
    .modal_flat_main input,
    .modal_flat_main button {  
      font-size: 16.8px;
    }

    .modal_flat_main input, 
    .modal_flat_main button {  
      padding: 5.25px;
      box-sizing: border-box; 
    }

    .modal_flat_inner { 
      padding: 31.5px;
      background: #fff; 
      color: #000; 
    }

    .modal_flat_content { 
      font-family:"Helvetica"; 
      margin: 21px 0px;
    }

    .modal_flat_input { 
      margin: 21px 0px;
    }

    .modal_flat_buttons { 
      text-align:center;
      margin-top: 42px;
    }

    .modal_flat_main button { 
      background-color: #ccc; 
      color: #000; 
      padding: 10.5px 21px;
      border: 0px; 
      cursor: pointer; 
      outline: none; 
      width: 105px;
    }

    .modal_flat_cancel {
      margin-left: 5.25px;
    }
    </style>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>

    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-VM0N9HL3MK');
    </script>

  </head>

  <body>
  
    <h1>ABC Transcription Tools&nbsp;-&nbsp;Custom Instrument Builder</h1>

    <button class="accordion" title="Click to expand/collapse this section">Click to show/hide the instructions</button>

    <div class="tocpanel" style="text-align:left;background-color:#f5ffff;">
      <p>This tool is used to create an ABC Transcription Tools custom instrument from a directory of per-note audio sample files.</p>
      <p>The files should be in .wav or .mp3 format.</p>
      <p>1)&nbsp;Click <strong>Select audio sample files in .wav, or .mp3 format</strong> to select your audio sample files.</p>
      <p>The samples must all be in the same directory.</p>
      <p>The output note filename for each audio sample input file is displayed at the right of each item in the list.</p>
      <p>Drag and drop the items in the list into the scale note order you want.</p>
      <p>2)&nbsp;Select the default volume scale and fade time for the instrument.</p>
      <p>3)&nbsp;Choose the starting octave number for the instrument notes.</p>
      <p>4)&nbsp;Choose the starting scale note for the file names.</p>
      <p>5)&nbsp;If your files have filenames that contain note names, check <strong>Try to automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> to align the sample file list with the note names (checked by default).</p>
      <p>6)&nbsp;When automatically sorting by scale order, if there are scale gaps found, select between either synthesizing (pitch shift) the missing note samples in the scale from other available notes or just replacing them with placeholder silent .wav files.</p>
      <p>7)&nbsp;<strong>Optional:</strong> Enable <strong>Trim leading silence</strong> and set a <strong>Silence threshold (dB)</strong> to remove silence at the start of each file. Use the ▶︎ buttons to audition the result. Click <strong>Apply</strong> to apply the threshold.</p>
      <p>8)&nbsp;Click "Export as Custom ABC Transcription Tools Instrument" to export the custom instrument.</p>
      <p>The exported file will be saved to your browser's default <strong>Downloads</strong> directory.</p>
      <p style="text-align: center;"><a href="https://michaeleskin.com/abctools/userguide.html#creating_custom_midi_instruments" target="_blank">Click here for the ABC Transcription Tools User Guide section on Custom Instruments</a></p>
    </div>

    <label>Select audio sample files in .wav or .mp3 format:
      <input type="file" id="fileInput" accept=".wav,.mp3" multiple>
    </label>

    <div class="form-row">
      <label>Default instrument volume scale:
        <input type="number" id="volumeScale" step="0.1" min="0" value="1.0" inputmode="decimal">
      </label>

      <label>Default instrument release fade time (ms):
        <input type="number" id="fadeTime" step="5" min="0" value="100" inputmode="numeric">
      </label>
    </div>

    <div class="form-row">
      <label>Starting Octave Number:
        <select id="startNumber">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="9">9</option>
        </select>
      </label>

      <label>Starting Scale Note:
        <select id="startNote">
          <option value="0">C</option>
          <option value="1">Db</option>
          <option value="2">D</option>
          <option value="3">Eb</option>
          <option value="4">E</option>
          <option value="5">F</option>
          <option value="6">Gb</option>
          <option value="7">G</option>
          <option value="8">Ab</option>
          <option value="9">A</option>
          <option value="10">Bb</option>
          <option value="11">B</option>
        </select>
      </label>
    </div>

    <!-- Trimming UI -->
    <div class="form-row">
      <label style="flex:0 0 auto;">
        <input type="checkbox" id="trimSilence">
        Trim leading silence
      </label>
    </div>

    <div id="thresholdControls" style="display:none; margin-top:6px;">
      <label title="Samples below this absolute dB are considered silence. Typical: -40 dB"
             style="display:flex;align-items:center;gap:6px;">
        <span>Silence threshold (dB):</span>
        <input type="number" id="silenceDb" step="1" max="0" min="-120" value="-40" inputmode="numeric" style="flex:0 0 80px;">
        <button type="button" id="applyThresholdBtn" style="margin:0;margin-left:4px;padding:0.3em 0.7em;font-size:0.9em;transform: translateY(2px);">Apply</button>
        <span id="applyStatus" class="apply-status" role="status" aria-live="polite" aria-atomic="true"></span>
      </label>
    </div>    

    <label>
      <input type="checkbox" id="autoSort" checked>
      Try to automatically sort files by scale order (C, Db, D, Eb, E, ...)
    </label>

    <div id="gapOptions" class="gap-controls">
      Missing Note Handling:
      <select id="gapMode">
        <option value="synth">Synthesize (pitch-shift) missing notes</option>
        <option value="silent">Fill gaps with silent WAVs</option>
      </select>
    </div>

    <p id="dragMessage" style="margin-bottom:8px;display:none;"><strong>Drag the notes into the note scale order you want:</strong></p>

    <div id="fileList"></div>

    <div style="text-align: center;">
      <button id="exportZip">Click to Export as a Custom ABC Transcription Tools Instrument</button>
    </div>

    <script>
      function DoStartup() {
        const notes = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        let files = [];
        let originalFiles = [];

        const fileInput = document.getElementById('fileInput');
        const startNumber = document.getElementById('startNumber');
        const startNote = document.getElementById('startNote');
        const fileList = document.getElementById('fileList');
        const exportZipBtn = document.getElementById('exportZip');
        const autoSortCheckbox = document.getElementById('autoSort');
        const gapOptions = document.getElementById('gapOptions');
        const gapMode = document.getElementById('gapMode');
        const dragMessage = document.getElementById('dragMessage');

        const volumeScaleInput = document.getElementById('volumeScale');
        const fadeTimeInput = document.getElementById('fadeTime');

        const trimSilenceCheckbox = document.getElementById('trimSilence');
        const silenceDbInput = document.getElementById('silenceDb');
        const thresholdControls = document.getElementById('thresholdControls');
        const applyThresholdBtn = document.getElementById('applyThresholdBtn');

        var gFileSaveName = "custom_instrument.zip";

        /* --- Preview playback state --- */
        let gAudio = new Audio();
        let gAudioUrl = null;
        let gCurrentBtn = null;
        let gPlaybackId = 0;

        function markPlaying(btn, on) {
          if (!btn) return;
          btn.classList.toggle('is-playing', !!on);
          btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        }
        function stopCurrentPreview() {
          try { gAudio.pause(); } catch {}
          gAudio.removeAttribute('src');
          gAudio.load();
          if (gAudioUrl) { URL.revokeObjectURL(gAudioUrl); gAudioUrl = null; }
          if (gCurrentBtn) { markPlaying(gCurrentBtn, false); gCurrentBtn = null; }
        }
        async function previewFile(file, btn) {
          try {
            if (gCurrentBtn === btn && !gAudio.paused && !gAudio.ended) { stopCurrentPreview(); return; }
            stopCurrentPreview();
            const blob = await fileToProcessedBlob(file);
            const myId = ++gPlaybackId;
            gAudioUrl = URL.createObjectURL(blob);
            gAudio.src = gAudioUrl;
            gAudio.load();
            gCurrentBtn = btn;
            markPlaying(btn, true);
            gAudio.onended = () => {
              if (myId !== gPlaybackId) return;
              if (gAudioUrl) { URL.revokeObjectURL(gAudioUrl); gAudioUrl = null; }
              markPlaying(btn, false);
              if (gCurrentBtn === btn) gCurrentBtn = null;
            };
            gAudio.onerror = () => { if (myId !== gPlaybackId) return; stopCurrentPreview(); };
            const p = gAudio.play();
            if (p && typeof p.catch === 'function') p.catch(() => {});
          } catch (e) { console.error(e); stopCurrentPreview(); }
        }

        // ===== Hashed filename detection =====
        let gHasHashedNames = false;
        function stripExtension(name) { const i = name.lastIndexOf('.'); return i >= 0 ? name.slice(0, i) : name; }
        const HASHLIKE_RE = /(?:^|[_\-])([0-9a-fA-F]{16,})(?:$|\b)/;
        function hasHashedFilenames(list){ return list.some(f=>HASHLIKE_RE.test(stripExtension(f.name))); }
        function applyHashedModeUIState(){ autoSortCheckbox.checked=false; gapOptions.style.display='none'; dragMessage.style.display='block'; }
        function clearHashedModeUIState(){ gapOptions.style.display=autoSortCheckbox.checked?'block':'none'; dragMessage.style.display=autoSortCheckbox.checked?'none':'block'; }

        // ===== Pitch parsing =====
        const sharpToFlat = {"C#":"Db","D#":"Eb","F#":"Gb","G#":"Ab","A#":"Bb","Cs":"Db","Ds":"Eb","Fs":"Gb","Gs":"Ab","As":"Bb","CS":"Db","DS":"Eb","FS":"Gb","GS":"Ab","AS":"Bb"};
        const noteOrder = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
        const noteRegex = /([A-G][#bsS]?)(\d+)/i;
        function parsePitchFromName(name){
          const m = name.match(noteRegex); if(!m) return null;
          let note = m[1]; const octave = parseInt(m[2],10);
          note = note.charAt(0).toUpperCase()+(note.slice(1)||""); note = sharpToFlat[note] || note;
          const idx = noteOrder.indexOf(note); if (idx<0 || isNaN(octave)) return null;
          return { noteIdx: idx, octave, pitchIndex: octave*12+idx };
        }

        function detectAndApplyLowestPitch() {
          let minPI = Infinity, minNoteIdx=0, minOct=0;
          for (const f of files){ const p=parsePitchFromName(f.name); if(p && p.pitchIndex<minPI){minPI=p.pitchIndex;minNoteIdx=p.noteIdx;minOct=p.octave;} }
          if (minPI!==Infinity){ startNote.value=String(minNoteIdx); startNumber.value=String(Math.max(0,Math.min(9,minOct))); }
        }

        function sortFilesIfNeeded(){
          if (autoSortCheckbox.checked){
            files.sort((a,b)=>{
              const A=a.name.match(noteRegex), B=b.name.match(noteRegex);
              if (A && B){
                let nA=A[1].charAt(0).toUpperCase()+(A[1].slice(1)||"");
                let nB=B[1].charAt(0).toUpperCase()+(B[1].slice(1)||"");
                nA=sharpToFlat[nA]||nA; nB=sharpToFlat[nB]||nB;
                const oA=parseInt(A[2],10), oB=parseInt(B[2],10);
                if (oA!==oB) return oA-oB; return noteOrder.indexOf(nA)-noteOrder.indexOf(nB);
              }
              if (A) return -1; if (B) return 1; return 0;
            });
          } else { files=[...originalFiles]; }
        }

        function getProposedNameForIndex(i, extIfNotTrim){
          const start=parseInt(startNumber.value,10);
          const offset=parseInt(startNote.value,10);
          const noteIndex=(i+offset)%12;
          const octave=start+Math.floor((i+offset)/12);
          const useExt=trimSilenceCheckbox.checked ? "wav" : extIfNotTrim;
          return `${notes[noteIndex]}${octave}.${useExt}`;
        }

        function buildContinuousRange(){
          const matched=[], unmatched=[];
          for (const f of files){
            const p=parsePitchFromName(f.name);
            if (p){
              if (p.octave>8){
                DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Note Octave Out-of-Range Detected (Max is 8)</strong><br/><br/>Auto-sort and note range detect will be disabled.</p>', { theme:"modal_flat", top:200 });
                gHasHashedNames=true; applyHashedModeUIState();
                setTimeout(()=>{ files=[...originalFiles]; safeRenderList(); },250);
                return { full:[], unmatched: files.slice() };
              }
              matched.push({ file:f, pitchIndex:p.pitchIndex, ext:f.name.split('.').pop() });
            } else { unmatched.push(f); }
          }
          if (!matched.length) return { full:[], unmatched };
          matched.sort((a,b)=>a.pitchIndex-b.pitchIndex);
          const minPI=matched[0].pitchIndex, maxPI=matched[matched.length-1].pitchIndex;
          const pitchMap=new Map(); for (const m of matched) if(!pitchMap.has(m.pitchIndex)) pitchMap.set(m.pitchIndex,m);
          const full=[]; for (let pi=minPI; pi<=maxPI; pi++){ const m=pitchMap.get(pi)||null; full.push({ file:m?m.file:null, pitchIndex:pi, ext:m?m.ext:"wav" }); }
          return { full, unmatched };
        }

        /* ====== Device-independent decode (single OfflineAudioContext) ====== */
        let gDecodeOffline = null;
        function getDecodeOffline(){
          // Tiny render length; just used to access decodeAudioData without opening audio device
          if (!gDecodeOffline) gDecodeOffline = new OfflineAudioContext(1, 1, 44100);
          return gDecodeOffline;
        }

        const decodeCache = new WeakMap(); // File -> Promise<AudioBuffer>
        async function decodeFileToAudioBuffer(file){
          if (decodeCache.has(file)) return decodeCache.get(file);
          const p = (async ()=>{
            const offline = getDecodeOffline();
            const arr = await file.arrayBuffer();
            // slice() avoids neutering issues on some browsers
            return await offline.decodeAudioData(arr.slice(0));
          })();
          decodeCache.set(file,p);
          return p;
        }

        /* ====== Pitch shift that returns AudioBuffer (no re-decode later) ====== */
        async function pitchShiftBuffer(srcBuf, semitones){
          const rate = Math.pow(2, semitones/12);
          const outLength = Math.max(1, Math.ceil(srcBuf.length / rate));
          const offline = new OfflineAudioContext(srcBuf.numberOfChannels, outLength, srcBuf.sampleRate);
          const src = offline.createBufferSource();
          src.buffer = srcBuf;
          src.playbackRate.value = rate;
          src.connect(offline.destination);
          src.start();
          return await offline.startRendering(); // AudioBuffer
        }

        /* ====== WAV helpers / trimming ====== */
        function generateSilentWav(durationSec=1, sampleRate=44100){
          const numSamples = Math.floor(durationSec*sampleRate);
          const buffer = new ArrayBuffer(44 + numSamples*2);
          const view = new DataView(buffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          ws(0,"RIFF"); view.setUint32(4, 36+numSamples*2, true); ws(8,"WAVE"); ws(12,"fmt ");
          view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,1,true);
          view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
          view.setUint16(32,2,true); view.setUint16(34,16,true); ws(36,"data");
          view.setUint32(40,numSamples*2,true);
          return new Blob([buffer], {type:"audio/wav"});
        }

        function audioBufferToWav(buffer){
          const numChannels=buffer.numberOfChannels, sampleRate=buffer.sampleRate;
          const length=buffer.length*numChannels*2+44;
          const arrayBuffer=new ArrayBuffer(length); const view=new DataView(arrayBuffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          let pos=0; ws(pos,"RIFF"); pos+=4; view.setUint32(pos,length-8,true); pos+=4;
          ws(pos,"WAVE"); pos+=4; ws(pos,"fmt "); pos+=4; view.setUint32(pos,16,true); pos+=4;
          view.setUint16(pos,1,true); pos+=2; view.setUint16(pos,numChannels,true); pos+=2;
          view.setUint32(pos,sampleRate,true); pos+=4; view.setUint32(pos,sampleRate*numChannels*2,true); pos+=4;
          view.setUint16(pos,numChannels*2,true); pos+=2; view.setUint16(pos,16,true); pos+=2;
          ws(pos,"data"); pos+=4; view.setUint32(pos,length-44,true); pos+=4;
          const channels=[]; for(let i=0;i<numChannels;i++) channels.push(buffer.getChannelData(i));
          for(let i=0;i<buffer.length;i++){
            for(let ch=0; ch<numChannels; ch++){
              let s=channels[ch][i]; s=Math.max(-1,Math.min(1,s));
              view.setInt16(pos, s<0 ? s*0x8000 : s*0x7FFF, true); pos+=2;
            }
          }
          return new Blob([arrayBuffer], {type:"audio/wav"});
        }

        function dbToLinear(db){ return Math.pow(10, db/20); }

        function trimLeadingSilenceFromBuffer(buffer, thresholdLinear){
          const numChannels=buffer.numberOfChannels, length=buffer.length, sr=buffer.sampleRate;
          const preRollSamples = Math.round(sr*0.003);
          const windowSize = Math.max(32, Math.round(sr*0.001));
          let startIndex=0, found=false;
          for (let i=0; i<length; i+=windowSize){
            let maxAbs=0;
            for(let ch=0; ch<numChannels; ch++){
              const data=buffer.getChannelData(ch);
              const end=Math.min(i+windowSize,length);
              for(let s=i; s<end; s++){ const v=Math.abs(data[s]); if(v>maxAbs) maxAbs=v; }
              if (maxAbs>=thresholdLinear) break;
            }
            if (maxAbs>=thresholdLinear){ startIndex=Math.max(0, i-preRollSamples); found=true; break; }
          }
          if (!found){
            const tiny=Math.min(length, Math.round(sr*0.01));
            startIndex=Math.max(0, length-tiny);
          }
          const newLength=Math.max(1, length-startIndex);
          const out=new AudioBuffer({length:newLength, numberOfChannels:numChannels, sampleRate:sr});
          for(let ch=0; ch<numChannels; ch++){
            const src=buffer.getChannelData(ch).subarray(startIndex, startIndex+newLength);
            out.copyToChannel(src, ch, 0);
          }
          return out;
        }

        // Return a Blob to write into ZIP, trimming if needed
        async function bufferToFinalBlob(buffer){
          if (trimSilenceCheckbox.checked){
            const thr = dbToLinear(Number(silenceDbInput.value));
            const trimmed = trimLeadingSilenceFromBuffer(buffer, thr);
            return audioBufferToWav(trimmed);
          }
          return audioBufferToWav(buffer);
        }

        // If not trimming, return the original file (mp3/wav). If trimming, decode->trim->WAV.
        async function fileToProcessedBlob(file){
          if (!trimSilenceCheckbox.checked) return file;
          const buf = await decodeFileToAudioBuffer(file);
          return bufferToFinalBlob(buf);
        }

        // ---------- RENDER LIST ----------

        function safeRenderList(){
          if (gAudio && !gAudio.paused && !gAudio.ended) return; // don't rerender during preview playback
          renderList();
        }

        function renderList(){
          fileList.innerHTML='';
          if (!autoSortCheckbox.checked){
            files.forEach((file,i)=>{
              const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=i;
              const ext=file.name.split('.').pop(); const proposedName=getProposedNameForIndex(i,ext);
              const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposedName}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item); fileList.appendChild(item);
            });
            return;
          }

          const { full, unmatched } = buildContinuousRange();
          if (!full.length){
            files.forEach((file,i)=>{
              const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=i;
              const ext=file.name.split('.').pop(); const proposedName=getProposedNameForIndex(i,ext);
              const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposedName}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item); fileList.appendChild(item);
            });
            return;
          }

          full.forEach((slot,idx)=>{
            const item=document.createElement('div');
            if (slot.file){
              item.className='file-item real'; item.draggable=true; item.dataset.fileName=slot.file.name;
              const originalIndex=files.findIndex(f=>f===slot.file); if (originalIndex>=0) item.dataset.index=String(originalIndex);
              const nameSpan=document.createElement('span'); nameSpan.textContent=slot.file.name;
              const proposed=getProposedNameForIndex(idx,slot.ext);
              const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposed}`;
              const ctrl=document.createElement('div'); ctrl.className='controls';
              const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>previewFile(slot.file,e.currentTarget));
              ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
              addDragHandlers(item);
            } else {
              item.className='file-item';
              const proposed=getProposedNameForIndex(idx,"wav");
              const modeLabel=(gapMode.value==='synth')?' (placeholder: synth)':' (placeholder: silent)';
              item.innerHTML=`<span class="placeholder-label">(placeholder)</span><span class="proposed">→ ${proposed}${modeLabel}</span><div class="controls"></div>`;
            }
            fileList.appendChild(item);
          });

          unmatched.forEach((file,i)=>{
            const idx=full.length+i;
            const item=document.createElement('div'); item.className='file-item real'; item.draggable=true; item.dataset.index=files.findIndex(f=>f===file);
            const ext=file.name.split('.').pop(); const proposed=getProposedNameForIndex(idx,ext);
            const nameSpan=document.createElement('span'); nameSpan.textContent=file.name;
            const proposedSpan=document.createElement('span'); proposedSpan.className='proposed'; proposedSpan.textContent=`→ ${proposed}`;
            const ctrl=document.createElement('div'); ctrl.className='controls';
            const btn=document.createElement('button'); btn.className='preview-btn'; btn.type='button'; btn.textContent='▶︎';
            btn.addEventListener('click',(e)=>previewFile(file,e.currentTarget));
            ctrl.appendChild(btn); item.appendChild(nameSpan); item.appendChild(proposedSpan); item.appendChild(ctrl);
            addDragHandlers(item); fileList.appendChild(item);
          });
        }

        function addDragHandlers(el){
          el.addEventListener('dragstart',(e)=>{
            if (!el.classList.contains('real')){ e.preventDefault(); return; }
            e.dataTransfer.setData('text/plain', el.dataset.index);
            el.classList.add('dragging');
          });
          el.addEventListener('dragend',()=>{
            el.classList.remove('dragging');
            const newOrder = Array.from(fileList.children)
              .filter(c=>c.dataset.index!==undefined && c.dataset.index!==null)
              .map(c=>files[Number(c.dataset.index)]);
            if (newOrder.length) files=newOrder;
            safeRenderList();
          });
          el.addEventListener('dragover',(e)=>{
            if (!document.querySelector('.dragging')) return;
            e.preventDefault();
            const dragging=document.querySelector('.dragging');
            const rect=el.getBoundingClientRect();
            const offset=e.clientY-rect.top;
            const parent=el.parentNode;
            if (offset > rect.height/2) parent.insertBefore(dragging, el.nextSibling);
            else parent.insertBefore(dragging, el);
          });
        }

        fileList.addEventListener('dragover',(e)=>{
          const scrollZone=40, scrollSpeed=4;
          const rect=fileList.getBoundingClientRect();
          if (e.clientY<rect.top+scrollZone) fileList.scrollTop-=scrollSpeed;
          else if (e.clientY>rect.bottom-scrollZone) fileList.scrollTop+=scrollSpeed;
        });

        // ===================== Export (ZIP) =====================

        exportZipBtn.addEventListener('click', async ()=>{
          async function saveZipFile(fname){
            if (!files.length){
              DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme:"modal_flat", top:200 });
              return;
            }

            const zip=new JSZip();

            // Meta
            let volumeScale=parseFloat(volumeScaleInput.value);
            let fadeTimeMs=parseInt(fadeTimeInput.value,10);
            if (isNaN(volumeScale)) volumeScale=1.0;
            if (isNaN(fadeTimeMs)) fadeTimeMs=100;
            if (volumeScale<0) volumeScale=0;
            if (fadeTimeMs<0) fadeTimeMs=0;
            const meta={ volumeScale, fadeTimeMs, trimLeadingSilence: !!trimSilenceCheckbox.checked, silenceThresholdDb: Number(silenceDbInput.value) };
            zip.file("abctools.json", JSON.stringify(meta,null,2));

            if (!autoSortCheckbox.checked){
              // Export current order (no synth)
              const reordered = Array.from(fileList.children).filter(el=>el.classList.contains('real')).map(el=>files[Number(el.dataset.index)]);
              for (let i=0;i<reordered.length;i++){
                const file=reordered[i];
                const ext=file.name.split('.').pop();
                const newName=getProposedNameForIndex(i, ext);
                const outBlob=await fileToProcessedBlob(file);
                zip.file(newName, outBlob);
              }

            } else {
              const { full, unmatched } = buildContinuousRange();

              if (!full.length){
                for (let i=0;i<files.length;i++){
                  const file=files[i];
                  const ext=file.name.split('.').pop();
                  const newName=getProposedNameForIndex(i, ext);
                  const outBlob=await fileToProcessedBlob(file);
                  zip.file(newName, outBlob);
                }
              } else {
                const haveAtIndex = new Map(); // idx -> file
                full.forEach((slot,i)=>{ if (slot.file) haveAtIndex.set(i, slot.file); });

                // Pre-decode all available sources into buffers (via OfflineAudioContext only)
                const decodedAtIndex = new Map();
                await Promise.all(Array.from(haveAtIndex.entries()).map(async ([i, file])=>{
                  try { decodedAtIndex.set(i, await decodeFileToAudioBuffer(file)); }
                  catch(e){ console.warn("Decode failed:", file.name, e); }
                }));

                function findSourceIndex(targetIdx){
                  for (let d=1; d<full.length; d++){
                    const lower=targetIdx-d, higher=targetIdx+d;
                    if (lower>=0 && decodedAtIndex.has(lower)) return lower;
                    if (higher<full.length && decodedAtIndex.has(higher)) return higher;
                  }
                  return -1;
                }

                for (let i=0;i<full.length;i++){
                  const slot=full[i];

                  if (slot.file){
                    const ext=slot.ext;
                    const proposed=getProposedNameForIndex(i, ext);
                    const outBlob=await fileToProcessedBlob(slot.file);
                    zip.file(proposed, outBlob);
                  } else {
                    const proposed=getProposedNameForIndex(i, "wav");
                    if (gapMode.value==='silent'){
                      zip.file(proposed, generateSilentWav(1));
                    } else {
                      const srcIdx = findSourceIndex(i);
                      if (srcIdx>=0){
                        try{
                          const srcBuf = decodedAtIndex.get(srcIdx);
                          const semitones = i - srcIdx;
                          const shiftedBuf = await pitchShiftBuffer(srcBuf, semitones);
                          const outBlob = await bufferToFinalBlob(shiftedBuf);
                          zip.file(proposed, outBlob);
                        } catch(e){
                          console.warn("Synthesis failed at index", i, e);
                          zip.file(proposed, generateSilentWav(1));
                        }
                      } else {
                        zip.file(proposed, generateSilentWav(1));
                      }
                    }
                  }
                }

                // Append unmatched extras
                if (unmatched.length){
                  const startIdx=full.length;
                  for (let j=0;j<unmatched.length;j++){
                    const file=unmatched[j];
                    const ext=file.name.split('.').pop();
                    const proposed=getProposedNameForIndex(startIdx+j, ext);
                    const outBlob=await fileToProcessedBlob(file);
                    zip.file(proposed, outBlob);
                  }
                }
              }
            }

            const blob=await zip.generateAsync({type:"blob"});
            const a=document.createElement('a');
            a.href=URL.createObjectURL(blob);
            a.download=fname;
            a.click();
            setTimeout(()=>{ window.URL.revokeObjectURL(a.href); }, 1000);
          };

          if (fileList.children.length==0){
            DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme:"modal_flat", top:200 });
            return;
          }

          var thePrompt="Please enter a filename for your custom instrument file:";
          DayPilot.Modal.prompt(thePrompt, gFileSaveName, { theme:"modal_flat", top:200, autoFocus:true })
          .then(function(args){
            var fname=args.result;
            if (fname==null) return;
            if (fname.length==0) return;
            if (!fname.endsWith(".zip")){
              fname=fname.replace(/\..+$/,''); fname=fname+".zip";
            }
            gFileSaveName=fname;
            sortFilesIfNeeded();
            saveZipFile(fname);
          });

        });

        // ===== UI wiring =====

        fileInput.addEventListener('change',(e)=>{
          originalFiles=Array.from(e.target.files);
          files=[...originalFiles];

          gHasHashedNames=hasHashedFilenames(files);
          if (gHasHashedNames){
            applyHashedModeUIState();
            DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.<br/><br/>Auto-sort and note range detect if enabled may abort if there are not real note names with octave numbers in the filenames.</p>', { theme:"modal_flat", top:200 });
          } else { clearHashedModeUIState(); }

          sortFilesIfNeeded();
          if (autoSortCheckbox.checked && !gHasHashedNames) detectAndApplyLowestPitch();
          safeRenderList();
        });

        startNumber.addEventListener('change', safeRenderList);
        startNote.addEventListener('change', safeRenderList);

        autoSortCheckbox.addEventListener('change', ()=>{
          gapOptions.style.display=autoSortCheckbox.checked?'block':'none';
          dragMessage.style.display=autoSortCheckbox.checked?'none':'block';
          sortFilesIfNeeded();
          if (autoSortCheckbox.checked) detectAndApplyLowestPitch();
          safeRenderList();
        });

        gapMode.addEventListener('change', safeRenderList);

        // start with trim off and controls hidden
        trimSilenceCheckbox.checked=false;
        thresholdControls.style.display='none';

        trimSilenceCheckbox.addEventListener('change', ()=>{
          thresholdControls.style.display = trimSilenceCheckbox.checked ? 'block' : 'none';
          safeRenderList();
        });

        applyThresholdBtn.addEventListener('click', () => {

          // Re-render with the new threshold value (guarded by safeRenderList)
          safeRenderList();

          // Visual feedback
          const status = document.getElementById('applyStatus');
          status.textContent = 'Applied';
          status.classList.add('show');

          // Briefly disable to prevent double-click spam
          applyThresholdBtn.disabled = true;
          setTimeout(() => {
            status.classList.remove('show');
            applyThresholdBtn.disabled = false;
          }, 1200);
        });

        // If the user changes the number again, hide the old "Applied" hint
        silenceDbInput.addEventListener('input', () => {
          const status = document.getElementById('applyStatus');
          status.classList.remove('show');
        });

        // Accordion
        var acc=document.getElementsByClassName("accordion");
        for (var i=0;i<acc.length;i++){
          acc[i].addEventListener("click", function(){
            this.classList.toggle("active");
            var panel=this.nextElementSibling;
            if (panel.style.display==="block") panel.style.display="none";
            else panel.style.display="block";
          });
        }
      }

      function WaitForReady(fn){
        if (document.readyState!=='loading'){ fn(); return; }
        document.addEventListener('DOMContentLoaded', fn);
      }

      WaitForReady(DoStartup);

    </script>

  </body>

</html>
