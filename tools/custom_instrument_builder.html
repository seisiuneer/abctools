<!DOCTYPE html>
<html lang="en">

  <head>

  <meta charset="UTF-8">
  <title>ABC Transcription Tools - Custom Instrument Builder</title>
  <meta property="og:type" content="website" />
  <meta property="og:title" content="ABC Transcription Tools - Custom Instrument Builder" />
  <meta property="og:description" content="Utility for creating custom instruments for the ABC Transcription Tools." />
  <meta property="og:url" content="https://michaeleskin.com/tools/custom_instrument_builder.html" />
  <meta property="og:site_name" content="ABC Transcription Tools - Custom Instrument Builder" />
  <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
  <meta name="viewport" content="width=860">
  <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">

  <script type="text/javascript" src="jszip-min.js?v=20"></script>
  <script type="text/javascript" src="filesaver-min.js?v=20"></script>
  <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=20"></script>
  
  <style>
    body {
      background: #fafafa;
      color: #222;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 12.5px auto;               
      padding: 0 19px;                   
      line-height: 1.47;
      padding-bottom: 60px;                 
    }

    h1 {
      margin-top: 14.5px;                
      font-size: 1.73em;                 
      margin-bottom: .47em;              
      color: #000;
      text-align: center;
    }

    h2 {
      font-size: 1.5em;
      margin-top: .3em;
      margin-bottom: .47em;
      color: #000;
      text-align: center;
    }

    h4 {
      font-size: 1.15em;                 
      margin-top: .75em;
      margin-bottom: .47em;
      color: #000;
      text-align: center;
    }

    p { font-size: 1.0em; }              

    label {
      font-size: 1.0em;                  
      display: block;
      margin-top: .6em;                
      font-weight: 600;
    }

    input[type="file"], input[type="number"] {
      margin-top: 0.26em;
      font-size: 1.0em;
      padding: 0.37em 0.52em;
      width: 100%;
      box-sizing: border-box;
    }

    input[type="file"] {
      font-size: 1em;
      padding: 0.3em 0;
      height: 2.2em;
      line-height: 1.2;
      border-radius: 4px;
      box-sizing: border-box;
    }

    input[type="file"]::file-selector-button {
      -webkit-appearance: none;
      appearance: none;
      margin-right: 0.5em;
      padding: 0.3em 0.8em;
      border-radius: 5px;
      border: 1px solid #005aad;
      background: #005aad;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      cursor: pointer;
      line-height: 1.2;
    }

    input[type="file"]::file-selector-button:hover { background: #0a6bd1; border-color: #0a6bd1; }
    input[type="file"]::file-selector-button:active { background: #0a5db6; border-color: #0a5db6; }
    input[type="file"]::file-selector-button:focus,
    input[type="file"]:focus-visible::file-selector-button { outline: none; box-shadow: 0 0 0 2px rgba(0,90,173,0.25); }

    input[type="file"]::-webkit-file-upload-button {
      -webkit-appearance: none;
      margin-right: 0.5em;
      padding: 0.3em 0.8em;
      border-radius: 5px;
      border: 1px solid #005aad;
      background: #005aad;
      color: #fff;
      font-weight: 600;
      font-size: 0.95em;
      cursor: pointer;
      line-height: 1.2;
    }
    input[type="file"]::-webkit-file-upload-button:hover { background: #0a6bd1; border-color: #0a6bd1; }
    input[type="file"]::-webkit-file-upload-button:active { background: #0a5db6; border-color: #0a5db6; }
    input[type="file"]:focus-visible::-webkit-file-upload-button { outline: none; box-shadow: 0 0 0 2px rgba(0,90,173,0.25); }

    select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      margin-top: 0.26em;
      font-size: 1.0em;
      width: 100%;
      box-sizing: border-box;
      padding-block: 0.4em;
      padding-inline: 0.52em;
      color: #222;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    select:focus {
      border-color: #005aad;
      box-shadow: 0 0 0 2px rgba(0,90,173,0.25);
      outline: none;
    }

    #fileList {
      margin-top: .47em;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 0.84em;
      max-height: 32vh;
      overflow-y: auto;
    }

    .file-item {
      padding: 0.1em 0.9em;
      margin-bottom: 0.3em;
      background: #f5f5f5;
      border: 1px solid #e1e1e1;
      border-radius: 3px;
      display: flex;
      align-items: center;
      gap: 7px;
      font-size: 0.97em;
    }

    .file-item.real { cursor: grab; }
    .file-item.drag-over { background: #e6f7ff; border-color: #91d5ff; }

    .file-item > span { align-self: center; line-height: 1.24; }
    .file-item > span:first-child { flex: 1 1 auto; }

    .file-item:not(.real) { min-height: 1.6em; padding: 0.1em 0.9em; }

    .proposed { color: #555; font-style: italic; margin-left: auto; flex-shrink: 0; align-self: center; }

    .controls { display: flex; align-items: center; justify-content: flex-end; margin-left: 8.5px; }

    .preview-btn {
      -webkit-appearance: none;
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
      gap: 6.3px;
      line-height: 1.05;
      padding: .37em .74em;
      border-radius: 6px;
      border: 1px solid #0d6efd;
      background: #0d6efd;
      color: #fff;
      cursor: pointer;
      font-weight: 700;
      user-select: none;
      transform: translateY(-11.5px);
    }
    .preview-btn:active { background: #d32f2f; border-color: #b71c1c; }
    .placeholder-label { color: #888; font-style: italic; }

    .gap-controls { margin-top: 14px; }

    input[type="file"] { font-size: 1.1em; padding: 0.5em 0em; height: 2.6em; line-height: 1.3; }

    button {
      margin-top: 1.68em;
      padding: 0.63em 1.05em;
      font-size: 1.0em;
      background: #005aad;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: green; }

    .preview-btn.is-playing {
      background: #d32f2f !important;
      border-color: #b71c1c !important;
      color: #fff;
      box-shadow: 0 0 0 2px rgba(211,47,47,.15) inset;
    }
    .preview-btn:hover:not(.is-playing) { background: #81c784; border-color: #388e3c; }

    #fileList.drag-disabled { user-select: none; }
    #fileList.drag-disabled .file-item.real { cursor: default; opacity: 0.9; }

    .accordion {
      font-size: 12.1pt !important;
      font-family: "Helvetica" !important;
      background-color: #eee;
      color: #000 !important;
      cursor: pointer !important;
      padding: 7.3px 8.4px !important;
      width: 100% !important;
      text-align: center !important;
      border: .53px solid #000 !important;
      outline: none !important;
      margin-bottom: 7.3px;
      margin-top: 0px;
    }
    .accordion:hover { background: #88FF88; }

    .form-row { display: flex; gap: 10.5px; align-items: flex-end; flex-wrap: wrap; }
    .form-row > label { flex: 1 1 230px; margin-top: .7em; }
    .form-row > label > select, .form-row > label > input[type="number"] { width: 100%; }

    .active { background-color: #eee; }

    .apply-status { margin-left: 8px; font-size: 1em; color: #2e7d32; opacity: 0; transform: translateY(2px); transition: opacity 220ms ease, transform 220ms ease; }
    .apply-status.show { opacity: 1; transform: translateY(2px); }

    .expandall {
      font-size: 11.55pt !important; font-family:"Helvetica" !important; width:126px !important; height:42px !important;
      padding:7.3px !important; border-radius:4.2px !important; border:.53px solid #000 !important; color:black !important; background-color: #eee;
    }

    .modal_flat_background { background-color: #000; opacity: 0.4; }
    .modal_flat_main { border: 1px solid #333; box-shadow: 0px 0px 15.5px -2px rgba(0, 0, 0, 0.75); }
    .modal_flat_main, .modal_flat_main input, .modal_flat_main button { font-size: 16.8px; }
    .modal_flat_main input, .modal_flat_main button { padding: 5.25px; box-sizing: border-box; }
    .modal_flat_inner { padding: 20px; background: #fff; color: #000; }
    .modal_flat_content { font-family: "Helvetica"; margin: 21px 0px; }
    .modal_flat_input { margin: 21px 0px; }
    .modal_flat_buttons { text-align: center; margin-top: 20px; margin-bottom: 20px; }
    .modal_flat_main button { background-color: #ccc; color: #000; padding: 10.5px 21px; border: 0px; cursor: pointer; outline: none; width: 105px; }

    .modal_flat_cancel { margin-left: 5.25px; }

    .instr-modal { text-align: left; background-color: #f5ffff; max-height: 70vh; overflow: auto; padding: 12px; border: 1px solid #e1e1e1; border-radius: 4px; }
    .instr-modal p { margin: 0 0 12px 0; }

    .range-controls {
      display: none;
      margin-top: 7.3px;
      padding: 8px;
      padding-top:0px;
      background: #f8f8ff;
      border: 1px solid #e1e1f0;
      border-radius: 4px;
    }
    .range-controls .row {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    .range-controls label { margin-top: 0.2em; }

    .action-row { display: flex; justify-content: center; gap: 10px; }

    #exportZip { margin-left:9px; margin-top:12px; }
    #importZipBtn { background-color: #471268; border-color: #471268; margin-right:9px; margin-top:12px; }
    #importZipBtn:hover { background-color: green; border-color: green; }

    .touch-reorder{
      display:flex;
      gap:8px;
      justify-content:center;
      margin-top:6px;
    }

    .file-item.selected{ outline:2px solid #91d5ff; background:#e6f7ff; }
    .file-item.temp-suppressed {
      background: #fff7e6;
      border-color: #ffd591;
    }
    .file-item .temp-badge {
      margin-left: 6px;
      padding: 1px 6px;
      border-radius: 10px;
      font-size: 0.8em;
      background: #faad14;
      color: #000;
      font-weight: 700;
    }

    /* Add just below your existing .temp-badge / .temp-suppressed styles */
    .temp-meta {
      margin-left: 6px;
      padding: 1px 6px;
      border-radius: 10px;
      font-size: 0.83em;
      background: #fff1b8;              /* soft amber */
      color: #5b4a00;                   /* readable on amber */
      border: 1px solid #ffe58f;
      font-weight: 600;
      white-space: nowrap;
      max-width: 360px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Updated to include new Delete button */
    #moveUpBtn, #moveDownBtn, #insertAfterBtn, #deleteBtn {
      background-color: #008a53;  
      border-color: #008a53;
    }

    #moveUpBtn:hover, #moveDownBtn:hover, #insertAfterBtn:hover, #deleteBtn:hover{
      background-color: #008a53 !important;
      border-color: #008a53 !important;
    }

    #moveUpBtn, #moveDownBtn, #insertAfterBtn{
      margin-right:8px;
    }

    #touchReorderControls button:disabled {
      opacity: 0.5;
      cursor: default;
    }

  </style>
    
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>

  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VM0N9HL3MK');
  </script>

  </head>

  <body>
  
    <h1>ABC Transcription Tools&nbsp;-&nbsp;Custom Instrument Builder</h1>

    <button id="instructionsBtn" class="accordion" title="Show Instructions">Show Instructions</button>

    <label>Import audio sample files in .wav or .mp3 format:
      <input type="file" id="fileInput" accept=".wav,.mp3" multiple>
      <label for="disableMidiDetect" style="display:flex; align-items:center; gap:6px; margin:0; white-space:nowrap;margin-top:10px !important;">
        <input type="checkbox" id="disableMidiDetect">
        Disable .sf2-style MIDI-number pitch name detection
      </label>
    </label>

    <div class="form-row">
      <label>Default instrument volume scale:
        <input type="number" id="volumeScale" step="0.1" min="0" value="1.0" inputmode="decimal">
      </label>

      <label>Default instrument release fade time (ms):
        <input type="number" id="fadeTime" step="5" min="0" value="100" inputmode="numeric">
      </label>
    </div>

    <div class="form-row">
      <label>Starting scale note:
        <select id="startNote">
          <option value="0">C</option>
          <option value="1">Db</option>
          <option value="2">D</option>
          <option value="3">Eb</option>
          <option value="4">E</option>
          <option value="5">F</option>
          <option value="6">Gb</option>
          <option value="7">G</option>
          <option value="8">Ab</option>
          <option value="9">A</option>
          <option value="10">Bb</option>
          <option value="11">B</option>
        </select>
      </label>
      <label>Starting octave number:
        <select id="startNumber">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
        </select>
      </label>
    </div>

    <!-- force mono WAV export -->
    <div class="form-row">
      <label style="flex:0 0 auto;">
        <input type="checkbox" id="forceMonoWav">
        Encode all exported files as mono .wav
      </label>
    </div>

    <!-- Trimming UI -->
    <div class="form-row">
      <label style="flex:0 0 auto;">
        <input type="checkbox" id="trimSilence">
        Trim leading silence
      </label>
    </div>

    <div id="thresholdControls" style="display:none; margin-top:6px;">
      <label title="Samples below this absolute dB are considered silence. Typical: -40 dB" style="display:flex;align-items:center;gap:6px;">
        <span>Silence threshold (dB):</span>
        <input type="number" id="silenceDb" step="0.5" max="0" min="-120" value="-40" inputmode="numeric" style="flex:0 0 90px;">
        <button type="button" id="applyThresholdBtn" style="margin:0;margin-left:4px;padding:0.3em 0.7em;font-size:0.9em;transform: translateY(2px);">Apply</button>
        <span id="applyStatus" class="apply-status" role="status" aria-live="polite" aria-atomic="true"></span>
      </label>
    </div>

    <div class="form-row">
      <label>
        <input type="checkbox" id="autoSort" checked>
        Automatically sort files by scale order (C, Db, D, Eb, E, ...)
      </label>
    </div>

    <!-- Range Expander toggle (available only when Auto Sort is on) -->
    <div class="form-row" id="rangeExpanderRow">
      <label>
        <input type="checkbox" id="rangeExpander">
        Range Expander (set lowest and highest desired notes and octaves)
      </label>
    </div>

    <!-- Range Expander controls -->
    <div id="rangeControls" class="range-controls">
      <div class="row">
        <label style="flex:1 1 220px;">Lowest desired note:
          <select id="lowNote">
            <option value="0">C</option>
            <option value="1">Db</option>
            <option value="2">D</option>
            <option value="3">Eb</option>
            <option value="4">E</option>
            <option value="5">F</option>
            <option value="6">Gb</option>
            <option value="7">G</option>
            <option value="8">Ab</option>
            <option value="9">A</option>
            <option value="10">Bb</option>
            <option value="11">B</option>
          </select>
        </label>
        <label style="flex:1 1 220px;">Lowest desired octave:
          <select id="lowOct">
            <option>0</option><option>1</option><option>2</option><option>3</option>
            <option>4</option><option>5</option><option>6</option><option>7</option>
            <option>8</option>
          </select>
        </label>
      </div>
      <div class="row">
        <label style="flex:1 1 220px;">Highest desired note:
          <select id="highNote">
            <option value="0">C</option>
            <option value="1">Db</option>
            <option value="2">D</option>
            <option value="3">Eb</option>
            <option value="4">E</option>
            <option value="5">F</option>
            <option value="6">Gb</option>
            <option value="7">G</option>
            <option value="8">Ab</option>
            <option value="9">A</option>
            <option value="10">Bb</option>
            <option value="11">B</option>
          </select>
        </label>
        <label style="flex:1 1 220px;">Highest desired octave:
          <select id="highOct">
            <option>0</option><option>1</option><option>2</option><option>3</option>
            <option>4</option><option>5</option><option>6</option><option>7</option>
            <option>8</option>
          </select>
        </label>
      </div>
      <p style="margin:8px 2px 0;color:#444;font-size:0.95em;">
        Files are transposed by <strong>Starting scale note/octave</strong> above before expansion. Output is clamped to this range.
      </p>
    </div>

    <div id="gapOptions" class="gap-controls">
      <strong>Missing note handling:</strong>
      <select id="gapMode">
        <option value="synth">Synthesize (pitch-shift) missing notes</option>
        <option value="silent">Fill gaps with silent WAVs</option>
      </select>
    </div>

    <p id="dragMessage" style="margin-bottom:8px;display:none;"><strong>Drag the notes into the scale note order you want.&nbsp;&nbsp;Right-click to insert/delete silent placeholders:</strong></p>

    <div id="fileList"></div>

    <div id="touchReorderControls" class="touch-reorder" style="display:none;">
      <button id="moveUpBtn" type="button" aria-label="Move selected note up">Move Up</button>
      <button id="moveDownBtn" type="button" aria-label="Move selected note down">Move Down</button>
      <button id="insertAfterBtn" type="button" aria-label="Insert silent placeholder after selected note">Insert Silent Placeholder</button>
      <button id="deleteBtn" type="button" aria-label="Delete selected item from list">Delete Selected Item from List</button>

      <button id="makePlaceholderBtn" type="button" aria-label="Temporarily replace with placeholder">Make Temporary Placeholder</button>
      <button id="restoreSampleBtn" type="button" aria-label="Restore original sample">Restore Original Sample</button>
    </div>

    <div id="exportStatus" role="status" aria-live="polite" style="margin-top:6px; min-height:1.2em; text-align:center; font-size:0.95em; color:#333;"></div>

    <div class="action-row">
      <button id="importZipBtn" title="Load and edit an ABC Transcription Tools custom instrument (.zip)">Import Custom Instrument (.zip)</button>
      <button id="exportZip" title="Export an ABC Transcription Tools custom instrument .zip file">Export Custom Instrument</button>
    </div>

    <!-- Hidden file inputs for controlled flows -->
    <input type="file" id="importZipInput" accept=".zip" style="display:none;">

    <script>
      function DoStartup() {

        // For mobile adaptation testing, set true to force mobile test
        const gForceMobile = false;

        const notes = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        let files = [];
        let originalFiles = [];

        const fileInput = document.getElementById('fileInput');
        const startNumber = document.getElementById('startNumber');
        const startNote = document.getElementById('startNote');
        const fileList = document.getElementById('fileList');
        const exportZipBtn = document.getElementById('exportZip');
        const importZipBtn = document.getElementById('importZipBtn');
        const importZipInput = document.getElementById('importZipInput');

        const autoSortCheckbox = document.getElementById('autoSort');
        const gapOptions = document.getElementById('gapOptions');
        const gapMode = document.getElementById('gapMode');
        const dragMessage = document.getElementById('dragMessage');

        const volumeScaleInput = document.getElementById('volumeScale');
        const fadeTimeInput = document.getElementById('fadeTime');

        const trimSilenceCheckbox = document.getElementById('trimSilence');
        const silenceDbInput = document.getElementById('silenceDb');
        const thresholdControls = document.getElementById('thresholdControls');
        const applyThresholdBtn = document.getElementById('applyThresholdBtn');
        const instructionsBtn = document.getElementById('instructionsBtn');

        const forceMonoWavCheckbox = document.getElementById('forceMonoWav');

        const disableMidiDetectCheckbox = document.getElementById('disableMidiDetect');

        // Range Expander UI
        const rangeExpanderRow = document.getElementById('rangeExpanderRow');
        const rangeExpanderCheckbox = document.getElementById('rangeExpander');
        const rangeControls = document.getElementById('rangeControls');
        const lowOct = document.getElementById('lowOct');
        const lowNote = document.getElementById('lowNote');
        const highOct = document.getElementById('highOct');
        const highNote = document.getElementById('highNote');

        const exportStatusEl = document.getElementById('exportStatus');
        function setExportStatus(msg){ if (exportStatusEl) exportStatusEl.textContent = msg; }
        function clearExportStatus(){ if (exportStatusEl) exportStatusEl.textContent = ''; }

        const tick = () => new Promise(r => setTimeout(r, 0));

        var gFileSaveName = "custom_instrument.zip";

        /* --- Preview playback state --- */
        let gPrevCtx = null;
        let gPrevSource = null;
        let gPrevGain = null;
        let gPrevBtn = null;
        let gPrevPlayId = 0;
        let gIsPlaying = false;

        function isIOS() {
          if (/iPad|iPhone|iPod/.test(navigator.platform)) return true;
          return navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);
        }
        function isIPad() {
          return (
            (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform)) ||
            (navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /iPad/.test(navigator.platform))
          );
        }
        function isAndroid() { return /Android/i.test(navigator.userAgent); }

        // Touch/manual-reorder support
        const isMobile = gForceMobile || isIOS() || isIPad() || isAndroid();

        // Desktop-only helper
        function isDesktop() {
          if (gForceMobile){
            return false;
          }
          return !(isIOS() || isIPad() || isAndroid());
        }

        const touchReorderControls = document.getElementById('touchReorderControls');
        const moveUpBtn = document.getElementById('moveUpBtn');
        const moveDownBtn = document.getElementById('moveDownBtn');
        const insertAfterBtn = document.getElementById('insertAfterBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const makePlaceholderBtn = document.getElementById('makePlaceholderBtn');
        const restoreSampleBtn   = document.getElementById('restoreSampleBtn');

        let selectedIndex = -1; // manual mode selection

        // Sorted-mode mobile selection
        let selectedRef = null; // { kind: 'real'|'placeholder', fileRef: File|null, renderIdx: number }

        // Track samples temporarily suppressed (treated as placeholders)
        const gTempSuppressed = new WeakSet();

        // Convert an absolute pitch index to a "NoteOctave" label, e.g., "Db4"
        function piToNoteOctave(absPI) {
          const octave = Math.floor(absPI / 12);
          const noteIndex = absPI % 12;
          const noteNames = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
          return `${noteNames[noteIndex]}${octave}`;
        }

        // Builds a "temp-meta" badge describing where a temporary placeholder came from
        function buildTempMetaBadge(fileName, absPI) {
          const meta = document.createElement('span');
          meta.className = 'temp-meta';
          meta.textContent = `original: ${fileName}`;
          meta.title = `Temporarily replaced\nOriginal file: ${fileName}\nMapped note: ${piToNoteOctave(absPI)}`;
          return meta;
        }

        // Sorted/Range mode helper
        function isSortedMode() {
          return autoSortCheckbox.checked || rangeExpanderCheckbox.checked;
        }

        // Can we show the temp toggle on this platform/mode?
        function canTempToggleOnDesktopSorted(isPlaceholderRow) {
          return isDesktop() && isSortedMode() && !isPlaceholderRow;
        }

        function isTempSuppressedFile(f) {
          return !!(f && gTempSuppressed && gTempSuppressed.has(f));
        }

        // Toggle one file between "real" and "temporary placeholder"
        function toggleTemporaryPlaceholderForFile(fileRef) {
          if (!fileRef) return;
          if (gTempSuppressed.has(fileRef)) gTempSuppressed.delete(fileRef);
          else gTempSuppressed.add(fileRef);
          safeRenderList();
          updateDragInteractivity();
        }

        insertAfterBtn.addEventListener('click', () => {
          // Manual mode only
          if (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) return;
          stopPreviewIfPlaying();
          const idx = (selectedIndex >= 0 && selectedIndex < files.length) ? selectedIndex : -1;
          insertPlaceholderAfter(idx);
        });

        if (disableMidiDetectCheckbox) {
          disableMidiDetectCheckbox.addEventListener('change', () => {
            // re-run mapping/sorting and refresh the view
            stopPreviewIfPlaying();
            sortFilesIfNeeded(); // will honor the new parse behavior
            if ((autoSortCheckbox.checked || rangeExpanderCheckbox.checked) && !gHasHashedNames) {
              detectAndApplyLowestPitch();
            }
            safeRenderList();
            updateDragInteractivity();
            clearSelection();
          });
        }

        // Generic delete button (mobile)
        if (deleteBtn) {
          deleteBtn.addEventListener('click', () => {
            stopPreviewIfPlaying();

            const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

            if (manualMode) {
              if (selectedIndex < 0 || selectedIndex >= files.length) return;
              const f = files[selectedIndex];
              if (f && f._isPlaceholder) {
                deletePlaceholderAtIndex(selectedIndex);
              } else {
                deleteSampleAtIndex(selectedIndex);
              }
              return;
            }

            // Sorted / Range mode:
            if (!selectedRef) return;

            // Case A: real row
            if (selectedRef.kind === 'real' && selectedRef.fileRef) {
              const idx = files.findIndex(f => f === selectedRef.fileRef);
              if (idx >= 0) {
                selectedRef = null;
                deleteSampleAtIndex(idx);
              }
              return;
            }

            // Case B: TEMP placeholder row (suppressed real sample)
            if (selectedRef.kind === 'placeholder' && selectedRef.fileRef && isTempSuppressedFile(selectedRef.fileRef)) {
              const idx = files.findIndex(f => f === selectedRef.fileRef);
              if (idx >= 0) {
                selectedRef = null;
                deleteSampleAtIndex(idx);
              }
              return;
            }
          });
        }

        // Unified enable/disable that lets CSS handle the "idle/dim" look
        function setBtnState(btn, enabled) {
          if (!btn) return;
          btn.disabled = !enabled;
        }

        function updateDeleteBtnState() {
          if (!deleteBtn) return;

          const manualMode = !isSortedMode ? (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked) : !isSortedMode();

          if (manualMode) {
            const valid = selectedIndex >= 0 && selectedIndex < files.length;
            setBtnState(deleteBtn, valid);
            return;
          }

          // sorted/range modes: allow delete if
          //  - a real row with fileRef is selected, OR
          //  - a placeholder row WITH fileRef that is TEMP-suppressed is selected
          const canDelete =
            !!selectedRef &&
            (
              (selectedRef.kind === 'real' && !!selectedRef.fileRef) ||
              (selectedRef.kind === 'placeholder' && !!selectedRef.fileRef && isTempSuppressedFile(selectedRef.fileRef))
            );

          setBtnState(deleteBtn, canDelete);
        }

        function updateTempButtonsState() {
          if (!isMobile) return;

          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

          // Only show these in sorted/range modes
          if (makePlaceholderBtn) makePlaceholderBtn.style.display = manualMode ? 'none' : '';
          if (restoreSampleBtn)   restoreSampleBtn.style.display   = manualMode ? 'none' : '';

          // Default disabled
          setBtnState(makePlaceholderBtn, false);
          setBtnState(restoreSampleBtn, false);

          if (manualMode || !selectedRef) return;

          const fileRef = selectedRef.fileRef || null;

          // Enable “Make Placeholder” on a real, unsuppressed mapped sample
          if (selectedRef.kind === 'real' && fileRef && !gTempSuppressed.has(fileRef)) {
            setBtnState(makePlaceholderBtn, true);
          }

          // Enable “Restore” if:
          // - a real row that’s currently suppressed, or
          // - a TEMP placeholder row that carries its original fileRef
          const canRestore =
            (selectedRef.kind === 'real' && fileRef && gTempSuppressed.has(fileRef)) ||
            (selectedRef.kind === 'placeholder' && fileRef && gTempSuppressed.has(fileRef));

          if (canRestore) setBtnState(restoreSampleBtn, true);
        }

        function clearSelection(){
          selectedIndex = -1;
          selectedRef = null;
          fileList.querySelectorAll('.file-item').forEach(el => el.classList.remove('selected'));
          updateMoveButtons();
          updateDeleteBtnState();
          updateTempButtonsState();
          if (isMobile) updateMobileReorderUI();
        }

        function selectManualRow(i){
          selectedIndex = i;
          selectedRef = null;
          fileList.querySelectorAll('.file-item.real').forEach((el, idx) => {
            el.classList.toggle('selected', idx === selectedIndex);
          });
          updateMoveButtons();
          updateDeleteBtnState();
          if (isMobile) updateMobileReorderUI(); // enable Insert-after right away
        }

        function selectRowForButton(btn){
          const row = btn && btn.closest('.file-item.real');
          if (!row) return;
          const i = Number(row.dataset.index);
          if (!Number.isInteger(i)) return;
          selectManualRow(i);
        }

        function selectSortedRow(kind, fileRef, renderIdx) {
          selectedRef = { kind, fileRef, renderIdx };
          selectedIndex = -1;
          fileList.querySelectorAll('.file-item').forEach((el) => el.classList.remove('selected'));
          const row = fileList.querySelector(`.file-item[data-render-index="${renderIdx}"]`);
          if (row) row.classList.add('selected');
          updateDeleteBtnState();
          updateTempButtonsState(); 
        }

        function updateMoveButtons() {
          // If the mobile control bar is hidden, disable move buttons and bail
          if (!isMobile || touchReorderControls.style.display === 'none') {
            setBtnState(moveUpBtn,   false);
            setBtnState(moveDownBtn, false);
            updateDeleteBtnState();
            return;
          }

          const len = files.length;
          const valid = selectedIndex >= 0 && selectedIndex < len;

          // Move Up/Down are only meaningful in manual mode
          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

          setBtnState(moveUpBtn,   manualMode && valid && selectedIndex > 0);
          setBtnState(moveDownBtn, manualMode && valid && selectedIndex < len - 1);

          // Keep Delete in sync
          updateDeleteBtnState();
        }

        function updateMobileReorderUI() {
          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

          // On mobile keep the bar visible
          if (touchReorderControls) touchReorderControls.style.display = isMobile ? 'flex' : 'none';

          // Show/hide per-mode controls
          if (moveUpBtn)      moveUpBtn.style.display      = manualMode ? '' : 'none';
          if (moveDownBtn)    moveDownBtn.style.display    = manualMode ? '' : 'none';
          if (insertAfterBtn) insertAfterBtn.style.display = manualMode ? '' : 'none';
          if (deleteBtn)      deleteBtn.style.display      = isMobile ? '' : 'none';

          // Hint text
          if (dragMessage) {
            if (manualMode) {
              dragMessage.style.display = 'block';
              dragMessage.innerHTML = "<strong>To reorder the notes, select a note and then click Move Up or Move Down:</strong>";
            } else {
              dragMessage.style.display = 'none';
            }
          }

          // Enabled/disabled states
          const len = files.length;
          const validSel = selectedIndex >= 0 && selectedIndex < len;

          setBtnState(moveUpBtn,      manualMode && validSel && selectedIndex > 0);
          setBtnState(moveDownBtn,    manualMode && validSel && selectedIndex < len - 1);
          setBtnState(insertAfterBtn, manualMode && validSel);

          updateDeleteBtnState();

          updateTempButtonsState(); 
        }

        // Absolute effective PI for first row
        let gRenderMinPI = 0;

        function getPreviewContext() {
          if (!gPrevCtx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            gPrevCtx = new AC();
          }
          return gPrevCtx;
        }

        function markPlaying(btn, on) {
          if (btn) {
            btn.classList.toggle('is-playing', !!on);
            btn.setAttribute('aria-pressed', on ? 'true' : 'false');
          }
          gIsPlaying = !!on;
          updateDragInteractivity();
        }

        function stopCurrentPreview() {
          try {
            if (gPrevSource) {
              gPrevSource.onended = null;
              gPrevSource.stop(0);
              gPrevSource.disconnect();
            }
            if (gPrevGain) gPrevGain.disconnect();
          } catch(e) {}
          gPrevSource = null;
          gPrevGain = null;

          if (gPrevBtn) markPlaying(gPrevBtn, false);
          gPrevBtn = null;
        }

        async function playBufferWithScale(buffer, btn) {
          const ctx = getPreviewContext();
          try { await ctx.resume(); } catch(e) {}

          const playId = ++gPrevPlayId;

          const source = ctx.createBufferSource();
          source.buffer = buffer;

          const gain = ctx.createGain();
          const scale = Math.max(0, parseFloat(volumeScaleInput.value) || 0);
          gain.gain.value = scale;

          source.connect(gain);
          gain.connect(ctx.destination);

          stopCurrentPreview();
          gPrevSource = source;
          gPrevGain = gain;
          gPrevBtn = btn;
          markPlaying(btn, true);

          source.onended = () => {
            if (playId !== gPrevPlayId) return;
            stopCurrentPreview();
          };

          source.start(0);
        }

        volumeScaleInput.addEventListener('input', () => {
          if (gPrevGain) {
            const scale = Math.max(0, parseFloat(volumeScaleInput.value) || 0);
            gPrevGain.gain.value = scale;
          }
        });

        async function previewFile(file, btn) {
          try {
            if (gPrevBtn === btn && gPrevSource) { stopCurrentPreview(); return; }
            let buf = await decodeFileToAudioBuffer(file);
            if (forceMonoWavCheckbox.checked) { buf = mixToMono(buf); }
            if (trimSilenceCheckbox.checked) {
              const thr = dbToLinear(Number(silenceDbInput.value));
              buf = trimLeadingSilenceFromBuffer(buf, thr);
            }
            await playBufferWithScale(buf, btn);
          } catch (e) {
            console.error(e);
            stopCurrentPreview();
          }
        }

        // Hashed filename detection
        let gHasHashedNames = false;
        function stripExtension(name) { const i = name.lastIndexOf('.'); return i >= 0 ? name.slice(0, i) : name; }
        const HASHLIKE_RE = /(?:^|[_\-])([0-9a-fA-F]{16,})(?:$|\b)/;
        function hasHashedFilenames(list){ return list.some(f=>HASHLIKE_RE.test(stripExtension(f.name))); }
        function applyHashedModeUIState(){ autoSortCheckbox.checked=false; gapOptions.style.display='none'; dragMessage.style.display='block'; }
        function clearHashedModeUIState(){ gapOptions.style.display=autoSortCheckbox.checked?'block':'none'; dragMessage.style.display=autoSortCheckbox.checked?'none':'block'; }

        // Pitch parsing
        const sharpToFlat = {"C#":"Db","D#":"Eb","F#":"Gb","G#":"Ab","A#":"Bb","Cs":"Db","Ds":"Eb","Fs":"Gb","Gs":"Ab","As":"Bb","CS":"Db","DS":"Eb","FS":"Gb","GS":"Ab","AS":"Bb"};
        const noteOrder = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
        const noteRegex = /([A-G][#bsS]?)(\d+)/i;

        // Existing helpers in your file we reuse:
        // - sharpToFlat, noteOrder
        // - stripExtension(name)  -> returns name without extension

        // Extract the last 1–3 digit integer found in a file's base name.
        // Examples:
        //   "Foo-60.wav"                     -> 60
        //   "ChorFemKhb - ChorFem-71.mp3"    -> 71
        //   "Bar_062_take3.wav"              -> 3 (last number)  <-- we handle this by preferring a strict end-match first
        function extractLastIntegerFromBaseName(filename) {
          const base = stripExtension(filename);

          // Prefer a number at the very end (common in your examples)
          const endMatch = base.match(/(\d{1,3})\s*$/);
          if (endMatch) {
            return parseInt(endMatch[1], 10);
          }

          // Otherwise, fall back to "last number anywhere" (still 1–3 digits)
          const all = base.match(/\d{1,3}/g);
          if (all && all.length) {
            return parseInt(all[all.length - 1], 10);
          }

          return null;
        }

        // Convert a MIDI number (C4=60) into your internal pitch parts:
        // pitchIndex = octave*12 + noteIdx  with C0 = 0  => pitchIndex = midi - 12
        // Returns null if midi is out of a reasonable range for your UI.
        function midiToPitchParts(midi) {
          if (!Number.isInteger(midi)) return null;

          // Typical safe range for your UI (C0..B8) -> MIDI 12..119
          // You can loosen if desired, but this keeps octave in 0..8, matching other code paths.
          if (midi < 12 || midi > 119) return null;

          const pitchIndex = midi - 12;                     // map MIDI to your 0-based C0 index
          const octave     = Math.floor(pitchIndex / 12);
          const noteIdx    = pitchIndex % 12;

          return { noteIdx, octave, pitchIndex };
        }

        // First try NoteName+Octave; if that fails AND the checkbox is NOT checked,
        // fall back to MIDI-number detection (e.g. Foo-60.wav -> 60 -> C4).
        function parsePitchFromName(name) {
          // Attempt 1: note name + octave
          const m = name.match(noteRegex);
          if (m) {
            let note = m[1];
            const oct = parseInt(m[2], 10);
            if (!Number.isNaN(oct)) {
              note = note.charAt(0).toUpperCase() + (note.slice(1) || "");
              note = sharpToFlat[note] || note;
              const idx = noteOrder.indexOf(note);
              if (idx >= 0) {
                return { noteIdx: idx, octave: oct, pitchIndex: oct * 12 + idx };
              }
            }
          }

          // If MIDI-number detect is disabled via the new checkbox, stop here.
          if (disableMidiDetectCheckbox && disableMidiDetectCheckbox.checked) {
            return null;
          }

          // Attempt 2: MIDI number fallback from filename
          const midi = extractLastIntegerFromBaseName(name);
          if (midi !== null) {
            const parts = midiToPitchParts(midi);
            if (parts) return parts;
          }

          return null;
        }

        function detectAndApplyLowestPitch() {
          let minPI = Infinity, minNoteIdx=0, minOct=0;
          for (const f of files){ const p=parsePitchFromName(f.name); if(p && p.pitchIndex<minPI){minPI=p.pitchIndex;minNoteIdx=p.noteIdx;minOct=p.octave;} }
          if (minPI!==Infinity){ startNote.value=String(minNoteIdx); startNumber.value=String(Math.max(0,Math.min(9,minOct))); }
        }

        function sortFilesIfNeeded() {
          if (autoSortCheckbox.checked) {
            files.sort((a, b) => {
              const A = a.name.match(noteRegex), B = b.name.match(noteRegex);
              if (A && B) {
                let nA = A[1].charAt(0).toUpperCase() + (A[1].slice(1) || "");
                let nB = B[1].charAt(0).toUpperCase() + (B[1].slice(1) || "");
                nA = sharpToFlat[nA] || nA;
                nB = sharpToFlat[nB] || nB;
                const oA = parseInt(A[2], 10), oB = parseInt(B[2], 10);
                if (oA !== oB) return oA - oB;
                return noteOrder.indexOf(nA) - noteOrder.indexOf(nB);
              }
              if (A) return -1;
              if (B) return 1;
              return 0;
            });
          }
        }

        // Name for row index i (use effective absolute PI = gRenderMinPI + i)
        function getProposedNameForIndex(i, extIfNotTrim){
          const absPI = gRenderMinPI + i;
          const octave = Math.floor(absPI/12);
          const noteIndex = absPI % 12;

          if (forceMonoWavCheckbox.checked || trimSilenceCheckbox.checked) {
            return `${notes[noteIndex]}${octave}.wav`;
          }
          return `${notes[noteIndex]}${octave}.${extIfNotTrim}`;
        }

        // Desired range from UI
        function getDesiredRangePI(){
          const lo = parseInt(lowOct.value,10)*12 + parseInt(lowNote.value,10);
          const hi = parseInt(highOct.value,10)*12 + parseInt(highNote.value,10);
          if (hi >= lo) return {minPI: lo, maxPI: hi};
          return {minPI: hi, maxPI: lo};
        }

        // Build continuous range; applies Starting Note/Octave as a transpose to source pitches BEFORE expansion.
        function buildContinuousRange(){
          const matched = [], unmatched = [];
          const seen = new Set();
          let hasDuplicatePitch = false;

          for (const f of files){
            const p = parsePitchFromName(f.name);
            if (p){
              if (p.octave > 8){
                DayPilot.Modal.alert(
                  '<p style="text-align:center;font-size:1.1em;"><strong>Note Octave Out-of-Range Detected (Max is 8)</strong><br/><br/>Auto-sort and note range detect will be disabled.</p>',
                  { theme:"modal_flat", top:200 }
                );
                applyHashedModeUIState();
                setTimeout(()=>{ files=[...originalFiles]; safeRenderList(); }, 250);
                return { full:[], unmatched: files.slice(), nameBasePI:0, minPI:0, maxPI:-1 };
              }

              if (seen.has(p.pitchIndex)) hasDuplicatePitch = true;
              else { seen.add(p.pitchIndex); matched.push({ file:f, pitchIndex:p.pitchIndex, ext:f.name.split('.').pop() }); }
            } else {
              unmatched.push(f);
            }
          }

          if (hasDuplicatePitch) {
            DayPilot.Modal.alert(
              '<p style="text-align:center;font-size:1.1em;"><strong>Duplicate Pitch Detected</strong><br/><br/>Two or more files map to the same pitch.<br/><br/>Auto-sort and note range detect have been disabled.</p>',
              { theme:"modal_flat", top:200 }
            );
            applyHashedModeUIState();
            setTimeout(()=>{ files=[...originalFiles]; safeRenderList(); }, 250);
            return { full:[], unmatched: files.slice(), nameBasePI:0, minPI:0, maxPI:-1 };
          }

          if (!matched.length) return { full:[], unmatched, nameBasePI:0, minPI:0, maxPI:-1 };

          matched.sort((a,b)=>a.pitchIndex-b.pitchIndex);
          const actualMinPI = matched[0].pitchIndex;
          const actualMaxPI = matched[matched.length-1].pitchIndex;

          // Starting Note/Octave -> basePI
          const basePI = parseInt(startNumber.value,10)*12 + parseInt(startNote.value,10);
          const transpose = basePI - actualMinPI;

          // Effective pitch map
          const effPitchMap = new Map();
          let effMin = Infinity, effMax = -Infinity;
          for (const m of matched){
            const effPI = m.pitchIndex + transpose;
            effPitchMap.set(effPI, { file: m.file, ext: m.ext });
            if (effPI < effMin) effMin = effPI;
            if (effPI > effMax) effMax = effPI;
          }

          // Final render range
          let finalMinPI = effMin;
          let finalMaxPI = effMax;

          if (rangeExpanderCheckbox.checked) {
            const desired = getDesiredRangePI();
            finalMinPI = desired.minPI;
            finalMaxPI = desired.maxPI;
          }

          const full = [];
          for (let pi = finalMinPI; pi <= finalMaxPI; pi++){
            const m = effPitchMap.get(pi) || null;
            full.push({ file: m ? m.file : null, pitchIndex: pi, ext: m ? m.ext : "wav" });
          }

          return { full, unmatched, nameBasePI: basePI, minPI: finalMinPI, maxPI: finalMaxPI, effMin, effMax, transpose };
        }

        /* ====== Audio utils ====== */
        let gDecodeOffline = null;
        function getDecodeOffline(){
          if (!gDecodeOffline) gDecodeOffline = new OfflineAudioContext(1, 1, 44100);
          return gDecodeOffline;
        }

        const decodeCache = new WeakMap();
        async function decodeFileToAudioBuffer(file){
          if (decodeCache.has(file)) return decodeCache.get(file);
          const p = (async ()=>{
            const offline = getDecodeOffline();
            const arr = await file.arrayBuffer();
            return await offline.decodeAudioData(arr.slice(0));
          })();
          decodeCache.set(file,p);
          return p;
        }

        async function pitchShiftBuffer(srcBuf, semitones){
          const rate = Math.pow(2, semitones/12);
          const outLength = Math.max(1, Math.ceil(srcBuf.length / rate));
          const offline = new OfflineAudioContext(srcBuf.numberOfChannels, outLength, srcBuf.sampleRate);
          const src = offline.createBufferSource();
          src.buffer = srcBuf;
          src.playbackRate.value = rate;
          src.connect(offline.destination);
          src.start();
          return await offline.startRendering();
        }

        function generateSilentWav(durationSec=1, sampleRate=44100){
          const numSamples = Math.floor(durationSec*sampleRate);
          const buffer = new ArrayBuffer(44 + numSamples*2);
          const view = new DataView(buffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          ws(0,"RIFF"); view.setUint32(4, 36+numSamples*2, true); ws(8,"WAVE"); ws(12,"fmt ");
          view.setUint32(16,16,true); view.setUint16(20,1,true); view.setUint16(22,1,true);
          view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
          view.setUint16(32,2,true); view.setUint16(34,16,true); ws(36,"data");
          view.setUint32(40,numSamples*2,true);
          return new Blob([buffer], {type:"audio/wav"});
        }

        function audioBufferToWav(buffer){
          const numChannels=buffer.numberOfChannels, sampleRate=buffer.sampleRate;
          const length=buffer.length*numChannels*2+44;
          const arrayBuffer=new ArrayBuffer(length); const view=new DataView(arrayBuffer);
          const ws=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
          let pos=0; ws(pos,"RIFF"); pos+=4; view.setUint32(pos,length-8,true); pos+=4;
          ws(pos,"WAVE"); pos+=4; ws(pos,"fmt "); pos+=4; view.setUint32(pos,16,true); pos+=4;
          view.setUint16(pos,1,true); pos+=2; view.setUint16(pos,numChannels,true); pos+=2;
          view.setUint32(pos,sampleRate,true); pos+=4; view.setUint32(pos,sampleRate*numChannels*2,true); pos+=4;
          view.setUint16(pos,numChannels*2,true); pos+=2; view.setUint16(pos,16,true); pos+=2;
          ws(pos,"data"); pos+=4; view.setUint32(pos,length-44,true); pos+=4;
          const channels=[]; for(let i=0;i<numChannels;i++) channels.push(buffer.getChannelData(i));
          for(let i=0;i<buffer.length;i++){
            for(let ch=0; ch<numChannels; ch++){
              let s=channels[ch][i]; s=Math.max(-1,Math.min(1,s));
              view.setInt16(pos, s<0 ? s*0x8000 : s*0x7FFF, true); pos+=2;
            }
          }
          return new Blob([arrayBuffer], {type:"audio/wav"});
        }

        function dbToLinear(db){ return Math.pow(10, db/20); }

        function trimLeadingSilenceFromBuffer(buffer, thresholdLinear){
          const numChannels=buffer.numberOfChannels, length=buffer.length, sr=buffer.sampleRate;
          const preRollSamples = Math.round(sr*0.003);
          const windowSize = Math.max(32, Math.round(sr*0.001));
          let startIndex=0, found=false;
          for (let i=0; i<length; i+=windowSize){
            let maxAbs=0;
            for(let ch=0; ch<numChannels; ch++){
              const data=buffer.getChannelData(ch);
              const end=Math.min(i+windowSize,length);
              for(let s=i; s<end; s++){ const v=Math.abs(data[s]); if(v>maxAbs) maxAbs=v; }
              if (maxAbs>=thresholdLinear) break;
            }
            if (maxAbs>=thresholdLinear){ startIndex=Math.max(0, i-preRollSamples); found=true; break; }
          }
          if (!found){
            const tiny=Math.min(length, Math.round(sr*0.01));
            startIndex=Math.max(0, length-tiny);
          }
          const newLength=Math.max(1, length-startIndex);
          const out=new AudioBuffer({length:newLength, numberOfChannels:numChannels, sampleRate:sr});
          for(let ch=0; ch<numChannels; ch++){
            const src=buffer.getChannelData(ch).subarray(startIndex, startIndex+newLength);
            out.copyToChannel(src, ch, 0);
          }
          return out;
        }

        // RMS-preserving mono (with peak cap)
        function mixToMono(buffer){
          if (buffer.numberOfChannels === 1) return buffer;

          const len = buffer.length;
          const sr  = buffer.sampleRate;
          const chs = buffer.numberOfChannels;

          const mono = new Float32Array(len);

          let sumSquaresOrig = 0;
          for (let i = 0; i < len; i++) {
            let sum = 0;
            let power = 0;
            for (let ch = 0; ch < chs; ch++) {
              const v = buffer.getChannelData(ch)[i];
              sum   += v;
              power += v * v;
            }
            mono[i] = sum;
            sumSquaresOrig += power / chs;
          }

          let sumSquaresMono = 0;
          let peakMono = 0;
          for (let i = 0; i < len; i++) {
            const v = mono[i];
            sumSquaresMono += v * v;
            const av = Math.abs(v);
            if (av > peakMono) peakMono = av;
          }

          const rmsOrig = Math.sqrt(sumSquaresOrig / len);
          const rmsMono = Math.sqrt(sumSquaresMono / len);

          let gain = 1.0;
          if (rmsMono > 0 && rmsOrig > 0) {
            gain = rmsOrig / rmsMono;
          }
          if (peakMono > 0 && peakMono * gain > 1.0) {
            gain = 1.0 / peakMono;
          }

          if (gain !== 1.0) {
            for (let i = 0; i < len; i++) mono[i] *= gain;
          }

          const out = new AudioBuffer({ length: len, numberOfChannels: 1, sampleRate: sr });
          out.copyToChannel(mono, 0, 0);
          return out;
        }

        async function bufferToFinalBlob(buffer){
          if (forceMonoWavCheckbox.checked) {
            buffer = mixToMono(buffer);
          }
          if (trimSilenceCheckbox.checked){
            const thr = dbToLinear(Number(silenceDbInput.value));
            buffer = trimLeadingSilenceFromBuffer(buffer, thr);
          }
          return audioBufferToWav(buffer);
        }

        async function fileToProcessedBlob(file){
          const needsProcessing = trimSilenceCheckbox.checked || forceMonoWavCheckbox.checked;
          if (!needsProcessing) return file;
          const buf = await decodeFileToAudioBuffer(file);
          return bufferToFinalBlob(buf);
        }

        // ---------- Placeholder PREVIEW helpers ----------
        function findNearestSourceIndex(full, targetIdx){
          for (let d=1; d<full.length; d++){
            const lower = targetIdx - d;
            const higher = targetIdx + d;
            if (lower >= 0 && full[lower] && full[lower].file) return lower;
            if (higher < full.length && full[higher] && full[higher].file) return higher;
          }
          return -1;
        }

        // ---------- PREVIEW: placeholder row (auto/range) using ONLY real, unsuppressed sources ----------
        async function previewPlaceholderAtIndex(full, idx, btn){
          try {
            if (gPrevBtn === btn && gPrevSource) { 
              stopCurrentPreview(); 
              return; 
            }

            // Build a map of indices that have a REAL, UNSUPPRESSED source
            const haveAtIndex = new Map();
            for (let i = 0; i < full.length; i++) {
              const slot = full[i];
              if (slot && slot.file && !(gTempSuppressed && gTempSuppressed.has(slot.file))) {
                haveAtIndex.set(i, slot.file);
              }
            }
            if (haveAtIndex.size === 0) return; // nothing to borrow from

            // Decode only those real/unsuppressed sources once
            const decodedAtIndex = new Map();
            await Promise.all(
              Array.from(haveAtIndex.entries()).map(async ([i, file]) => {
                try {
                  decodedAtIndex.set(i, await decodeFileToAudioBuffer(file));
                } catch (e) {
                  console.warn("Decode failed for preview source:", file && file.name, e);
                }
              })
            );

            // Neighbor search that ONLY considers decodedAtIndex (i.e., real/unsuppressed)
            function findSourceIndex(targetIdx){
              for (let d = 1; d < full.length; d++) {
                const lower  = targetIdx - d;
                const higher = targetIdx + d;
                if (lower  >= 0           && decodedAtIndex.has(lower))  return lower;
                if (higher <  full.length && decodedAtIndex.has(higher)) return higher;
              }
              return -1;
            }

            const srcIdx = findSourceIndex(idx);
            if (srcIdx < 0) return;

            let buf = decodedAtIndex.get(srcIdx);
            if (forceMonoWavCheckbox.checked) {
              buf = mixToMono(buf);
            }
            if (trimSilenceCheckbox.checked) {
              const thr = dbToLinear(Number(silenceDbInput.value));
              buf = trimLeadingSilenceFromBuffer(buf, thr);
            }

            const semitones = idx - srcIdx;
            const shifted   = await pitchShiftBuffer(buf, semitones);
            await playBufferWithScale(shifted, btn);

          } catch (e) {
            console.warn("Placeholder preview failed:", e);
            stopCurrentPreview();
          }
        }

        // --- Placeholder utilities ---

        function createPlaceholderFile() {
          const blob = generateSilentWav(1);
          const f = new File([blob], "placeholder.wav", { type: "audio/wav" });
          Object.defineProperty(f, "_isPlaceholder", { value: true, enumerable: false });
          return f;
        }

        // Insert manual placeholder
        function insertPlaceholderAfter(idx) {
          stopPreviewIfPlaying();
          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;
          if (!manualMode) return;

          const insertAt = (idx >= 0 && idx < files.length) ? idx + 1 : 0;
          const ph = createPlaceholderFile();
          files.splice(insertAt, 0, ph);

          if (isMobile) selectedIndex = insertAt;

          safeRenderList();
          updateDragInteractivity();
          if (isMobile) scrollSelectedIntoView();
        }

        function deletePlaceholderAtIndex(idx) {
          stopPreviewIfPlaying();
          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;
          if (!manualMode) return;
          if (idx < 0 || idx >= files.length) return;
          const f = files[idx];
          if (!f || !f._isPlaceholder) return;

          files.splice(idx, 1);

          if (isMobile) {
            if (selectedIndex > idx) selectedIndex -= 1;
            if (selectedIndex >= files.length) selectedIndex = files.length - 1;
            if (files.length === 0) selectedIndex = -1;
          }

          safeRenderList();
          updateDragInteractivity();

          if (isMobile && selectedIndex >= 0) scrollSelectedIntoView();
          updateDeleteBtnState();
        }

        // Remove a real sample and rebuild mapping (incl. Range Expander)
        function deleteSampleAtIndex(idx) {
          if (idx < 0 || idx >= files.length) return;
          const f = files[idx];
          if (!f || f._isPlaceholder) return;

          stopPreviewIfPlaying();

          files.splice(idx, 1);

          if (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) {
            sortFilesIfNeeded();
            if (autoSortCheckbox.checked && !gHasHashedNames) {
              detectAndApplyLowestPitch();
            }
          }

          safeRenderList();
          updateDragInteractivity();
          updateDeleteBtnState();
        }

        // --- Minimal context menu (right-click) for manual mode ---
        let ctxMenuEl = null;

        function ensureContextMenu() {
          if (ctxMenuEl) return ctxMenuEl;
          ctxMenuEl = document.createElement('div');
          ctxMenuEl.id = 'ctxMenu';
          ctxMenuEl.style.position = 'fixed';
          ctxMenuEl.style.zIndex = '99999';
          ctxMenuEl.style.background = '#fff';
          ctxMenuEl.style.border = '1px solid #ccc';
          ctxMenuEl.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
          ctxMenuEl.style.borderRadius = '4px';
          ctxMenuEl.style.minWidth = '180px';
          ctxMenuEl.style.fontSize = '0.9em';
          ctxMenuEl.style.display = 'none';
          ctxMenuEl.style.padding = '4px 0';
          ctxMenuEl.style.margin = '0';
          ctxMenuEl.style.cursor = 'default';
          document.body.appendChild(ctxMenuEl);
          return ctxMenuEl;
        }

        function showContextMenu(x, y, idx, { isPlaceholder, fileRef, isTempSuppressed } = {}) {
          if (isMobile) return;

          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

          const el = ensureContextMenu();
          clearContextMenuItems();

          if (manualMode) {
            // Manual mode menu
            addMenuItem('Insert silent placeholder after this note', () => {
              hideContextMenu();
              stopPreviewIfPlaying();
              insertPlaceholderAfter(idx);
            });

            if (isPlaceholder) {
              addSeparator();
              addMenuItem('Delete silent placeholder', () => {
                hideContextMenu();
                stopPreviewIfPlaying();
                deletePlaceholderAtIndex(idx);
              });
            } else {
              addSeparator();
              addMenuItem('Delete sample from list', () => {
                hideContextMenu();
                stopPreviewIfPlaying();
                deleteSampleAtIndex(idx);
              });
            }

          } else {
            // Sorted / Range mode menu
            if (!isPlaceholder) {
              if (canTempToggleOnDesktopSorted(false)) {
                addMenuItem(
                  isTempSuppressed ? 'Restore original sample' : 'Temporarily replace with placeholder',
                  () => {
                    hideContextMenu();
                    stopPreviewIfPlaying();
                    toggleTemporaryPlaceholderForFile(fileRef);
                  }
                );
                addSeparator();
              }
              addMenuItem('Delete sample from list', () => {
                hideContextMenu();
                stopPreviewIfPlaying();
                deleteSampleAtIndex(idx);
              });
            } else {
              // true placeholders: suppress a menu
              return;
            }
          }

          el.dataset.idx = String(idx);
          el.style.left = `${x}px`;
          el.style.top  = `${y}px`;
          el.style.display = 'block';

          const rect = el.getBoundingClientRect();
          const vw = window.innerWidth, vh = window.innerHeight;
          if (rect.right > vw)  el.style.left = `${Math.max(8, vw  - rect.width  - 8)}px`;
          if (rect.bottom > vh) el.style.top  = `${Math.max(8, vh - rect.height - 8)}px`;
        }


        function hideContextMenu() {
          if (ctxMenuEl) {
            ctxMenuEl.style.display = 'none';
            delete ctxMenuEl.dataset.idx;
          }
        }

        document.addEventListener('click', (e) => {
          if (!ctxMenuEl) return;
          if (ctxMenuEl.style.display !== 'none' && !ctxMenuEl.contains(e.target)) hideContextMenu();
        });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideContextMenu(); });

        function clearContextMenuItems() { if (!ctxMenuEl) return; while (ctxMenuEl.firstChild) ctxMenuEl.removeChild(ctxMenuEl.firstChild); }

        function addMenuItem(label, onClick) {
          const item = document.createElement('div');
          item.textContent = label;
          item.style.padding = '6px 12px';
          item.style.color = '#333';
          item.style.userSelect = 'none';
          item.style.fontWeight = 'normal';
          item.addEventListener('mouseover', () => { item.style.background = '#f0f0f0'; });
          item.addEventListener('mouseout',  () => { item.style.background = 'transparent'; });
          item.addEventListener('click', onClick);
          ctxMenuEl.appendChild(item);
        }

        function addSeparator() {
          const sep = document.createElement('div');
          sep.style.height = '1px';
          sep.style.margin = '4px 0';
          sep.style.background = '#e6e6e6';
          ctxMenuEl.appendChild(sep);
        }

        // ---------- RENDER LIST ----------
        function safeRenderList(){
          if (gPrevSource) return;
          renderList();
        }

        function renderList(){
          fileList.innerHTML='';

          // ===== Manual mode (Auto Sort OFF and Range Expander OFF) =====
          if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked){
            // Anchor manual naming to Starting Note/Octave
            gRenderMinPI = parseInt(startNumber.value,10)*12 + parseInt(startNote.value,10);

            files.forEach((file,i)=>{
              const item=document.createElement('div'); 
              item.className='file-item real'; 
              item.draggable=true; 
              item.dataset.index=i;
              item.dataset.renderIndex = String(i);

              const ext=file.name.split('.').pop(); 
              const proposedName=getProposedNameForIndex(i,ext);

              const nameSpan=document.createElement('span'); 
              const proposedSpan=document.createElement('span'); 
              proposedSpan.className='proposed';

              const ctrl=document.createElement('div'); 
              ctrl.className='controls';

              if (file._isPlaceholder) {
                // Placeholder row (manual mode)
                nameSpan.className = 'placeholder-label';
                nameSpan.textContent = '(placeholder)';
                proposedSpan.textContent = `→ ${proposedName} (silent)`;

                const spacer = document.createElement('button');
                spacer.className = 'preview-btn';
                spacer.type = 'button';
                spacer.textContent = '▶︎';
                spacer.style.visibility = 'hidden';
                spacer.tabIndex = -1;
                spacer.setAttribute('aria-hidden', 'true');
                ctrl.appendChild(spacer);

              } else {
                // Real file row (manual mode)
                nameSpan.textContent = file.name;
                proposedSpan.textContent = `→ ${proposedName}`;

                const btn=document.createElement('button'); 
                btn.className='preview-btn'; 
                btn.type='button'; 
                btn.textContent='▶︎';
                btn.addEventListener('click',(e)=>{
                  if (isMobile) {
                    const row = e.currentTarget.closest('.file-item.real');
                    if (row) {
                      const idx = Number(row.dataset.index);
                      if (Number.isInteger(idx)) selectManualRow(idx);
                    }
                  }
                  previewFile(file,e.currentTarget);
                });
                ctrl.appendChild(btn);
              }

              item.appendChild(nameSpan); 
              item.appendChild(proposedSpan); 
              item.appendChild(ctrl);

              // Mobile: tap selects a row for Move Up/Down buttons
              item.addEventListener('click', () => { if (isMobile) selectManualRow(i); });

              // Desktop right-click (manual)
              if (!isMobile) {
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  stopPreviewIfPlaying();
                  showContextMenu(e.clientX, e.clientY, i, { isPlaceholder: !!file._isPlaceholder });
                });
              }

              addDragHandlers(item); 
              fileList.appendChild(item);
            });

            updateDragInteractivity();
            updateMobileReorderUI();

            if (isMobile && selectedIndex >= 0 && selectedIndex < files.length) {
              selectManualRow(selectedIndex);
            }

            updateTempButtonsState(); // NEW: reflect current render
            return;
          }

          // ===== Auto/Range modes =====
          const built = buildContinuousRange();
          const { full, unmatched, minPI, maxPI } = built;
          if (minPI <= maxPI) gRenderMinPI = minPI;

          // No 'full' (couldn't map): just list actual files
          if (!full.length){
            files.forEach((file,i)=>{
              const isSuppressed = gTempSuppressed.has(file);
              const item=document.createElement('div'); 
              item.className='file-item real' + (isSuppressed ? ' temp-suppressed' : ''); 
              item.draggable=true; 
              item.dataset.index=i;
              item.dataset.renderIndex = String(i);

              const ext=file.name.split('.').pop(); 
              const proposedName=getProposedNameForIndex(i,ext);

              const nameSpan=document.createElement('span'); 
              nameSpan.textContent=file.name;

              if (isSuppressed) {
                const badge = document.createElement('span');
                badge.className = 'temp-badge';
                badge.textContent = 'temp';
                nameSpan.appendChild(badge);

                const absPI = gRenderMinPI + i;
                nameSpan.appendChild(buildTempMetaBadge(file.name, absPI));
              }

              const proposedSpan=document.createElement('span'); 
              proposedSpan.className='proposed'; 
              proposedSpan.textContent = isSuppressed
                ? `→ ${proposedName} (placeholder)`
                : `→ ${proposedName}`;

              const ctrl=document.createElement('div'); 
              ctrl.className='controls';

              const btn=document.createElement('button'); 
              btn.className='preview-btn'; 
              btn.type='button'; 
              btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>{
                if (isMobile) selectSortedRow('real', file, i);
                if (isSuppressed) {
                  stopCurrentPreview();
                } else {
                  previewFile(file,e.currentTarget);
                }
              });
              ctrl.appendChild(btn); 

              item.appendChild(nameSpan); 
              item.appendChild(proposedSpan); 
              item.appendChild(ctrl);
              addDragHandlers(item); 
              fileList.appendChild(item);

              // Mobile tap selects in auto mode
              item.addEventListener('click', () => {
                if (isMobile) selectSortedRow('real', file, i);
              });

              // Desktop: context menu
              if (!isMobile) {
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  stopPreviewIfPlaying();
                  showContextMenu(e.clientX, e.clientY, i, {
                    isPlaceholder: false,
                    fileRef: file,
                    isTempSuppressed: isSuppressed
                  });
                });
              }
            });

            updateDragInteractivity();
            updateTempButtonsState(); // NEW
            return;
          }

          // We have a continuous render plan (full)
          full.forEach((slot,idx)=>{
            // Treat a real slot as placeholder if it's temporarily suppressed
            const suppressed = !!(slot.file && gTempSuppressed.has(slot.file));

            if (slot.file && !suppressed){
              // Real file in mapped range
              const item=document.createElement('div');
              item.className='file-item real'; 
              item.draggable=true; 
              item.dataset.fileName=slot.file.name;
              item.dataset.renderIndex = String(idx);

              const originalIndex=files.findIndex(f=>f===slot.file); 
              if (originalIndex>=0) item.dataset.index=String(originalIndex);

              const nameSpan=document.createElement('span'); 
              nameSpan.textContent=slot.file.name;

              const proposed=getProposedNameForIndex(idx,slot.ext);
              const proposedSpan=document.createElement('span'); 
              proposedSpan.className='proposed'; 
              proposedSpan.textContent=`→ ${proposed}`;

              const ctrl=document.createElement('div'); 
              ctrl.className='controls';

              const btn=document.createElement('button'); 
              btn.className='preview-btn'; 
              btn.type='button'; 
              btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>{
                if (isMobile) selectSortedRow('real', slot.file, idx);
                previewFile(slot.file,e.currentTarget);
              });
              ctrl.appendChild(btn); 

              item.appendChild(nameSpan); 
              item.appendChild(proposedSpan); 
              item.appendChild(ctrl);
              addDragHandlers(item);

              // Mobile tap -> select this mapped real row
              item.addEventListener('click', () => {
                if (isMobile) selectSortedRow('real', slot.file, idx);
              });

              // Desktop: context menu (sorted)
              if (!isMobile) {
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  stopPreviewIfPlaying();
                  const idxInFiles = (originalIndex>=0) ? originalIndex : files.indexOf(slot.file);
                  showContextMenu(e.clientX, e.clientY, idxInFiles, {
                    isPlaceholder: false,
                    fileRef: slot.file,
                    isTempSuppressed: false
                  });
                });
              }

              fileList.appendChild(item);

            } else {
              // Placeholder row in auto/range OR temporarily suppressed real row
              const item=document.createElement('div');
              item.className = 'file-item' + (suppressed ? ' temp-suppressed' : '');
              item.dataset.renderIndex = String(idx);

              const proposed = getProposedNameForIndex(idx, "wav");
              const modeLabel = (gapMode.value === 'synth') ? ' (synthesized)' : ' (silent)';

              const nameBits = document.createElement('span');
              nameBits.className = 'placeholder-label';
              nameBits.textContent = '(placeholder)';

              if (suppressed && slot.file) {
                const badge = document.createElement('span');
                badge.className = 'temp-badge';
                badge.textContent = 'temp';
                nameBits.appendChild(badge);

                const absPI = gRenderMinPI + idx;
                nameBits.appendChild(buildTempMetaBadge(slot.file.name, absPI));
              }

              const proposedSpan = document.createElement('span');
              proposedSpan.className = 'proposed';
              proposedSpan.textContent = `→ ${proposed}${modeLabel}`;

              const ctrl = document.createElement('div');
              ctrl.className = 'controls';

              if (gapMode.value === 'synth') {
                const pbtn = document.createElement('button');
                pbtn.className = 'preview-btn';
                pbtn.type = 'button';
                pbtn.textContent = '▶︎';
                pbtn.title = 'Preview synthesized placeholder';
                pbtn.addEventListener('click', (e) => {
                  if (isMobile) selectSortedRow('placeholder', suppressed ? slot.file : null, idx); // CHANGED
                  previewPlaceholderAtIndex(full, idx, e.currentTarget);
                });
                ctrl.appendChild(pbtn);
              } else {
                const spacer = document.createElement('button');
                spacer.className = 'preview-btn';
                spacer.type = 'button';
                spacer.textContent = '▶︎';
                spacer.style.visibility = 'hidden';
                spacer.tabIndex = -1;
                spacer.setAttribute('aria-hidden', 'true');
                ctrl.appendChild(spacer);
              }

              item.appendChild(nameBits);
              item.appendChild(proposedSpan);
              item.appendChild(ctrl);

              // Mobile tap -> select this placeholder row
              item.addEventListener('click', () => {
                if (isMobile) {
                  const ref = suppressed && slot.file ? slot.file : null; // suppressed placeholders have a real file behind them
                  selectSortedRow('placeholder', ref, idx);
                  updateDeleteBtnState();
                  if (typeof updateTempButtonsState === 'function') updateTempButtonsState();
                }
              });

              // Desktop: context menu to restore if this was a temp-suppressed real
              if (!isMobile && suppressed && slot.file) {
                const originalIndex = files.findIndex(f => f && slot.file && f === slot.file);
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  stopPreviewIfPlaying();
                  showContextMenu(e.clientX, e.clientY, originalIndex >= 0 ? originalIndex : -1, {
                    isPlaceholder: false,
                    fileRef: slot.file,
                    isTempSuppressed: true
                  });
                });
              } else if (!isMobile) {
                item.addEventListener('contextmenu', (e) => { e.preventDefault(); });
              }

              fileList.appendChild(item);
            }
          });

          // If Range Expander is OFF, append any unmatched files after the mapped region
          if (!rangeExpanderCheckbox.checked && unmatched.length){
            const startIdx=full.length;
            unmatched.forEach((file,j)=>{
              const isSuppressed = gTempSuppressed.has(file);
              const item=document.createElement('div'); 
              item.className='file-item real' + (isSuppressed ? ' temp-suppressed' : ''); 
              item.draggable=true; 
              item.dataset.index=files.findIndex(f=>f===file);
              item.dataset.renderIndex = String(startIdx + j);

              const ext=file.name.split('.').pop(); 
              const proposed=getProposedNameForIndex(startIdx + j,ext);

              const nameSpan=document.createElement('span'); 
              nameSpan.textContent=file.name;

              if (isSuppressed) {
                const badge = document.createElement('span');
                badge.className = 'temp-badge';
                badge.textContent = 'temp';
                nameSpan.appendChild(badge);

                const absPI = gRenderMinPI + (startIdx + j);
                nameSpan.appendChild(buildTempMetaBadge(file.name, absPI));
              }

              const proposedSpan=document.createElement('span'); 
              proposedSpan.className='proposed'; 
              proposedSpan.textContent = isSuppressed
                ? `→ ${proposed} (placeholder)`
                : `→ ${proposed}`;

              const ctrl=document.createElement('div'); 
              ctrl.className='controls';

              const btn=document.createElement('button'); 
              btn.className='preview-btn'; 
              btn.type='button'; 
              btn.textContent='▶︎';
              btn.addEventListener('click',(e)=>{
                if (isMobile) selectSortedRow(isSuppressed ? 'placeholder' : 'real', isSuppressed ? file : file, startIdx + j); // CHANGED
                if (isSuppressed) {
                  stopCurrentPreview();
                } else {
                  previewFile(file,e.currentTarget);
                }
              });
              ctrl.appendChild(btn); 

              item.appendChild(nameSpan); 
              item.appendChild(proposedSpan); 
              item.appendChild(ctrl);
              addDragHandlers(item); 
              fileList.appendChild(item);

              // Mobile tap -> select unmatched row (real or placeholder)
              item.addEventListener('click', () => {
                // CHANGED: if suppressed, select as placeholder WITH fileRef
                if (isMobile) selectSortedRow(isSuppressed ? 'placeholder' : 'real', file, startIdx + j);
              });

              // Desktop: context menu with temp toggle + delete
              if (!isMobile) {
                item.addEventListener('contextmenu', (e) => {
                  e.preventDefault();
                  stopPreviewIfPlaying();
                  const idxInFiles = files.findIndex(f=>f===file);
                  showContextMenu(e.clientX, e.clientY, idxInFiles, {
                    isPlaceholder: false,
                    fileRef: file,
                    isTempSuppressed: isSuppressed
                  });
                });
              }
            });
          }

          updateDragInteractivity();
          updateTempButtonsState(); 
        }

        function addDragHandlers(el){
          el.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (
              e.target.closest('.preview-btn') ||
              e.target.closest('button') ||
              e.target.closest('input') ||
              e.target.closest('a')
            ) return;

            if (gPrevSource) {
              stopCurrentPreview();
              el.setAttribute('draggable', 'true');
              fileList.classList.remove('drag-disabled');
              updateDragInteractivity();
            }
          }, true);

          el.addEventListener('dragstart',(e)=>{
            if (!el.classList.contains('real')){ e.preventDefault(); return; }
            if (fileList.classList.contains('drag-disabled')) { e.preventDefault(); return; }
            e.dataTransfer.setData('text/plain', el.dataset.index);
            el.classList.add('dragging');
            if (gPrevSource) stopCurrentPreview();
          });

          el.addEventListener('dragend',()=>{
            el.classList.remove('dragging');
            const newOrder = Array.from(fileList.children)
              .filter(c=>c.dataset.index!==undefined && c.dataset.index!==null)
              .map(c=>files[Number(c.dataset.index)]);
            if (newOrder.length) files=newOrder;
            safeRenderList();
          });

          el.addEventListener('dragover',(e)=>{
            if (!document.querySelector('.dragging')) return;
            e.preventDefault();
            const dragging=document.querySelector('.dragging');
            const rect=el.getBoundingClientRect();
            const offset=e.clientY-rect.top;
            const parent=el.parentNode;
            if (offset > rect.height/2) parent.insertBefore(dragging, el.nextSibling);
            else parent.insertBefore(dragging, el);
          });
        }

        fileList.addEventListener('dragover',(e)=>{
          const scrollZone=40, scrollSpeed=4;
          const rect=fileList.getBoundingClientRect();
          if (e.clientY<rect.top+scrollZone) fileList.scrollTop-=scrollSpeed;
          else if (e.clientY>rect.bottom-scrollZone) fileList.scrollTop+=scrollSpeed;
        });

        fileList.addEventListener('dragstart', () => { if (gPrevSource) stopCurrentPreview(); });

        function updateDragInteractivity() {
          const realRows = fileList.querySelectorAll('.file-item.real');
          const manualMode = !autoSortCheckbox.checked && !rangeExpanderCheckbox.checked;

          const enableDesktopDrag = manualMode && !gIsPlaying && !isMobile;
          realRows.forEach(row => row.setAttribute('draggable', enableDesktopDrag ? 'true' : 'false'));
          fileList.classList.toggle('drag-disabled', !enableDesktopDrag);

          gapOptions.style.display = manualMode ? 'none' : 'block';

          if (isMobile) {
            if (touchReorderControls) touchReorderControls.style.display = 'flex';
            dragMessage.innerHTML = "<strong>To reorder the notes, select a note and then click Move Up or Move Down:</strong>";
            dragMessage.style.display = manualMode ? 'block' : 'none';
          } else {
            dragMessage.innerHTML = '<strong>Drag the notes into the scale note order you want.&nbsp;&nbsp;Right-click to insert/delete silent placeholders:</strong>';
            dragMessage.style.display = manualMode ? 'block' : 'none';
            if (touchReorderControls) touchReorderControls.style.display = 'none';
          }

          rangeExpanderRow.style.display = autoSortCheckbox.checked ? 'block' : 'none';
          if (!autoSortCheckbox.checked) {
            rangeExpanderCheckbox.checked = false;
            rangeControls.style.display = 'none';
          } else {
            rangeControls.style.display = rangeExpanderCheckbox.checked ? 'block' : 'none';
          }

          updateMobileReorderUI();

          updateTempButtonsState(); 
        }

        // ===================== Export (ZIP) =====================
        exportZipBtn.addEventListener('click', async ()=>{
          if (gPrevSource) stopCurrentPreview();

          exportZipBtn.disabled = true;
          setExportStatus('Starting export…');

          let plannedCount = 0;
          (function computePlannedCountPreflight(){
            if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked) {
              plannedCount = Array.from(fileList.children).filter(el => el.classList.contains('real')).length;
            } else {
              const plan = buildContinuousRange();
              if (plan && plan.full && plan.full.length) {
                plannedCount = plan.full.length;
                if (!rangeExpanderCheckbox.checked && plan.unmatched && plan.unmatched.length) {
                  plannedCount += plan.unmatched.length;
                }
              } else {
                plannedCount = files.length;
              }
            }
          })();

          if (plannedCount === 0) {
            DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme:"modal_flat", top:200 });
            exportZipBtn.disabled = false;
            clearExportStatus();
            return;
          }

          async function saveZipFile(fname){
            if (fileList.children.length == 0 || !files.length){
              DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme:"modal_flat", top:200 });
              exportZipBtn.disabled = false;
              clearExportStatus();
              return;
            }

            const zip = new JSZip();

            let volumeScale = parseFloat(volumeScaleInput.value);
            let fadeTimeMs  = parseInt(fadeTimeInput.value, 10);
            if (isNaN(volumeScale)) volumeScale = 1.0;
            if (isNaN(fadeTimeMs))  fadeTimeMs  = 100;
            if (volumeScale < 0) volumeScale = 0;
            if (fadeTimeMs  < 0) fadeTimeMs  = 0;

            const meta = {
              volumeScale,
              fadeTimeMs,
              trimLeadingSilence: !!trimSilenceCheckbox.checked,
              silenceThresholdDb: Number(silenceDbInput.value),
              forceMonoWav: !!forceMonoWavCheckbox.checked,
              rangeExpander: !!rangeExpanderCheckbox.checked,
              desiredRange: rangeExpanderCheckbox.checked ? {
                lowOct: parseInt(lowOct.value,10),
                lowNote: parseInt(lowNote.value,10),
                highOct: parseInt(highOct.value,10),
                highNote: parseInt(highNote.value,10)
              } : null
            };
            zip.file("abctools.json", JSON.stringify(meta,null,2));

            let processedCount = 0;
            let plannedCount   = 0;

            function updateStep(label){
              processedCount++;
              setExportStatus(`Processing ${processedCount} of ${plannedCount}… ${label || ''}`.trim());
            }

            (function computePlannedCount(){
              if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked) {
                plannedCount = Array.from(fileList.children).filter(el => el.classList.contains('real')).length;
              } else {
                const plan = (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) ? buildContinuousRange() : null;
                if (plan && plan.full && plan.full.length) {
                  plannedCount = plan.full.length;
                  if (!rangeExpanderCheckbox.checked && plan.unmatched && plan.unmatched.length) {
                    plannedCount += plan.unmatched.length;
                  }
                } else {
                  plannedCount = files.length;
                }
              }
            })();
            await tick();

            let built = null, full = null;
            if (autoSortCheckbox.checked || rangeExpanderCheckbox.checked) {
              built = buildContinuousRange();
              full  = built.full;
            }

            if (!autoSortCheckbox.checked && !rangeExpanderCheckbox.checked){
              const reordered = Array.from(fileList.children)
                .filter(el => el.classList.contains('real'))
                .map(el => files[Number(el.dataset.index)]);

              for (let i = 0; i < reordered.length; i++){
                const file = reordered[i];
                const ext  = file.name.split('.').pop();
                const newName = getProposedNameForIndex(i, ext);
                const outBlob = await fileToProcessedBlob(file);
                zip.file(newName, outBlob);
                updateStep(newName);
                await tick();
              }

            } else {
              const unmatched = built ? built.unmatched : [];

              if (!full || !full.length){
                for (let i = 0; i < files.length; i++){
                  const file = files[i];
                  const ext  = file.name.split('.').pop();
                  const newName = getProposedNameForIndex(i, ext);
                  const outBlob = await fileToProcessedBlob(file);
                  zip.file(newName, outBlob);
                  updateStep(newName);
                  await tick();
                }
              } else {
                // ---- Modified synthesis prep: ONLY real, unsuppressed samples are sources ----
                const haveAtIndex = new Map();
                full.forEach((slot, i) => {
                  if (slot.file && !(gTempSuppressed && gTempSuppressed.has(slot.file))) {
                    haveAtIndex.set(i, slot.file);
                  }
                });

                const decodedAtIndex = new Map();
                await Promise.all(
                  Array.from(haveAtIndex.entries()).map(async ([i, file]) => {
                    try {
                      decodedAtIndex.set(i, await decodeFileToAudioBuffer(file));
                    } catch (e) {
                      console.warn("Decode failed:", file && file.name, e);
                    }
                  })
                );

                function findSourceIndex(targetIdx){
                  for (let d = 1; d < full.length; d++) {
                    const lower  = targetIdx - d;
                    const higher = targetIdx + d;
                    if (lower  >= 0           && decodedAtIndex.has(lower))  return lower;
                    if (higher <  full.length && decodedAtIndex.has(higher)) return higher;
                  }
                  return -1;
                }

                for (let i = 0; i < full.length; i++){
                  const slot = full[i];

                  if (slot.file && !(gTempSuppressed && gTempSuppressed.has(slot.file))) {
                    // real, unsuppressed file → write it (with any processing)
                    const ext      = slot.ext;
                    const proposed = getProposedNameForIndex(i, ext);
                    const outBlob  = await fileToProcessedBlob(slot.file);
                    zip.file(proposed, outBlob);
                    updateStep(proposed);
                    await tick();

                  } else if (slot.file && gTempSuppressed && gTempSuppressed.has(slot.file)) {
                    // this slot is temporarily a placeholder
                    const proposed = getProposedNameForIndex(i, "wav");
                    if (gapMode.value === 'silent'){
                      zip.file(proposed, generateSilentWav(1));
                      updateStep(proposed);
                      await tick();
                    } else {
                      const srcIdx = findSourceIndex(i);
                      if (srcIdx >= 0){
                        try{
                          const srcBuf    = decodedAtIndex.get(srcIdx);
                          const semitones = i - srcIdx;
                          const shifted   = await pitchShiftBuffer(srcBuf, semitones);
                          const outBlob   = await bufferToFinalBlob(shifted);
                          zip.file(proposed, outBlob);
                        } catch(e){
                          console.warn("Synthesis failed at index", i, e);
                          zip.file(proposed, generateSilentWav(1));
                        }
                      } else {
                        zip.file(proposed, generateSilentWav(1));
                      }
                      updateStep(proposed);
                      await tick();
                    }

                  } else {
                    // slot has no file (true gap/placeholder from auto-range)
                    const proposed = getProposedNameForIndex(i, "wav");
                    if (gapMode.value === 'silent'){
                      zip.file(proposed, generateSilentWav(1));
                      updateStep(proposed);
                      await tick();
                    } else {
                      const srcIdx = findSourceIndex(i);
                      if (srcIdx >= 0){
                        try{
                          const srcBuf    = decodedAtIndex.get(srcIdx);
                          const semitones = i - srcIdx;
                          const shifted   = await pitchShiftBuffer(srcBuf, semitones);
                          const outBlob   = await bufferToFinalBlob(shifted);
                          zip.file(proposed, outBlob);
                        } catch(e){
                          console.warn("Synthesis failed at index", i, e);
                          zip.file(proposed, generateSilentWav(1));
                        }
                      } else {
                        zip.file(proposed, generateSilentWav(1));
                      }
                      updateStep(proposed);
                      await tick();
                    }
                  }
                }

                if (!rangeExpanderCheckbox.checked && unmatched.length){
                  const startIdx = full.length;
                  for (let j = 0; j < unmatched.length; j++){
                    const file = unmatched[j];
                    const ext  = file.name.split('.').pop();
                    const proposed = getProposedNameForIndex(startIdx + j, ext);
                    const outBlob = await fileToProcessedBlob(file);
                    zip.file(proposed, outBlob);
                    updateStep(proposed);
                    await tick();
                  }
                }
              }
            }

            setExportStatus('Zipping files… 0%');
            const blob = await zip.generateAsync(
              { type: "blob" },
              (meta) => {
                const pct = Math.max(0, Math.min(100, Math.round(meta.percent || 0)));
                setExportStatus(`Zipping files… ${pct}%`);
              }
            );

            setExportStatus('Export complete. Saving…');
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fname;
            a.click();
            setTimeout(()=>{ window.URL.revokeObjectURL(a.href); }, 1000);

            clearExportStatus();
            exportZipBtn.disabled = false;
          };

          const thePrompt = "Please enter a filename for your custom instrument file:";
          DayPilot.Modal.prompt(thePrompt, gFileSaveName, { theme:"modal_flat", top:200, autoFocus:true })
          .then(function(args){
            let fname = args.result;
            if (fname == null || fname.length == 0){
              exportZipBtn.disabled = false;
              clearExportStatus();
              return;
            }
            if (!fname.endsWith(".zip")){
              fname = fname.replace(/\..+$/,'');
              fname = fname + ".zip";
            }
            gFileSaveName = fname;
            sortFilesIfNeeded();
            return saveZipFile(fname);
          })
          .catch((e)=>{
            console.error(e);
            DayPilot.Modal.alert('<p style="text-align:center">Export failed.</p>', { theme:"modal_flat", top:200 });
          })
          .finally(()=>{ exportZipBtn.disabled = false; });
        });


        // ===================== Import Existing Instrument (.zip) =====================
        importZipBtn.addEventListener('click', () => {
          importZipInput.value = "";
          importZipInput.click();
        });

        function isIgnorableZipEntry(path) {
          if (path.startsWith('__MACOSX/')) return true;
          const base = path.split('/').pop();
          if (!base) return true;
          if (base.startsWith('._')) return true;
          if (base === '.DS_Store' || base === 'Thumbs.db') return true;
          return false;
        }
        function sanitizeBaseName(path) {
          let base = path.split('/').pop() || path;
          if (base.startsWith('./')) base = base.slice(2);
          return base;
        }

        importZipInput.addEventListener('change', async (e) => {
          const zipFile = e.target.files && e.target.files[0];
          if (!zipFile) return;

          try {
            if (gPrevSource) stopCurrentPreview();

            const zip = await JSZip.loadAsync(zipFile);

            let importedVolumeScale = null;
            let importedFadeTimeMs = null;
            const metaEntry = Object.keys(zip.files).find(n => n.toLowerCase() === "abctools.json");
            if (metaEntry) {
              try {
                const metaText = await zip.file(metaEntry).async("string");
                const meta = JSON.parse(metaText);
                if (meta && typeof meta.volumeScale === "number" && meta.volumeScale >= 0) importedVolumeScale = meta.volumeScale;
                if (meta && typeof meta.fadeTimeMs === "number" && meta.fadeTimeMs >= 0) importedFadeTimeMs = meta.fadeTimeMs;
              } catch {}
            }

            const imported = [];
            const seen = new Set();

            const entries = Object.keys(zip.files)
              .filter(n => !zip.files[n].dir)
              .filter(n => /\.(wav|mp3)$/i.test(n));

            for (const path of entries) {
              if (isIgnorableZipEntry(path)) continue;

              const baseName = sanitizeBaseName(path);
              const key = baseName.toLowerCase();
              if (seen.has(key)) continue;
              seen.add(key);

              const blob = await zip.file(path).async("blob");
              const ext = baseName.split('.').pop().toLowerCase();
              const mime = (ext === 'wav') ? 'audio/wav' : (ext === 'mp3' ? 'audio/mpeg' : 'application/octet-stream');

              const f = new File([blob], baseName, { type: mime });
              imported.push(f);
            }

            if (!imported.length) {
              DayPilot.Modal.alert('<p style="text-align:center">No audio files found in .zip</p>', { theme:"modal_flat", top:200 });
              return;
            }

            trimSilenceCheckbox.checked = false;
            thresholdControls.style.display = 'none';
            forceMonoWavCheckbox.checked = false;
            rangeExpanderCheckbox.checked = false;

            if (importedVolumeScale !== null) {
              volumeScaleInput.value = String(importedVolumeScale);
              if (gPrevGain) gPrevGain.gain.value = importedVolumeScale;
            }
            if (importedFadeTimeMs !== null) {
              fadeTimeInput.value = String(importedFadeTimeMs);
            }

            originalFiles = [...imported];
            files = [...imported];

            gHasHashedNames = hasHashedFilenames(files);
            if (gHasHashedNames){
              applyHashedModeUIState();
              DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.</p>', { theme:"modal_flat", top:200 });
            } else {
              clearHashedModeUIState();
              sortFilesIfNeeded();
              if ((autoSortCheckbox.checked || rangeExpanderCheckbox.checked) && !gHasHashedNames) {
                detectAndApplyLowestPitch();
              }
            }

            if (autoSortCheckbox.checked) {
              const built = buildContinuousRange();
              if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
                const loOct = Math.floor(built.effMin / 12), loNote = built.effMin % 12;
                const hiOct = Math.floor(built.effMax / 12), hiNote = built.effMax % 12;
                lowOct.value = String(loOct);  lowNote.value = String(loNote);
                highOct.value = String(hiOct); highNote.value = String(hiNote);
              }
            }

            rangeControls.style.display = 'none';

            safeRenderList();
            updateDragInteractivity();
            clearSelection();

          } catch (err) {
            console.error("Import zip failed:", err);
            DayPilot.Modal.alert('<p style="text-align:center">Failed to import .zip</p>', { theme:"modal_flat", top:200 });
          }
        });


        // ===== UI wiring =====

        fileInput.addEventListener('change',(e)=>{
          originalFiles=Array.from(e.target.files);
          files=[...originalFiles];

          gHasHashedNames=hasHashedFilenames(files);
          if (gHasHashedNames){
            applyHashedModeUIState();
            DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.</p>', { theme:"modal_flat", top:200 });
          } else { clearHashedModeUIState(); }

          sortFilesIfNeeded();

          if ((autoSortCheckbox.checked || rangeExpanderCheckbox.checked) && !gHasHashedNames) {
            detectAndApplyLowestPitch();
          }

          if (autoSortCheckbox.checked) {
            const built = buildContinuousRange();
            if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
              const loOct = Math.floor(built.effMin/12), loNote = built.effMin%12;
              const hiOct = Math.floor(built.effMax/12), hiNote = built.effMax%12;
              lowOct.value = String(loOct); lowNote.value = String(loNote);
              highOct.value = String(hiOct); highNote.value = String(hiNote);
            }
          }

          safeRenderList();
          updateDragInteractivity();
          clearSelection();
        });

        function handleStartingControlsChange() {
          if (gPrevSource) stopCurrentPreview();
          safeRenderList();
          updateDragInteractivity();
        }

        startNumber.addEventListener('change', handleStartingControlsChange);
        startNote.addEventListener('change', handleStartingControlsChange);

        autoSortCheckbox.addEventListener('change', ()=>{
          stopPreviewIfPlaying();

          if (autoSortCheckbox.checked) {
            files = files.filter(f => !f._isPlaceholder);
            rangeExpanderCheckbox.checked = rangeExpanderCheckbox.checked;
          } else {
            rangeExpanderCheckbox.checked = false;
            rangeControls.style.display = 'none';
          }

          sortFilesIfNeeded();
          if (autoSortCheckbox.checked && !gHasHashedNames) detectAndApplyLowestPitch();

          if (autoSortCheckbox.checked) {
            const built = buildContinuousRange();
            if (built && isFinite(built.effMin) && isFinite(built.effMax)) {
              const loOct = Math.floor(built.effMin/12), loNote = built.effMin%12;
              const hiOct = Math.floor(built.effMax/12), hiNote = built.effMax%12;
              lowOct.value = String(loOct); lowNote.value = String(loNote);
              highOct.value = String(hiOct); highNote.value = String(hiNote);
            }
          }

          safeRenderList();
          updateDragInteractivity();
          clearSelection();
        });

        gapMode.addEventListener('change', () => {
          stopPreviewIfPlaying();
          safeRenderList();
        });

        // Trim UI
        trimSilenceCheckbox.checked=false;
        thresholdControls.style.display='none';

        trimSilenceCheckbox.addEventListener('change', ()=>{
          stopPreviewIfPlaying();
          thresholdControls.style.display = trimSilenceCheckbox.checked ? 'block' : 'none';
          safeRenderList();
          updateDragInteractivity();
        });

        forceMonoWavCheckbox.addEventListener('change', () => {
          stopPreviewIfPlaying();
          safeRenderList();
          updateDragInteractivity();
        });

        applyThresholdBtn.addEventListener('click', () => {
          safeRenderList();
          const status = document.getElementById('applyStatus');
          status.textContent = 'Applied';
          status.classList.add('show');
          applyThresholdBtn.disabled = true;
          setTimeout(() => {
            status.classList.remove('show');
            applyThresholdBtn.disabled = false;
          }, 1200);
        });

        silenceDbInput.addEventListener('input', () => {
          const status = document.getElementById('applyStatus');
          status.classList.remove('show');
        });

        function stopPreviewIfPlaying(){ if (gPrevSource) stopCurrentPreview(); }

        function updateRangeExpanderUI(){
          stopPreviewIfPlaying(); 
          const on = rangeExpanderCheckbox.checked;
          if (!autoSortCheckbox.checked) rangeExpanderCheckbox.checked = false;
          rangeControls.style.display = (on && autoSortCheckbox.checked) ? 'block' : 'none';

          sortFilesIfNeeded();
          safeRenderList();
          updateDragInteractivity();
          clearSelection();
        }

        function scrollSelectedIntoView() {
          requestAnimationFrame(() => {
            const sel = fileList.querySelector(`.file-item.selected`);
            if (sel) sel.scrollIntoView({ block: 'nearest', inline: 'nearest' });
          });
        }

        rangeExpanderCheckbox.addEventListener('change', updateRangeExpanderUI);
        const handleRangeValueChange = () => { stopPreviewIfPlaying(); safeRenderList();  updateDragInteractivity(); clearSelection();};
        lowOct.addEventListener('change', handleRangeValueChange);
        lowNote.addEventListener('change', handleRangeValueChange);
        highOct.addEventListener('change', handleRangeValueChange);
        highNote.addEventListener('change', handleRangeValueChange);

        // Move Up/Down buttons (mobile manual mode)
        if (moveUpBtn) moveUpBtn.addEventListener('click', () => {
          stopPreviewIfPlaying();

          // If nothing is selected, but a preview button exists, select that row
          if (selectedIndex < 0 && gPrevBtn) {
            selectRowForButton(gPrevBtn);
          }

          if (selectedIndex <= 0) return;

          const i = selectedIndex;
          [files[i - 1], files[i]] = [files[i], files[i - 1]];
          selectedIndex = i - 1;

          stopCurrentPreview();
          renderList();

          dragMessage.style.display = 'block';
          dragMessage.innerHTML = '<strong>To reorder the notes, select a note and then click Move Up or Move Down:</strong>';

          scrollSelectedIntoView();
        });

        if (moveDownBtn) moveDownBtn.addEventListener('click', () => {
          stopPreviewIfPlaying();

          // If nothing is selected, but a preview button exists, select that row
          if (selectedIndex < 0 && gPrevBtn) {
            selectRowForButton(gPrevBtn);
          }

          if (selectedIndex < 0 || selectedIndex >= files.length - 1) return;

          const i = selectedIndex;
          [files[i], files[i + 1]] = [files[i + 1], files[i]];
          selectedIndex = i + 1;

          stopCurrentPreview();
          renderList();

          dragMessage.style.display = 'block';
          dragMessage.innerHTML = '<strong>To reorder the notes, select a note and then click Move Up or Move Down:</strong>';

          scrollSelectedIntoView();
        });

        // Helper: are we in a mode that supports temp placeholders?
        function _isTempSupportedMode() {
          return (typeof isSortedMode === 'function') ? isSortedMode()
            : (autoSortCheckbox.checked || rangeExpanderCheckbox.checked);
        }

        if (makePlaceholderBtn) {
          makePlaceholderBtn.addEventListener('click', () => {
            // Only in sorted/range mode
            if (!_isTempSupportedMode()) return;
            if (!selectedRef || selectedRef.kind !== 'real' || !selectedRef.fileRef) return;

            const fileRef   = selectedRef.fileRef;
            const renderIdx = selectedRef.renderIdx;

            // Only make placeholder if it's not already suppressed
            if (gTempSuppressed.has(fileRef)) return;

            stopPreviewIfPlaying();

            // Suppress this file (becomes TEMP placeholder)
            toggleTemporaryPlaceholderForFile(fileRef);

            // Re-render, then reselect same row as a placeholder
            safeRenderList();
            updateDragInteractivity();
            selectSortedRow('placeholder', fileRef, renderIdx);

            // Make sure mobile buttons reflect the new state
            updateTempButtonsState();
          });
        }

        if (restoreSampleBtn) {
          restoreSampleBtn.addEventListener('click', () => {
            // Only in sorted/range mode
            if (!_isTempSupportedMode()) return;
            if (!selectedRef || !selectedRef.fileRef) return;

            const fileRef   = selectedRef.fileRef;
            const renderIdx = selectedRef.renderIdx;

            // Can restore if: currently selected is a placeholder w/ fileRef AND suppressed,
            // or a real row that is suppressed.
            const isValidRestore =
              (selectedRef.kind === 'placeholder' && gTempSuppressed.has(fileRef)) ||
              (selectedRef.kind === 'real'        && gTempSuppressed.has(fileRef));

            if (!isValidRestore) return;

            stopPreviewIfPlaying();

            // Unsuppress this file (back to real)
            // (toggleTemporaryPlaceholderForFile will remove from the set if present)
            toggleTemporaryPlaceholderForFile(fileRef);

            // Re-render, then reselect same row as a real sample
            safeRenderList();
            updateDragInteractivity();
            selectSortedRow('real', fileRef, renderIdx);

            // Make sure mobile buttons reflect the new state
            updateTempButtonsState();
          });
        }

        // Instructions modal
        instructionsBtn.addEventListener('click', async () => {

          var html;

          if (isMobile){
            html = `
            <div class="instr-modal">
             <h2>Instructions</h2>
              <p>This tool is used to create an ABC Transcription Tools custom instrument from a directory of per-note instrument audio sample files.</p>
              <p>The files should be in .wav or .mp3 format. The samples must all be in the same directory.</p>
              <p><strong>1)</strong> Tap <strong>Choose Files</strong> (<strong>Browse...</strong> on Firefox) to import your audio sample files.</p>
              <p>The tool will attempt to determine the note name and octave of each of the files.</p>
              <p>Both note name (e.g., C4.wav) or patchname-(MIDI note number) filenames (e.g., Piano-60.wav), which are common in .sf2-extracted .wav files, are supported.</p>
              <p>Note name detection is done first, and if it fails, MIDI-number pitch name detection is attempted.</p>
              <p>If both note name pitch detections fail, the files will be loaded into the list with no pitch mapping.</p>
              <p>If you want to specifically disable the .sf2 MIDI-number pitch name detection, check <strong>Disable .sf2-style MIDI-number pitch name detection</strong>.</p>
              <p>You can also import an existing custom instrument by tapping <strong>Import Custom Instrument (.zip)</strong>.</p>
              <p>If you re-import a previously exported custom instrument .zip, your saved volume scale and fade settings will also be restored automatically.</p>
              <p>The custom instrument note output filename for each audio sample is displayed to the right of each note.</p>
              <p><strong>2)</strong> Select the default volume scale and fade time for the instrument.</p>
              <p>These values will be applied to the instrument when used in the <strong>ABC Transcription Tools</strong>.</p>
              <p><strong>3)</strong> Choose the starting scale note for the instrument notes.</p>
              <p><strong>4)</strong> Choose the starting octave number for the instrument notes.</p>
              <p>For reference, in ABC notation, middle C on the piano (written as C) corresponds to C4, while the lowest string on a violin (written as G,) corresponds to G3.</p>
              <p><strong>5)</strong> If your sample filenames contain note names (e.g., C4.wav) or follow the patchname-(MIDI note number) format (e.g., Piano-60.wav), which is common in .sf2-extracted .wav files, check <strong>Automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> to align the sample file list with the note names (checked by default).</p>
              <p>If note names cannot be automatically parsed, sorting and range detection will be disabled. You can still manually reorder your samples.</p>
              <p><strong>6)</strong> If you have any original samples that don't sound good and want to instead create them by pitch-shifting from adjacent samples, you can remove them from the list by:</p>
              <p>Tap the item to select it and then tap the <strong>Delete Selected Item from List</strong> button.</p>
              <p><strong>7)</strong> When automatically sorting by scale order, if there are scale gaps found, select whether to synthesize (pitch-shift) the missing notes from nearby samples or replace them with silent placeholder files.</p>
              <p>In this mode, you may also temporarily replace a real sample with a placeholder without permanently removing it from the sample list.</p>
              <p>Select a mapped sample and tap <strong>Make Temporary Placeholder</strong> to turn it into a temporary placeholder (it will show a yellow <strong>"temp"</strong> badge and its original filename). When a temporary placeholder row is selected, tap <strong>Restore Original Sample</strong> to restore it.</p>
              <p>You can also delete a temporary placeholder (which removes its underlying sample) by selecting it and tapping <strong>Delete Selected Item from List</strong>.</p>
              <p>The buttons are context-aware and will enable/disable automatically based on the currently selected item (enabled on a real, mapped sample to replace; enabled on a temporary placeholder to restore the original sample).</p>
              <p>• If <strong>Synthesize</strong> is selected for gaps, the temporarily missing note will be generated from the nearest real, non-placeholder sample.</p>
              <p>• If <strong>Silent</strong> is selected for gaps, the temporarily missing note will preview/export as silence.</p>
              <p><strong>8)</strong> <em>Optional:</em> Turn on the <strong>Range Expander</strong> (available only when <strong>Automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> is enabled) to set the lowest and highest desired note and octave.</p>
              <p>The ends of the list will match your requested notes exactly, while the lowest actual input sample retains the label determined by the <strong>Starting note/octave</strong> settings.</p>
              <p><strong>9)</strong> If not automatically sorting files by scale order, you can manually reorder the scale note order.</p>
              <p>This can be useful for loops/stems or non-pitched percussion instruments where you want sounds to play on specific scale notes.</p>
              <p>Select a note and then tap the <strong>Move Up</strong> and <strong>Move Down</strong> buttons to reorder the list into the scale note order you want.</p>
              <p><strong>Adding and deleting silent placeholders:</strong></p>
              <p>You may also add additional silent placeholders to allow you to place the notes exactly at the scale positions you want.</p>
              <p>To insert a silent placeholder after any item in the list, select the item and then tap the <strong>Insert Silent Placeholder</strong> button.</p>
              <p>To delete a silent placeholder, select the silent placeholder and then tap the <strong>Delete Selected Item from List</strong> button.</p>
              <p><strong>10)</strong> <em>Optional:</em> Enable <strong>Trim leading silence</strong> and set a <strong>Silence threshold (dB)</strong> to remove silence at the start of each file.</p>
              <p>Smaller dB values are more sensitive (e.g., -40 to -50 dB is typical).</p>
              <p>Tap <strong>Apply</strong> to update silence trimming for all samples.</p>
              <p><strong>11)</strong> <em>Optional:</em> Enable <strong>Encode all exported files as mono .wav</strong> to force every exported file to mono .wav format, regardless of input type.</p>
              <p>If silence trimming or mono conversion is enabled, the exported filenames always use .wav extension.</p>
              <p>This applies to both normal exports and silence-trimmed files and may reduce the custom instrument size if the original samples were stereo .wav files.</p>
              <p><strong>12)</strong> Tap the ▶︎ buttons to audition the notes with the current volume scale, silence trimming, and stereo-to-mono conversion settings.</p>
              <p><strong>13)</strong> Tap <strong>Export Custom Instrument</strong> to export the final custom instrument.</p>
              <p>The .zip file is saved to your browser’s default <strong>Downloads</strong> folder.</p>
              <hr>
              <h4>Additional Resources</h4>
              <p style="text-align:center;margin-top:12px;">User Guide Information on Custom Instrument Creation</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/userguide.html#creating_custom_midi_instruments" target="_blank">ABC Transcription Tools User Guide: Custom Instruments</a></p>
              <p style="text-align:center;margin-top:12px;">UltraBox Utility for Extracting Samples from .sf2 Soundfonts</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/tools/UltraBox/UltraBox_Sample_Extractor.html" target="_blank">UltraBox Sample Extractor</a></p>
              <hr>
              <h4>Credits</h4>
              <p style="text-align:center;">This tool uses several open-source Javascript libraries, credits can be found here:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/credits.html" target="_blank">Credits</a></p>
              <hr>
              <h4>Tip Jars</h4>
              <p style="text-align:center;">This tool was created by <a href="https://michaeleskin.com" target="_blank">Michael Eskin</a>.</p>
              <p style="text-align:center;">If you find it useful, please consider making a contribution via my online tip jars:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/tipjars.html" target="_blank">Tip Jars</a></p>
            </div>
          `;
          }
          else{
            html = `
            <div class="instr-modal">
             <h2>Instructions</h2>
              <p>This tool is used to create an ABC Transcription Tools custom instrument from a directory of per-note instrument audio sample files.</p>
              <p>The files should be in .wav or .mp3 format. The samples must all be in the same directory.</p>
              <p><strong>1)</strong> Click <strong>Choose Files</strong> (<strong>Browse...</strong> on Firefox) to import your audio sample files.</p>
              <p>The tool will attempt to determine the note name and octave of each of the files.</p>
              <p>Both note name (e.g., C4.wav) or patchname-(MIDI note number) filenames (e.g., Piano-60.wav), which are common in .sf2-extracted .wav files, are supported.</p>
              <p>Note name detection is done first, and if it fails, MIDI-number pitch name detection is attempted.</p>
              <p>If both note name pitch detections fail, the files will be loaded into the list with no pitch mapping.</p>
              <p>If you want to specifically disable the .sf2 MIDI-number pitch name detection, check <strong>Disable .sf2-style MIDI-number pitch name detection</strong>.</p>
              <p>You can also import an existing custom instrument by clicking <strong>Import Custom Instrument (.zip)</strong>.</p>
              <p>If you re-import a previously exported custom instrument .zip, your saved volume scale and fade settings will also be restored automatically.</p>
              <p>The custom instrument note output filename for each audio sample is displayed to the right of each note.</p>
              <p><strong>2)</strong> Select the default volume scale and fade time for the instrument.</p>
              <p>These values will be applied to the instrument when used in the <strong>ABC Transcription Tools</strong>.</p>
              <p><strong>3)</strong> Choose the starting scale note for the instrument notes.</p>
              <p><strong>4)</strong> Choose the starting octave number for the instrument notes.</p>
              <p>For reference, in ABC notation, middle C on the piano (written as C) corresponds to C4, while the lowest string on a violin (written as G,) corresponds to G3.</p>
              <p><strong>5)</strong> If your sample filenames contain note names (e.g., C4.wav) or follow the patchname-(MIDI note number) format (e.g., Piano-60.wav), which is common in .sf2-extracted .wav files, check <strong>Automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> to align the sample file list with the note names (checked by default).</p>
              <p>If note names cannot be automatically parsed, sorting and range detection will be disabled. You can still manually reorder your samples.</p>
              <p><strong>6)</strong> If you have any original samples that don't sound good and want to instead create them by pitch-shifting from adjacent samples, you can remove them from the list by:</p>
              <p>Right-click the item and select <strong>Delete sample from list</strong> from the context menu.</p>
              <p><strong>7)</strong> When automatically sorting by scale order, if there are scale gaps found, select whether to synthesize (pitch-shift) the missing notes from nearby samples or replace them with silent placeholder files.</p>
              <p>In this mode, you may also temporarily replace a real sample with a placeholder without permanently removing it from the sample list.</p>
              <p>Right-click a mapped sample and choose <strong>Temporarily replace with placeholder</strong>. The sample will be visually marked with a yellow <strong>"temp"</strong> badge and also display the original filename it came from, and it will be treated as a placeholder when previewing or exporting.</p>
              <p>Right-click again and choose <strong>Restore original sample</strong> to restore it.</p>
              <p>To delete the underlying sample of a temporary placeholder from the list, right-click the placeholder and choose <strong>Delete sample from list</strong>.</p>
              <p>• If <strong>Synthesize</strong> is selected for gaps, the temporarily missing note will be generated from the nearest real, non-placeholder sample.</p>
              <p>• If <strong>Silent</strong> is selected for gaps, the temporarily missing note will preview/export as silence.</p>
              <p><strong>8)</strong> <em>Optional:</em> Turn on the <strong>Range Expander</strong> (available only when <strong>Automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> is enabled) to set the lowest and highest desired note and octave.</p>
              <p>The ends of the list will match your requested notes exactly, while the lowest actual input sample retains the label determined by the <strong>Starting note/octave</strong> settings.</p>
              <p><strong>9)</strong> If not automatically sorting files by scale order, you can manually reorder the scale note order.</p>
              <p>This can be useful for loops/stems or non-pitched percussion instruments where you want sounds to play on specific scale notes.</p>
              <p>Drag-and-drop the notes in the list into the scale note order you want.</p>
              <p><strong>Adding and deleting silent placeholders:</strong></p>
              <p>You may also add additional silent placeholders to allow you to place the notes exactly at the scale positions you want.</p>
              <p>To insert a silent placeholder after any item in the list, right-click the item and then select <strong>Insert silent placeholder after this note</strong> from the context menu.</p>
              <p>To delete a silent placeholder, right-click the silent placeholder and then select <strong>Delete silent placeholder</strong> from the context menu.</p>
              <p><strong>10)</strong> <em>Optional:</em> Enable <strong>Trim leading silence</strong> and set a <strong>Silence threshold (dB)</strong> to remove silence at the start of each file.</p>
              <p>Smaller dB values are more sensitive (e.g., -40 to -50 dB is typical).</p>
              <p>Click <strong>Apply</strong> to update silence trimming for all samples.</p>
              <p><strong>11)</strong> <em>Optional:</em> Enable <strong>Encode all exported files as mono .wav</strong> to force every exported file to mono .wav format, regardless of input type.</p>
              <p>If silence trimming or mono conversion is enabled, the exported filenames always use .wav extension.</p>
              <p>This applies to both normal exports and silence-trimmed files and may reduce the custom instrument size if the original samples were stereo .wav files.</p>
              <p><strong>12)</strong> Click the ▶︎ buttons to audition the notes with the current volume scale, silence trimming, and stereo-to-mono conversion settings.</p>
              <p><strong>13)</strong> Click <strong>Export Custom Instrument</strong> to export the final custom instrument.</p>
              <p>The .zip file is saved to your browser’s default <strong>Downloads</strong> folder.</p>
              <hr>
              <h4>Additional Resources</h4>
              <p style="text-align:center;margin-top:12px;">User Guide Information on Custom Instrument Creation</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/userguide.html#creating_custom_midi_instruments" target="_blank">ABC Transcription Tools User Guide: Custom Instruments</a></p>
              <p style="text-align:center;margin-top:12px;">UltraBox Utility for Extracting Samples from .sf2 Soundfonts</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/tools/UltraBox/UltraBox_Sample_Extractor.html" target="_blank">UltraBox Sample Extractor</a></p>
              <hr>
              <h4>Credits</h4>
              <p style="text-align:center;">This tool uses several open-source Javascript libraries, credits can be found here:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/credits.html" target="_blank">Credits</a></p>
              <hr>
              <h4>Tip Jars</h4>
              <p style="text-align:center;">This tool was created by <a href="https://michaeleskin.com" target="_blank">Michael Eskin</a>.</p>
              <p style="text-align:center;">If you find it useful, please consider making a contribution via my online tip jars:</p>
              <p style="text-align:center;margin-top:12px;"><a href="https://michaeleskin.com/abctools/tipjars.html" target="_blank">Tip Jars</a></p>
            </div>
          `;          }
          await DayPilot.Modal.alert(html, { theme: "modal_flat", top: 25, width: 780 });
        });

        // Range defaults
        lowOct.value = "3";  lowNote.value = "0";    // C3
        highOct.value = "6"; highNote.value = "0";   // C6

        updateDragInteractivity();
      }

      function guessMimeByExt(name){
        const ext = (name.split('.').pop()||'').toLowerCase();
        if (ext==='wav') return 'audio/wav';
        if (ext==='mp3') return 'audio/mpeg';
        return 'application/octet-stream';
      }

      function WaitForReady(fn){
        if (document.readyState!=='loading'){ fn(); return; }
        document.addEventListener('DOMContentLoaded', fn);
      }

      WaitForReady(DoStartup);

    </script>

  </body>

</html>
