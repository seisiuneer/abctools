<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>ABC Transcription Tools - Custom Instrument Builder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=1"></script>
    <style>
    body {
      background: #fafafa;
      color: #222;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 10px auto;
      padding: 0 20px;
      line-height: 1.5;
    }
    h1 {
      margin-top: 18px;
      font-size: 1.8em;
      margin-bottom: .5em;
      color: #000;
      text-align: center;
    }
    h4 {
      font-size: 1.2em;
      margin-bottom: 1em;
      color: #000;
    }
    p { font-size: 1em; }
    label {
      font-size: 1em;
      display: block;
      margin-top: 1.25em;
      font-weight: 600;
    }
    input[type="file"], select, input[type="number"] {
      margin-top: 0.25em;
      font-size: 1em;
      padding: 0.4em;
      width: 100%;
      box-sizing: border-box;
    }
    #fileList {
      margin-top: .5em;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 1em;
      max-height: 33vh;
      overflow-y: auto;
    }
    .file-item {
      padding: 0.5em;
      margin-bottom: 0.3em;
      background: #f5f5f5;
      border: 1px solid #e1e1e1;
      border-radius: 3px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.95em;
    }
    .file-item.real { cursor: grab; }
    .file-item.drag-over { background: #e6f7ff; border-color: #91d5ff; }
    .proposed {
      color: #555;
      font-style: italic;
      margin-left: 1em;
      flex-shrink: 0;
    }
    .placeholder-label {
      color: #888;
      font-style: italic;
    }
    .gap-controls {
      margin-top: 8px;
    }
    button {
      margin-top: 2em;
      padding: 0.75em 1.2em;
      font-size: 1em;
      background: #005aad;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: green; }
    .accordion {
      font-size:12pt  !important;
      font-family:"Helvetica" !important;
      background-color: #eee;
      color: #000 !important;
      cursor: pointer !important;
      padding: 8px !important;
      width: 100% !important;
      text-align: center !important;
      border: .5px solid #000 !important;
      outline: none !important;
      margin-bottom:8px;
      margin-top:12px;
    }
    .form-row {
	  display: flex;
	  gap: 12px;
	  align-items: flex-end; /* aligns the bottoms of the controls nicely */
	  flex-wrap: wrap;       /* lets them wrap on narrow screens */
  	}
  	.form-row > label {
  	  flex: 1 1 240px;       /* grow, shrink, min width */
  	  margin-top: 1em;    /* keep your existing label spacing */
  	}
  	.form-row > label > select,
  	.form-row > label > input[type="number"] {
  	  width: 100%;
  	}
    .active { background-color: #eee; }
    @media not all and (pointer: coarse) {
      .accordion:hover { background-color: #9f9; }
    }
    .expandall{
      font-size:11pt  !important;
      font-family:"Helvetica" !important;
      width:120px !important;
      height:40px !important;
      padding:7px !important;
      border-radius:4px !important;
      border:.5px solid #000 !important;
      color:black !important;
      background-color: #eee;
    }
    @media not all and (pointer: coarse) {
      .expandall:hover { background-color: #9f9; }
    }
    .tocpanel { padding: 8px !important; display: none; overflow: hidden !important; }

    /* For modal dialog prompt replacement */
    .modal_flat_background { background-color: #000; opacity: 0.4; }
    .modal_flat_main { border: 1px solid #333; box-shadow: 0px 0px 15px -2px rgba(0,0,0,0.75);  }
    .modal_flat_main, .modal_flat_main input, .modal_flat_main button {  font-size: 16px; }
    .modal_flat_main input, .modal_flat_main button {  padding: 5px; box-sizing: border-box; }
    .modal_flat_inner { padding: 30px; background: #fff; color: #000; }
    .modal_flat_content { font-family:"Helvetica"; margin: 20px 0px;}
    .modal_flat_input { margin: 20px 0px;}
    .modal_flat_buttons { text-align:center;margin-top: 40px; }
    .modal_flat_main button { background-color: #ccc; color: #000; padding: 10px 20px; border: 0px; cursor: pointer; outline: none; width: 100px;  }
    .modal_flat_cancel {margin-left: 5px;}
    </style>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>

    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VM0N9HL3MK');
    </script>

  </head>
  <body>
    <h1>ABC Transcription Tools&nbsp;-&nbsp;Custom Instrument Builder</h1>

    <button class="accordion" title="Click to expand/collapse this section">Click to show/hide the instructions</button>

    <div class="tocpanel" style="text-align:left;background-color:#f5ffff;">
      <p>This tool is used to create an ABC Transcription Tools custom instrument from a directory of per-note audio sample files.</p>
      <p>The files should be in .wav, .mp3, or .ogg format.</p>
      <p>1)&nbsp;Click <strong>Select audio sample files in .wav, .mp3, or .ogg format</strong> to select your audio sample files.</p>
      <p>The samples must all be in the same directory.</p>
      <p>The output note filename for each audio sample input file is displayed at the right of each item in the list.</p>
      <p>Drag and drop the items in the list into the scale note order you want.</p>
      <p>2)&nbsp;Select the default volume scale and fade time for the instrument.</p>
      <p>3)&nbsp;Choose the starting octave number for the instrument notes.</p>
      <p>4)&nbsp;Choose the starting scale note for the file names.</p>
      <p>5)&nbsp;If your files have filenames that contain note names, check <strong>Try to automatically sort files by scale order (C, Db, D, Eb, E, ...)</strong> to align the sample file list with the note names (checked by default).</p>
      <p>6)&nbsp;When automatically sorting by scale order, if there are scale gaps found, select between either synthesizing (pitch shift) the missing note samples in the scale from the next available lowest note or just replacing them with placeholder silent .wav files.</p>
      <p>
      <p>7)&nbsp;Click "Export as Custom ABC Transcription Tools Instrument" to export the custom instrument .zip sample bundle.</p>
      <p>The exported file will be saved to your browser's default <strong>Downloads</strong> directory.</p>
    </div>

    <label>Select audio sample files in .wav, .mp3, or .ogg format:
      <input type="file" id="fileInput" accept=".wav,.mp3,.ogg" multiple>
    </label>

	<div class="form-row">
	  <label>Volume scale:
	    <input type="number" id="volumeScale" step="0.1" min="0" value="1.0" inputmode="decimal">
	  </label>

	  <label>Fade time (ms):
	    <input type="number" id="fadeTime" step="1" min="0" value="100" inputmode="numeric">
	  </label>
	</div>

	<div class="form-row">
	  <label>Starting Octave Number:
	    <select id="startNumber">
	      <option value="0">0</option>
	      <option value="1">1</option>
	      <option value="2">2</option>
	      <option value="3">3</option>
	      <option value="4">4</option>
	      <option value="5">5</option>
	      <option value="6">6</option>
	      <option value="7">7</option>
	      <option value="8">8</option>
	      <option value="9">9</option>
	    </select>
	  </label>

	  <label>Starting Scale Note:
	    <select id="startNote">
	      <option value="0">C</option>
	      <option value="1">Db</option>
	      <option value="2">D</option>
	      <option value="3">Eb</option>
	      <option value="4">E</option>
	      <option value="5">F</option>
	      <option value="6">Gb</option>
	      <option value="7">G</option>
	      <option value="8">Ab</option>
	      <option value="9">A</option>
	      <option value="10">Bb</option>
	      <option value="11">B</option>
	    </select>
	  </label>
	</div>


    <label>
      <input type="checkbox" id="autoSort" checked>
      Try to automatically sort files by scale order (C, Db, D, Eb, E, ...)
    </label>

    <!-- Shown only when AutoSort is enabled -->
    <div id="gapOptions" class="gap-controls">
      Missing Note Handling:
      <select id="gapMode">
        <option value="synth">Synthesize (pitch-shift) missing notes</option>
        <option value="silent">Fill gaps with silent WAVs</option>
      </select>
    </div>


    <p id="dragMessage" style="margin-bottom:8px;display:none;"><strong>Drag the notes into the note scale order you want:</strong></p>

    <div id="fileList"></div>

    <div style="text-align: center;">
      <button id="exportZip">Click to Export as a Custom ABC Transcription Tools Instrument</button>
    </div>

    <script>
function DoStartup() {

        const notes = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
        let files = [];
        let originalFiles = [];

        const fileInput = document.getElementById('fileInput');
        const startNumber = document.getElementById('startNumber');
        const startNote = document.getElementById('startNote');
        const fileList = document.getElementById('fileList');
        const exportZipBtn = document.getElementById('exportZip');
        const autoSortCheckbox = document.getElementById('autoSort');
        const gapOptions = document.getElementById('gapOptions');
        const gapMode = document.getElementById('gapMode');
        const dragMessage = document.getElementById('dragMessage');

        // NEW: refs for volume/fade inputs
        const volumeScaleInput = document.getElementById('volumeScale');
        const fadeTimeInput = document.getElementById('fadeTime');

        var gFileSaveName = "custom_instrument.zip";

        // =========================
        // NEW: Hashed filename detection & UI mode control
        // =========================
        let gHasHashedNames = false;

        function stripExtension(name) {
          const i = name.lastIndexOf('.');
          return i >= 0 ? name.slice(0, i) : name;
        }

        // Consider any 16+ hex characters as a "hashlike" token (e.g., _025c95dacef4407dbe5d015164fe458b)
        const HASHLIKE_RE = /(?:^|[_\-])([0-9a-fA-F]{16,})(?:$|\b)/;

        function hasHashedFilenames(list) {
          return list.some(f => HASHLIKE_RE.test(stripExtension(f.name)));
        }

        function applyHashedModeUIState() {
          // Lock AutoSort OFF and disable it
          autoSortCheckbox.checked = false;
          gapOptions.style.display = 'none';
          dragMessage.style.display = 'block';
        }

        function clearHashedModeUIState() {
          // Restore normal behavior
          gapOptions.style.display = autoSortCheckbox.checked ? 'block' : 'none';
          dragMessage.style.display = autoSortCheckbox.checked ? 'none' : 'block';
        }

        // =========================
        // Helpers for pitch parsing
        // =========================
        const sharpToFlat = {
          "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab", "A#": "Bb",
          "Cs": "Db", "Ds": "Eb", "Fs": "Gb", "Gs": "Ab", "As": "Bb",
          "CS": "Db", "DS": "Eb", "FS": "Gb", "GS": "Ab", "AS": "Bb",
        };
        const noteOrder = ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
        const noteRegex = /([A-G][#bsS]?)(\d+)/i; // same as your sorter

        function parsePitchFromName(name) {
          const m = name.match(noteRegex);
          if (!m) return null;
          let note = m[1];
          const octave = parseInt(m[2],10);
          note = note.charAt(0).toUpperCase() + (note.slice(1) || "");
          note = sharpToFlat[note] || note;
          const idx = noteOrder.indexOf(note);
          if (idx < 0 || isNaN(octave)) return null;
          const pitchIndex = octave * 12 + idx; // semitone index from C0
          return { noteIdx: idx, octave, pitchIndex };
        }

        // Detect lowest pitch in current files and set selectors
        function detectAndApplyLowestPitch() {
          let minPI = Infinity;
          let minNoteIdx = 0;
          let minOctave = 0;
          for (const f of files) {
            const p = parsePitchFromName(f.name);
            if (p && p.pitchIndex < minPI) {
              minPI = p.pitchIndex;
              minNoteIdx = p.noteIdx;
              minOctave = p.octave;
            }
          }
          if (minPI !== Infinity) {
            const oct = Math.max(0, Math.min(9, minOctave));
            startNote.value = String(minNoteIdx);
            startNumber.value = String(oct);
          }
        }

        // =========================
        // Sorting (keep your logic)
        // =========================
        function sortFilesIfNeeded() {
            if (autoSortCheckbox.checked) {
                files.sort((a, b) => {
                    const matchA = a.name.match(noteRegex);
                    const matchB = b.name.match(noteRegex);

                    if (matchA && matchB) {
                        let noteA = matchA[1].charAt(0).toUpperCase() + (matchA[1].slice(1) || "");
                        let octaveA = parseInt(matchA[2], 10);

                        let noteB = matchB[1].charAt(0).toUpperCase() + (matchB[1].slice(1) || "");
                        let octaveB = parseInt(matchB[2], 10);

                        // Normalize sharps to flats
                        noteA = sharpToFlat[noteA] || noteA;
                        noteB = sharpToFlat[noteB] || noteB;

                        if (octaveA !== octaveB) return octaveA - octaveB;
                        return noteOrder.indexOf(noteA) - noteOrder.indexOf(noteB);
                    }

                    if (matchA) return -1;
                    if (matchB) return 1;
                    return 0;
                });
            } else {
                // Restore original order
                files = [...originalFiles];
            }
        }

        // Naming based on index relative to the LOWEST pitch slot when autoSort,
        // or the visual order when not autoSort.
        function getProposedNameForIndex(i, ext) {
            const start = parseInt(startNumber.value, 10);
            const offset = parseInt(startNote.value, 10);
            const noteIndex = (i + offset) % 12;
            const octave = start + Math.floor((i + offset) / 12);
            return `${notes[noteIndex]}${octave}.${ext}`;
        }

        // Build continuous pitch sequence [min..max] from matched files
        function buildContinuousRange() {

          // Map pitchIndex -> file (first occurrence)
          const matched = [];
          const unmatched = [];
          for (const f of files) {
            const p = parsePitchFromName(f.name);
            if (p) matched.push({ file: f, pitchIndex: p.pitchIndex, ext: f.name.split('.').pop() });
            else unmatched.push(f);
          }
          if (matched.length === 0) {
            return { full: [], unmatched }; // nothing to fill
          }
          matched.sort((a,b)=>a.pitchIndex-b.pitchIndex);
          const minPI = matched[0].pitchIndex;
          const maxPI = matched[matched.length-1].pitchIndex;

          const pitchMap = new Map();
          for (const m of matched) if (!pitchMap.has(m.pitchIndex)) pitchMap.set(m.pitchIndex, m);

          const full = [];
          for (let pi=minPI; pi<=maxPI; pi++) {
            const m = pitchMap.get(pi) || null;
            full.push({ file: m ? m.file : null, pitchIndex: pi, ext: m ? m.ext : "wav" });
          }
          return { full, unmatched };
        }

        // UI wiring
        fileInput.addEventListener('change', (e) => {
            originalFiles = Array.from(e.target.files); // keep original selection order
            files = [...originalFiles];

            // NEW: detect hashed filenames and switch behavior
            gHasHashedNames = hasHashedFilenames(files);
            if (gHasHashedNames) {
              applyHashedModeUIState();
              DayPilot.Modal.alert('<p style="text-align:center;font-size:1.1em;"><strong>Hash-based Filenames Detected</strong><br/><br/>Auto-sort and note range detect initially disabled.<br/><br/>Auto-sort and note range detect may crash if enabled, so be careful.</p>', { theme: "modal_flat", top: 200 });
            } else {
              clearHashedModeUIState();
            }

            sortFilesIfNeeded();
            if (autoSortCheckbox.checked && !gHasHashedNames){
              detectAndApplyLowestPitch();
            }
            renderList();
        });

        startNumber.addEventListener('change', renderList);
        startNote.addEventListener('change', renderList);

        autoSortCheckbox.addEventListener('change', () => {
            gapOptions.style.display = autoSortCheckbox.checked ? 'block' : 'none';
            dragMessage.style.display = autoSortCheckbox.checked ? 'none' : 'block';
            sortFilesIfNeeded();
            if (autoSortCheckbox.checked){
              detectAndApplyLowestPitch();
            }
            renderList();
        });

        gapMode.addEventListener('change', renderList);

        function renderList() {
            fileList.innerHTML = '';

            if (!autoSortCheckbox.checked) {
              // Original behavior: show only current items (no placeholders)
              files.forEach((file, i) => {
                  const item = document.createElement('div');
                  item.className = 'file-item real';
                  item.draggable = true;
                  item.dataset.index = i;

                  const proposedName = getProposedNameForIndex(i, file.name.split('.').pop());
                  item.innerHTML = `
                    <span>${file.name}</span>
                    <span class="proposed">→ ${proposedName}</span>
                  `;
                  addDragHandlers(item);
                  fileList.appendChild(item);
              });
              return;
            }

            // AutoSort ON: show continuous range placeholders from LOWEST to HIGHEST pitch found
            const { full, unmatched } = buildContinuousRange();

            if (full.length === 0) {
              // fallback if nothing matched pitch names (or hashed mode bypass returned [])
              files.forEach((file, i) => {
                const item = document.createElement('div');
                item.className = 'file-item real';
                item.draggable = true;
                item.dataset.index = i;
                const proposedName = getProposedNameForIndex(i, file.name.split('.').pop());
                item.innerHTML = `<span>${file.name}</span><span class="proposed">→ ${proposedName}</span>`;
                addDragHandlers(item);
                fileList.appendChild(item);
              });
              return;
            }

            // Show matched/placeholder range
            full.forEach((slot, idx) => {
              const item = document.createElement('div');
              if (slot.file) {
                item.className = 'file-item real';
                item.draggable = true;
                item.dataset.fileName = slot.file.name; // track by name
                // We also need to map back to 'files' for reordering
                const originalIndex = files.findIndex(f=>f===slot.file);
                if (originalIndex >= 0) item.dataset.index = String(originalIndex);
                const proposed = getProposedNameForIndex(idx, slot.ext);
                item.innerHTML = `<span>${slot.file.name}</span><span class="proposed">→ ${proposed}</span>`;
                addDragHandlers(item);
              } else {
                item.className = 'file-item';
                const proposed = getProposedNameForIndex(idx, "wav");
                const modeLabel = (gapMode.value === 'synth') ? ' (placeholder: synth)' : ' (placeholder: silent)';
                item.innerHTML = `<span class="placeholder-label">(placeholder)</span><span class="proposed">→ ${proposed}${modeLabel}</span>`;
              }
              fileList.appendChild(item);
            });

            // Show unmatched extras after the continuous range, continuing naming
            unmatched.forEach((file, i) => {
              const idx = full.length + i;
              const item = document.createElement('div');
              item.className = 'file-item real';
              item.draggable = true;
              item.dataset.index = files.findIndex(f=>f===file);
              const proposed = getProposedNameForIndex(idx, file.name.split('.').pop());
              item.innerHTML = `<span>${file.name}</span><span class="proposed">→ ${proposed}</span>`;
              addDragHandlers(item);
              fileList.appendChild(item);
            });
        }

        function addDragHandlers(el) {
            el.addEventListener('dragstart', (e) => {
                // only draggable if it's a real file item
                if (!el.classList.contains('real')) { e.preventDefault(); return; }
                e.dataTransfer.setData('text/plain', el.dataset.index);
                el.classList.add('dragging');
            });
            el.addEventListener('dragend', () => {
                el.classList.remove('dragging');
                // Update files array according to new DOM order (ignore placeholders)
                const newOrder = Array.from(fileList.children)
                  .filter(c => c.dataset.index !== undefined && c.dataset.index !== null)
                  .map(c => files[Number(c.dataset.index)]);
                // Keep any files that weren't in the list (shouldn't happen, but safe)
                if (newOrder.length) files = newOrder;
                renderList(); // re-render to update proposed names
            });
            el.addEventListener('dragover', (e) => {
                if (!document.querySelector('.dragging')) return;
                e.preventDefault();
                const dragging = document.querySelector('.dragging');
                const bounding = el.getBoundingClientRect();
                const offset = e.clientY - bounding.top;
                const height = bounding.height / 2;
                const parent = el.parentNode;
                if (offset > height) {
                    parent.insertBefore(dragging, el.nextSibling);
                } else {
                    parent.insertBefore(dragging, el);
                }
            });
        }

        // autoscroll while dragging
        fileList.addEventListener('dragover', (e) => {
            const scrollZone = 40; // px from edge
            const scrollSpeed = 4; // px per event
            const rect = fileList.getBoundingClientRect();

            if (e.clientY < rect.top + scrollZone) {
                fileList.scrollTop -= scrollSpeed;
            } else if (e.clientY > rect.bottom - scrollZone) {
                fileList.scrollTop += scrollSpeed;
            }
        });

        // ======== Audio helpers (WAV + pitch shifting) ========
        function generateSilentWav(durationSec = 1, sampleRate = 44100) {
            const numSamples = Math.floor(durationSec * sampleRate);
            const buffer = new ArrayBuffer(44 + numSamples * 2); // 16-bit mono PCM
            const view = new DataView(buffer);
            function writeStr(offset, str) {
              for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
            }
            writeStr(0, "RIFF");
            view.setUint32(4, 36 + numSamples * 2, true);
            writeStr(8, "WAVE");
            writeStr(12, "fmt ");
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);  // PCM
            view.setUint16(22, 1, true);  // channels
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);  // block align
            view.setUint16(34, 16, true); // bits
            writeStr(36, "data");
            view.setUint32(40, numSamples * 2, true);
            return new Blob([buffer], { type: "audio/wav" });
        }

        function audioBufferToWav(buffer) {
          const numChannels = buffer.numberOfChannels;
          const sampleRate = buffer.sampleRate;
          const length = buffer.length * numChannels * 2 + 44;
          const arrayBuffer = new ArrayBuffer(length);
          const view = new DataView(arrayBuffer);

          function writeString(offset, str) {
            for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
          }
          let pos = 0;
          writeString(pos, "RIFF"); pos += 4;
          view.setUint32(pos, length - 8, true); pos += 4;
          writeString(pos, "WAVE"); pos += 4;
          writeString(pos, "fmt "); pos += 4;
          view.setUint32(pos, 16, true); pos += 4;
          view.setUint16(pos, 1, true); pos += 2; // PCM
          view.setUint16(pos, numChannels, true); pos += 2;
          view.setUint32(pos, sampleRate, true); pos += 4;
          view.setUint32(pos, sampleRate * numChannels * 2, true); pos += 4;
          view.setUint16(pos, numChannels * 2, true); pos += 2;
          view.setUint16(pos, 16, true); pos += 2; // bits
          writeString(pos, "data"); pos += 4;
          view.setUint32(pos, length - 44, true); pos += 4;

          // Interleave channels
          const channels = [];
          for (let i = 0; i < numChannels; i++) channels.push(buffer.getChannelData(i));
          let offset = 0;
          while (offset < buffer.length) {
            for (let ch = 0; ch < numChannels; ch++) {
              let sample = channels[ch][offset];
              sample = Math.max(-1, Math.min(1, sample));
              view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
              pos += 2;
            }
            offset++;
          }
          return new Blob([arrayBuffer], { type: "audio/wav" });
        }

        const decodeCache = new WeakMap(); // File -> Promise<AudioBuffer>
        async function decodeFileToAudioBuffer(file) {
          if (decodeCache.has(file)) return decodeCache.get(file);
          const p = (async () => {
            const ac = new (window.AudioContext || window.webkitAudioContext)();
            const arr = await file.arrayBuffer();
            const buf = await ac.decodeAudioData(arr);
            return buf;
          })();
          decodeCache.set(file, p);
          return p;
        }

        async function pitchShiftFile(file, semitones) {
          // semitones can be positive (up) or negative (down)
          const srcBuf = await decodeFileToAudioBuffer(file);
          const rate = Math.pow(2, semitones / 12);
          const outLength = Math.ceil(srcBuf.length / rate);
          const offline = new OfflineAudioContext(srcBuf.numberOfChannels, outLength, srcBuf.sampleRate);
          const src = offline.createBufferSource();
          src.buffer = srcBuf;
          src.playbackRate.value = rate;
          src.connect(offline.destination);
          src.start();
          const rendered = await offline.startRendering();
          return audioBufferToWav(rendered); // Blob
        }

        // =====================
        // Export (ZIP) handling
        // =====================
        exportZipBtn.addEventListener('click', async () => {

            async function saveZipFile(fname) {

                // If no files at all
                if (!files.length) {
                  DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme: "modal_flat", top: 200 });
                  return;
                }

                const zip = new JSZip();

                // ---- NEW: add abctools.json with volume/fade settings ----
                let volumeScale = parseFloat(volumeScaleInput.value);
                let fadeTimeMs = parseInt(fadeTimeInput.value, 10);

                if (isNaN(volumeScale)) volumeScale = 1.0;
                if (isNaN(fadeTimeMs)) fadeTimeMs = 100;

                // enforce simple bounds
                if (volumeScale < 0) volumeScale = 0;
                if (fadeTimeMs < 0) fadeTimeMs = 0;

                const meta = {
                  volumeScale,
                  fadeTimeMs
                };
                zip.file("abctools.json", JSON.stringify(meta, null, 2));

                if (!autoSortCheckbox.checked) {
                  // ORIGINAL BEHAVIOR: just rename in current visual order
                  const reordered = Array.from(fileList.children)
                    .filter(el => el.classList.contains('real'))
                    .map(el => files[Number(el.dataset.index)]);

                  reordered.forEach((file, i) => {
                      const newName = getProposedNameForIndex(i, file.name.split('.').pop());
                      zip.file(newName, file);
                  });

                } else {
                  // AUTOSORT: Build continuous range from LOWEST to HIGHEST pitch found
                  const { full, unmatched } = buildContinuousRange();

                  if (full.length === 0) {
                    // fallback if nothing matched pitch: behave like non-autosort
                    files.forEach((file, i) => {
                      const newName = getProposedNameForIndex(i, file.name.split('.').pop());
                      zip.file(newName, file);
                    });
                  } else {
                    // Map pitchIndex -> i in the continuous range
                    const haveAtIndex = new Map(); // idx -> file
                    full.forEach((slot, i) => { if (slot.file) haveAtIndex.set(i, slot.file); });

                    // Helper to find nearest source file index for a missing slot.
                    function findSourceIndex(targetIdx) {
                      // Prefer lower pitch. If none lower, use higher.
                      for (let d = 1; d < full.length; d++) {
                        const lower = targetIdx - d;
                        if (lower >= 0 && haveAtIndex.has(lower)) return lower;
                        const higher = targetIdx + d;
                        if (higher < full.length && haveAtIndex.has(higher)) return higher;
                      }
                      return -1;
                    }

                    // Fill the continuous range (matched files or placeholders)
                    for (let i = 0; i < full.length; i++) {
                      const slot = full[i];
                      const ext = slot.file ? slot.ext : "wav";
                      const proposed = getProposedNameForIndex(i, ext);

                      if (slot.file) {
                        zip.file(proposed, slot.file);
                      } else {
                        if (gapMode.value === 'silent') {
                          zip.file(proposed, generateSilentWav(1));
                        } else {
                          const srcIdx = findSourceIndex(i);
                          if (srcIdx >= 0) {
                            const srcFile = haveAtIndex.get(srcIdx);
                            const semitones = i - srcIdx; // up is +, down is -
                            const blob = await pitchShiftFile(srcFile, semitones);
                            zip.file(proposed, blob);
                          } else {
                            // No source at all (shouldn't happen if full.length>0), fallback to silence
                            zip.file(proposed, generateSilentWav(1));
                          }
                        }
                      }
                    }

                    // Append unmatched extras after the range, continuing the sequence index
                    if (unmatched.length) {
                      const startIdx = full.length;
                      unmatched.forEach((file, j) => {
                        const proposed = getProposedNameForIndex(startIdx + j, file.name.split('.').pop());
                        zip.file(proposed, file);
                      });
                    }
                  }
                }

                const blob = await zip.generateAsync({ type: "blob" });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fname;
                a.click();
                setTimeout(function() {
                    window.URL.revokeObjectURL(a.href);
                }, 1000);
            };

            if (fileList.children.length == 0) {
                DayPilot.Modal.alert('<p style="text-align:center">Nothing to export!</p>', { theme: "modal_flat", top: 200 });
                return;
            }

            var thePrompt = "Please enter a filename for your custom instrument file:";

            DayPilot.Modal.prompt(thePrompt, gFileSaveName, {
                theme: "modal_flat",
                top: 200,
                autoFocus: true
            }).then(function(args) {

                var fname = args.result;

                // If the user pressed Cancel, exit
                if (fname == null) return;
                if (fname.length == 0) return;

                if (!fname.endsWith(".zip")) {
                    fname = fname.replace(/\..+$/, '');
                    fname = fname + ".zip";
                }

                gFileSaveName = fname;

                // ensure sorting state is applied
                sortFilesIfNeeded();
                saveZipFile(fname);

            });

        });

        // Accordion
        var acc = document.getElementsByClassName("accordion");
        for (var i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.display === "block") {
                    panel.style.display = "none";
                } else {
                    panel.style.display = "block";
                }
            });
        }
    }

    function WaitForReady(fn) {
        if (document.readyState !== 'loading') {
            fn();
            return;
        }
        document.addEventListener('DOMContentLoaded', fn);
    }

    WaitForReady(DoStartup);

    </script>
  </body>
</html>
