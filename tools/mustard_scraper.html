<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link rel="profile" href="http://gmpg.org/xfn/11">
  <title>thesession.org Tune Settings Scraper</title>
  <link rel='dns-prefetch' href='//fonts.googleapis.com' />
  <link rel='dns-prefetch' href='//s.w.org' />
  <link rel='preconnect' href='https://secureservercdn.net' crossorigin />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="thesession.org Tune Settings Scraper" />
  <meta property="og:description" content="thesession.org Tune Settings Scraper" />
  <meta property="og:url" content="https://michaeleskin.com/tools/mustard_scraper.html" />
  <meta property="og:site_name" content="thesession.org Tune Settings Scraper" />
  <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png"/>
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">
  <link rel="manifest" href="https://michaeleskin.com/abctools/img/abc-manifest.json">

  <style>
    :root{
      color-scheme: light dark;

      /* Responsive typography (bigger overall, still mobile-safe) */
      --fs-base: clamp(15px, 1.05vw + 12px, 17px);
      --fs-small: clamp(13px, 0.7vw + 11px, 14.5px);
      --fs-h2: clamp(20px, 1.2vw + 16px, 24px);

      /* Page padding */
      --page-pad: 24px;
    }

    html, body{
      height:100%;
      margin:0;
    }

    *, *::before, *::after{ box-sizing:border-box; }

    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;

      padding:
        calc(var(--page-pad) + env(safe-area-inset-top))
        calc(var(--page-pad) + env(safe-area-inset-right))
        calc(var(--page-pad) + env(safe-area-inset-bottom))
        calc(var(--page-pad) + env(safe-area-inset-left));

      box-sizing:border-box;
      overflow:hidden;

      font-size:var(--fs-base);
      line-height:1.35;
      -webkit-text-size-adjust:100%;
    }

    .app, .main, .left, .right, .card, .taWrap{ min-width:0; }

    .app{
      height: calc(100vh - (2 * var(--page-pad)));
      display:flex;
      flex-direction:column;
      gap:14px;
      overflow:hidden;
      min-height:0;
    }

    @supports (height: 100dvh){
      .app{
        height: calc(
          100dvh
          - (2 * var(--page-pad))
          - env(safe-area-inset-top)
          - env(safe-area-inset-bottom)
        );
      }
    }

    h2{
      margin:0 0 8px 0;
      font-size:var(--fs-h2);
    }

    p{ margin:0; }

    .row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      min-width:0;
    }

    input, textarea, button{
      font:inherit;
      color:inherit;
      max-width:100%;
    }

    input[type="text"]{
      -webkit-appearance:none;
      appearance:none;

      border:1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.06);
      color:inherit;

      border-radius:10px;
      padding:10px 12px;
      line-height:1.2;

      flex: 3 1 360px;
      min-width: 0;
      width:auto;
    }

    button{
      -webkit-appearance:none;
      appearance:none;

      border:1px solid rgba(127,127,127,.35);
      background: rgba(127,127,127,.12);
      color:inherit;

      border-radius:12px;
      padding:10px 14px;
      line-height:1.15;
      font-weight:600;

      display:inline-flex;
      align-items:center;
      justify-content:center;

      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;

      max-width:100%;
      min-width:0;
    }

    button:active{ transform: translateY(0.5px); }

    button:disabled{
      opacity:0.4;
      cursor:default;
      transform:none;
    }

    .row button{
      white-space:normal;
      text-align:center;
      flex: 1 1 180px;
    }

    #btnFetch{
      flex: 0 0 180px;   /* narrower */
      padding-left: 12px;
      padding-right: 12px;
    }

    #btnOpenInTools{ flex-basis: 100%; }

    .muted{
      opacity:0.75;
      line-height:2.0;
    }
    .small{ font-size:var(--fs-small); }

    .card{
      border:1px solid rgba(127,127,127,.35);
      border-radius:12px;
      padding:14px;
      overflow:hidden;
      min-width:0;
    }

    .status{
      white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      overflow:auto;
      max-height:300px;

      font-size:0.95em;
      line-height:1.45;

      overflow-wrap:anywhere;
      word-break:break-word;

      -webkit-overflow-scrolling: touch;
    }

    .main{
      flex:1;
      display:flex;
      gap:14px;
      overflow:hidden;
      min-height:0;
      min-width:0;
    }

    .left, .right{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:14px;
      overflow:hidden;
      min-height:0;
      min-width:0;
    }

    .taWrap{
      flex:1;
      min-height:0;
      border-radius:10px;
      overflow:hidden;
      border:1px solid rgba(127,127,127,.35);
      background:Canvas;
      min-width:0;

      /* NEW */
      display:flex;      /* makes textarea flex sizing reliable in Chrome */
      padding: 1px;      /* keeps the anti-clipping fix */
    }

    textarea{
      /* REPLACE the width/height sizing with flex sizing */
      flex: 1 1 auto;
      min-height: 0;

      width: auto;       /* optional, but avoids some Chrome quirks */
      height: auto;      /* important: don't use height:100% in this layout */

      padding:12px;
      border:0;
      border-radius:0;
      background:transparent;
      resize:none;
      overflow:auto;

      font-size:0.98em;
      line-height:1.35;

      overflow-wrap:anywhere;
      -webkit-overflow-scrolling: touch;

      box-sizing:border-box;
      display:block;
    }

    .rightHeader{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:8px;
      min-width:0;
    }

    code{
      background: rgba(127,127,127,.15);
      padding:2px 5px;
      border-radius:4px;
      font-size:0.95em;
    }

    /* Checkbox row */
    .checkRow{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .checkRow label{
      display:inline-flex;
      align-items:center;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .checkRow input[type="checkbox"]{
      width: 18px;
      height: 18px;
      accent-color: auto;
    }

    .modal_flat_background{
      background-color:#000;
      opacity:0.4;
    }

    .modal_flat_main{
      border:1px solid #333;
      box-shadow:0 0 15px -2px rgba(0,0,0,0.75);
    }

    .modal_flat_main,
    .modal_flat_main input,
    .modal_flat_main button{
      font-size:16px;
    }

    .modal_flat_main input,
    .modal_flat_main button{
      padding:6px;
      box-sizing:border-box;
    }

    .modal_flat_inner{
      padding:16px;
      background:#fff;
      color:#000;
    }

    .modal_flat_content{
      font-family: Helvetica, Arial, sans-serif;
      margin:20px 0;
    }

    .modal_flat_input{ margin:20px 0; }

    .modal_flat_buttons{
      text-align:center;
      margin-top:40px;
    }

    .modal_flat_main button{
      background-color:#ccc;
      color:#000;
      padding:10px 20px;
      border:0;
      cursor:pointer;
      outline:none;
      width:100px;
      border-radius:10px;
    }

    .modal_flat_cancel{ margin-left:6px; }

    .exampleLink{
      color: inherit;
      text-decoration: underline;
      cursor: pointer;
      word-break: break-all;
    }
    
    .instructions{
      font-size: clamp(14.5px, 0.9vw + 13px, 16.5px);
      line-height: 2.0;
    }

    .instructions a.exampleLink{
      font-weight: 500;
    }

    /* Bottom Help button */
    #btnHelp{
      width: 100%;
    }

    @media (max-width: 980px){
      body{
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: calc(var(--page-pad) + env(safe-area-inset-bottom) + 12px);
      }

      .app{
        height:auto;
        overflow:visible;
        min-height:0;
      }

      .main{
        flex-direction:column;
        overflow:visible;
        min-height:auto;
      }

      .left, .right{
        overflow:visible;
        min-height:auto;
      }

      .taWrap{
        height: 55vh;
        min-height: 320px;
      }

      #btnFetch{
        flex: 1 0 100% !important;
        width: 100% !important;
      }
    }

    @media (max-width: 720px){
      .row{ gap:10px; }
      .row button{ flex-basis:100%; }
      input[type="text"]{ flex-basis:100%; }
      .taWrap{ height: 60vh; min-height: 300px; }
      #btnFetch{
        flex: 1 0 100% !important;
        width: 100% !important;
      }
      .instructions a.exampleLink{
        font-size: 0.92em;     /* slightly smaller than surrounding text */
      }   
      #instructions_div{
        display: none !important;
      }
    }
  </style>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-VM0N9HL3MK');
  </script>
</head>

<body>
  <div class="app">
    <div>
      <h2><a href="https://thesession.org/tunes" target="_blank">thesession.org</a> Tune Settings Scraper</h2>
      <p class="muted small instructions" style="margin-top:6px">
        Enter a thesession.org tune URL like:<br/>
        <a href="https://thesession.org/tunes/1" class="exampleLink" data-fill-url="https://thesession.org/tunes/1">https://thesession.org/tunes/1</a>
        <br/>
        or a member's bookmarks page URL like:<br/>
        <a href="https://thesession.org/members/22376/bookmarks" class="exampleLink" data-fill-url="https://thesession.org/members/22376/bookmarks">https://thesession.org/members/22376/bookmarks</a>
      </p>
    </div>

    <div class="main">
      <!-- LEFT COLUMN -->
      <div class="left">
        <div class="card">
          <div class="row">
            <label for="tuneUrl"><strong>thesession.org URL:</strong></label>
            <input id="tuneUrl" type="text" value="https://thesession.org/tunes/1" />
            <button id="btnFetch">Fetch</button>
          </div>

          <div class="checkRow">
            <label for="onlyChords">
              <input id="onlyChords" type="checkbox" />
              <span>Only include tune settings that have chords</span>
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="btnCopy" disabled>Copy ABC</button>
            <button id="btnDownload" disabled>Download .abc File</button>
            <button id="btnOpenInTools" disabled>Open All Settings in the ABC Transcription Tools</button>
          </div>
        </div>

        <div class="card">
          <strong>Status</strong>
          <div id="status" class="status muted" style="margin-top:8px">Ready.</div>
        </div>
      </div>

      <!-- RIGHT COLUMN -->
      <div class="right">
        <div class="card" style="flex:1; display:flex; flex-direction:column; min-height:0;">
          <div class="rightHeader">
            <strong>Tune Settings ABC</strong>
          </div>
          <div class="taWrap">
            <textarea id="out" spellcheck="false"></textarea>
          </div>
        </div>
      </div>
    </div>
    <div id="instructions_div" class="card">
      <button id="btnHelp">Instructions</button>
    </div>
  </div>

<script>
/* ============================================================
   Status accumulation helpers
   ============================================================ */

const $ = (id) => document.getElementById(id);
const statusEl = $("status");
const outEl = $("out");
const tuneUrlInput = $("tuneUrl");
const onlyChordsEl = $("onlyChords");

// Click-to-fill example links
document.addEventListener("click", (e) => {
  const a = e.target.closest("a.exampleLink");
  if (!a) return;

  e.preventDefault();

  const urlToFill = a.getAttribute("data-fill-url") || a.getAttribute("href") || "";
  if (!urlToFill) return;

  tuneUrlInput.value = urlToFill;
  tuneUrlInput.focus();
  tuneUrlInput.select(); // handy on mobile/desktop
});

function clearStatus(msg) {
  statusEl.textContent = (msg == null ? "" : String(msg));
  statusEl.scrollTop = statusEl.scrollHeight;
}

function appendStatus(msg) {
  const s = String(msg == null ? "" : msg);
  if (!s) return;

  if (statusEl.textContent && !statusEl.textContent.endsWith("\n")) {
    statusEl.textContent += "\n";
  }
  statusEl.textContent += s + "\n";
  statusEl.scrollTop = statusEl.scrollHeight;
}

/* ============================================================
   Core entry (tune URL OR bookmarks URL)
   ============================================================ */

async function fetchTuneOrBookmarksAsABC(inputUrl, opts) {
  opts = opts || {};
  const onlyChords = !!opts.onlyChords;

  const url = String(inputUrl || "").trim();
  if (!url) throw new Error("Error: Please enter a URL.");

  if (isSessionTuneUrl(url)) {
    return await fetchAllTuneVersionsAsABC(url, opts);
  }

  if (!isSessionBookmarksUrl(url)) {
    throw new Error("Error: URL must be a thesession.org tune URL (/tunes/####) or a bookmarks URL (/members/####/bookmarks).");
  }

  // ---- Bookmarks flow (PAGED JSON) ----
  appendStatus("Loading bookmarks…");
  const items = await fetchAllBookmarksItemsPaged(url);

  if (!items.length) throw new Error("No bookmark items found.");

  // Collect ONLY bookmarked SETTINGS from object.url where objectType === "setting"
  // PLUS: capture the displayName so status can show tune name while fetching.
  const settingItems = [];
  for (const it of items) {
    const obj = (it && it.object) ? it.object : null;
    const objType = (obj && typeof obj.objectType === "string") ? obj.objectType : "";
    if (objType !== "setting") continue;

    const objUrl = (obj && typeof obj.url === "string") ? obj.url.trim() : "";
    if (!objUrl) continue;

    // This is the tune name for the bookmarked setting (per your example JSON)
    const displayName = (obj && typeof obj.displayName === "string") ? obj.displayName.trim() : "";

    settingItems.push({
      url: objUrl,
      displayName: displayName
    });
  }

  if (!settingItems.length) throw new Error("No bookmarked tune settings found.");

  // De-dupe by URL (keep first seen displayName)
  const seen = new Set();
  const uniqSettingItems = [];
  for (const si of settingItems) {
    if (seen.has(si.url)) continue;
    seen.add(si.url);
    uniqSettingItems.push(si);
  }

  appendStatus(`Found ${uniqSettingItems.length} bookmarked tune setting(s).`);

  // Cache tune JSON per tuneId
  const tuneCache = new Map(); // tuneId -> { tuneData, tuneUrlNoHash, tuneTitle, tuneType }

  const included = [];
  let skippedNoChords = 0;
  let skippedNotFound = 0;

  for (let i = 0; i < uniqSettingItems.length; i++) {
    const settingUrl = uniqSettingItems[i].url;
    const statusTuneName = uniqSettingItems[i].displayName || ""; // <-- name from bookmark JSON

    const tuneId = extractTuneIdFromSettingUrl(settingUrl);
    const settingId = extractSettingIdFromSettingUrl(settingUrl);

    if (!tuneId || !settingId) {
      skippedNotFound++;
      appendStatus(`Skip: could not parse tune/setting from ${settingUrl}`);
      continue;
    }

    let cached = tuneCache.get(tuneId);
    if (!cached) {
      const tuneUrlNoHash = `https://thesession.org/tunes/${encodeURIComponent(tuneId)}`;
      const tuneJsonUrl = normalizeToJsonUrl(tuneUrlNoHash);

      // CHANGED: show tune name (from bookmark displayName) instead of tune number
      // Fall back to tune id if displayName missing.
      appendStatus(`Loading tune ${i+1} of ${uniqSettingItems.length}: ${statusTuneName || tuneId}`);

      const tr = await fetch(tuneJsonUrl, { method: "GET", mode: "cors", cache: "no-store" });
      if (!tr.ok) throw new Error(`Error: Tune fetch failed: ${tr.status} ${tuneJsonUrl}`);
      const tuneData = await tr.json();

      const tuneTitle = (tuneData && tuneData.name) ? String(tuneData.name) : (statusTuneName || `Tune ${tuneId}`);
      const tuneType  = (tuneData && tuneData.type) ? normalizeTuneType(String(tuneData.type)) : "";

      cached = { tuneData, tuneUrlNoHash, tuneTitle, tuneType };
      tuneCache.set(tuneId, cached);
    }

    const picked = findSettingById(cached.tuneData, cached.tuneUrlNoHash, settingId);
    if (!picked || typeof picked.abc !== "string" || !picked.abc.trim()) {
      skippedNotFound++;
      appendStatus(`Skip: setting ${settingId} not found in tune ${statusTuneName || tuneId}`);
      continue;
    }

    const rawAbc = picked.abc;

    const bodyNormalized = extractBody(rawAbc)
      .replace(/\|\!\s/g, "|\n")
      .split(/\r?\n/)
      .map(line => line.trim())
      .join("\n")
      .trimEnd();

    if (onlyChords && !abcBodyHasChords(bodyNormalized)) {
      skippedNoChords++;
      continue;
    }

    included.push({
      setting: picked,
      rawAbc,
      bodyNormalized,
      tuneTitle: cached.tuneTitle,
      tuneType: cached.tuneType,
      sourceSettingUrl: settingUrl
    });
  }

  if (!included.length) {
    if (onlyChords) throw new Error("No bookmarked tune settings contained chords.");
    throw new Error("No bookmarked tune settings could be loaded.");
  }

  const totalIncluded = included.length;
  appendStatus(`Building ABC for ${totalIncluded} bookmarked tune setting(s)…`);

  const built = [];
  for (let j = 0; j < included.length; j++) {
    const it = included[j];

    const xNum = j + 1;
    const tLine = it.tuneTitle;

    const rLine = it.tuneType || (extractHeader(it.rawAbc, "R") || "").trim() || "";

    const mFromAbc = (extractHeader(it.rawAbc, "M") || "").trim();
    const mLine = mFromAbc || defaultMForRhythm(rLine) || "4/4";

    const lLine = (extractHeader(it.rawAbc, "L") || "").trim() || "1/8";

    const qExisting = (extractHeader(it.rawAbc, "Q") || "").trim();
    const qVal = qExisting ? qExisting.replace(/^Q:\s*/i, "") : defaultQForRhythm(rLine);

    const kRaw = (typeof it.setting.key === "string") ? it.setting.key : "";
    const kLine = normalizeKValue(kRaw) || "Dmaj";

    const zFromAbc = (extractHeader(it.rawAbc, "Z") || "").trim();
    const memberName =
      (it.setting && it.setting.member && typeof it.setting.member.name === "string")
        ? it.setting.member.name.trim()
        : "";
    const zLine = zFromAbc || memberName;

    const header =
      `X:${xNum}\n` +
      `T:${tLine}\n` +
      `R:${rLine || "reel"}\n` +
      `M:${mLine}\n` +
      `L:${lLine}\n` +
      `Q:${qVal}\n` +
      `K:${kLine}\n` +
      `S:${it.sourceSettingUrl}\n` +
      (zLine ? `Z:${zLine}\n` : "");

    built.push(header + it.bodyNormalized + "\n");
  }

  return {
    combined: built.join("\n"),
    tuneTitle: "Bookmarks",
    tuneType: "",
    tuneId: "",
    settingsCount: totalIncluded,
    skippedNoChords,
    skippedNotFound,
    bookmarkItemsCount: items.length,
    bookmarkSettingsCount: uniqSettingItems.length
  };
}

/* ============================================================
   Bookmarks paging
   - Requests page=1,2,3,... with format=json
   - Stops when:
     - items array is empty, OR
     - fetch fails (non-2xx), OR
     - safety max page reached
   ============================================================ */

async function fetchAllBookmarksItemsPaged(bookmarksUrl) {
  const all = [];
  const base = new URL(String(bookmarksUrl));
  base.hash = ""; // ignore

  const MAX_PAGES = 250; // safety (prevents infinite loops)

  for (let page = 1; page <= MAX_PAGES; page++) {
    const pageUrl = new URL(base.toString());
    pageUrl.searchParams.set("format", "json");
    pageUrl.searchParams.set("page", String(page));

    appendStatus(`- Fetching bookmarks page ${page}…`);

    let res;
    try {
      res = await fetch(pageUrl.toString(), { method: "GET", mode: "cors", cache: "no-store" });
    } catch (e) {
      appendStatus(`  Stop: fetch error on page ${page}.`);
      break;
    }

    if (!res.ok) {
      appendStatus(`  Stop: HTTP ${res.status} on page ${page}.`);
      break;
    }

    const data = await res.json();
    const items = (data && Array.isArray(data.items)) ? data.items : [];

    if (!items.length) {
      appendStatus(`  All bookmarked tune settings fetched!`);
      break;
    }

    all.push.apply(all, items);
  }

  return all;
}

/* ============================================================
   Existing: fetch all tune settings from /tunes/{id}?format=json
   + chord filter with correct counts
   ============================================================ */

async function fetchAllTuneVersionsAsABC(tuneUrl, opts) {
  opts = opts || {};
  const onlyChords = !!opts.onlyChords;

  const tuneId = extractTuneIdFromSessionUrl(tuneUrl);
  if (!tuneId) throw new Error("Error: Could not extract tunes from: " + tuneUrl);

  const apiUrl = `https://thesession.org/tunes/${encodeURIComponent(tuneId)}?format=json`;
  const res = await fetch(apiUrl, { method: "GET", mode: "cors", cache: "no-store" });
  if (!res.ok) throw new Error(`Error: The Session fetch failed: ${res.status} ${apiUrl}`);

  const data = await res.json();

  const tuneTitle = (data && data.name) ? String(data.name) : `Tune ${tuneId}`;
  const tuneType  = (data && data.type) ? normalizeTuneType(String(data.type)) : "";

  const settings = (data && Array.isArray(data.settings)) ? data.settings : [];
  if (!settings.length) throw new Error("Error: No settings found for tune: " + tuneUrl);

  const included = [];
  let skippedNoChords = 0;

  for (let i = 0; i < settings.length; i++) {
    const setting = settings[i] || {};
    const rawAbc = typeof setting.abc === "string" ? setting.abc : "";
    if (!rawAbc.trim()) continue;

    const bodyNormalized = extractBody(rawAbc)
      .replace(/\|\!\s/g, "|\n")
      .split(/\r?\n/)
      .map(line => line.trim())
      .join("\n")
      .trimEnd();

    if (onlyChords && !abcBodyHasChords(bodyNormalized)) {
      skippedNoChords++;
      continue;
    }

    included.push({ setting, rawAbc, bodyNormalized });
  }

  if (!included.length) {
    if (onlyChords) {
      if (settings.length > 1) throw new Error(settings.length + " tune settings available but no settings contained chords.");
      throw new Error(settings.length + " tune setting available but it did not contain chords.");
    }
    throw new Error("Error: Settings had no ABC text.");
  }

  const totalIncluded = included.length;
  const built = [];

  for (let j = 0; j < included.length; j++) {
    const { setting, rawAbc, bodyNormalized } = included[j];

    const xNum = j + 1;
    const tLine = tuneTitle + (totalIncluded > 1 ? ` (${xNum} of ${totalIncluded})` : "");

    const rLine = tuneType || (extractHeader(rawAbc, "R") || "").trim() || "";

    const mFromAbc = (extractHeader(rawAbc, "M") || "").trim();
    const mLine = mFromAbc || defaultMForRhythm(rLine) || "4/4";

    const lLine = (extractHeader(rawAbc, "L") || "").trim() || "1/8";

    const qExisting = (extractHeader(rawAbc, "Q") || "").trim();
    const qVal = qExisting ? qExisting.replace(/^Q:\s*/i, "") : defaultQForRhythm(rLine);

    const kRaw = (typeof setting.key === "string") ? setting.key : "";

    const zFromAbc = (extractHeader(rawAbc, "Z") || "").trim();
    const memberName =
      (setting && setting.member && typeof setting.member.name === "string")
        ? setting.member.name.trim()
        : "";
    const zLine = zFromAbc || memberName;

    const kLine = normalizeKValue(kRaw) || "Dmaj";

    const header =
      `X:${xNum}\n` +
      `T:${tLine}\n` +
      `R:${rLine || "reel"}\n` +
      `M:${mLine}\n` +
      `L:${lLine}\n` +
      `Q:${qVal}\n` +
      `K:${kLine}\n` +
      `S:${tuneUrl}\n` +
      (zLine ? `Z:${zLine}\n` : "");

    built.push(header + bodyNormalized + "\n");
  }

  return {
    combined: built.join("\n"),
    tuneTitle,
    tuneType,
    tuneId,
    settingsCount: totalIncluded,
    skippedNoChords
  };
}

/* ============================================================
   URL detection + JSON URL
   ============================================================ */

function isSessionTuneUrl(s) {
  try {
    const u = new URL(String(s));
    return /^\/tunes\/\d+\b/.test(u.pathname);
  } catch {
    return /\/tunes\/\d+\b/.test(String(s));
  }
}

function isSessionBookmarksUrl(s) {
  try {
    const u = new URL(String(s));
    return /^\/members\/\d+\/bookmarks\/?$/.test(u.pathname);
  } catch {
    return /\/members\/\d+\/bookmarks\/?$/.test(String(s));
  }
}

function normalizeToJsonUrl(url) {
  const u = new URL(String(url));
  u.searchParams.set("format", "json");
  return u.toString();
}

function extractTuneIdFromSettingUrl(s) {
  try {
    const u = new URL(String(s));
    const m = u.pathname.match(/^\/tunes\/(\d+)\b/);
    return m ? m[1] : null;
  } catch {
    const m = String(s).match(/\/tunes\/(\d+)\b/);
    return m ? m[1] : null;
  }
}

function extractSettingIdFromSettingUrl(s) {
  const m = String(s).match(/#setting-?(\d+)\b/i);
  return m ? m[1] : null;
}

// Prefer matching by numeric setting.id, fallback to URL equivalence.
function findSettingById(tuneData, tuneUrlNoHash, settingIdStr) {
  const settings = (tuneData && Array.isArray(tuneData.settings)) ? tuneData.settings : [];
  const targetId = String(settingIdStr || "");
  if (!targetId) return null;

  for (const s of settings) {
    if (s && (String(s.id) === targetId)) return s;
  }

  const targetUrl = `${String(tuneUrlNoHash).replace(/\?.*$/, "")}#setting${targetId}`;
  for (const s of settings) {
    if (!s) continue;
    const sid = (s.id != null) ? String(s.id) : "";
    if (sid && (`${String(tuneUrlNoHash).replace(/\?.*$/, "")}#setting${sid}` === targetUrl)) return s;
  }

  return null;
}

/* ============================================================
   Chord detection (ABC)
   ============================================================ */

function abcBodyHasChords(bodyText) {
  const s = String(bodyText || "");
  if (s.indexOf('"') === -1) return false;

  const chordRe = /"[^"\r\n]{1,20}"/g;
  const matches = s.match(chordRe);
  if (!matches) return false;

  for (const token of matches) {
    const inner = token.slice(1, -1).trim();
    if (!inner) continue;

    if (/^(N\.?C\.?|NC)$/i.test(inner)) return true;

    if (/^[A-Ga-g](?:#|b)?(?:m|min|maj|dim|aug|sus|add)?\d{0,2}(?:\([^)]*\))?(?:[\/][A-Ga-g](?:#|b)?)?$/.test(inner)) {
      return true;
    }

    if (/^[A-Ga-g](?:#|b)?/.test(inner)) return true;
  }
  return false;
}

/* ============================================================
   Helpers (ABC parsing + defaults)
   ============================================================ */

function extractTuneIdFromSessionUrl(s) {
  try {
    const u = new URL(String(s));
    const m = u.pathname.match(/^\/tunes\/(\d+)\b/);
    return m ? m[1] : null;
  } catch {
    const m = String(s).match(/\/tunes\/(\d+)\b/);
    return m ? m[1] : null;
  }
}

function normalizeTuneType(type) {
  return String(type || "").trim().toLowerCase();
}

function canonicalRhythm(r) {
  return String(r || "")
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/\u2011|\u2012|\u2013|\u2014/g, "-");
}

function defaultMForRhythm(r) {
  const rr = canonicalRhythm(r);

  if (rr === "reel" || rr === "hornpipe" || rr === "barndance" || rr === "barn dance" ||
      rr === "strathspey" || rr === "march") return "4/4";
  if (rr === "jig") return "6/8";
  if (rr === "slip jig" || rr === "slipjig") return "9/8";
  if (rr === "hop jig" || rr === "hopjig") return "9/8";
  if (rr === "slide") return "12/8";
  if (rr === "waltz" || rr === "mazurka") return "3/4";
  if (rr === "polka") return "2/4";
  if (rr === "three-two" || rr === "three two" || rr === "3-2" || rr === "3/2") return "3/2";
  return "";
}

function defaultQForRhythm(r) {
  const rr = canonicalRhythm(r);

  if (rr === "jig" || rr === "slip jig" || rr === "slipjig" || rr === "slide" || rr === "hop jig" || rr === "hopjig")
    return "3/8=120";
  if (rr === "reel") return "1/2=90";
  if (rr === "hornpipe" || rr === "march"  || rr === "barndance" || rr === "barn dance") return "1/2=80";
  if (rr === "strathspey") return "1/2=70";
  if (rr === "polka") return "1/4=120";
  if (rr === "waltz" || rr === "mazurka") return "1/4=120";
  if (rr === "three-two" || rr === "three two" || rr === "3-2" || rr === "3/2") return "1/2=80";
  return "1/2=90";
}

function extractHeader(abcText, tagLetter) {
  const re = new RegExp(`^\\s*${tagLetter}\\s*:\\s*(.*)$`, "mi");
  const m = String(abcText).match(re);
  return m ? m[1] : "";
}

function extractBody(abcText) {
  const lines = String(abcText).replace(/^\uFEFF/, "").split(/\r?\n/);

  let i = 0;
  while (i < lines.length) {
    const line = lines[i];
    if (/^\s*$/.test(line) || /^\s*%/.test(line)) i++;
    else break;
  }

  while (i < lines.length) {
    const line = lines[i];
    if (
      /^\s*[A-Za-z][A-Za-z0-9]*\s*:/.test(line) ||
      /^\s*\+:\s*/.test(line) ||
      /^\s*%%/.test(line) ||
      /^\s*%/.test(line) ||
      /^\s*$/.test(line)
    ) {
      i++;
      continue;
    }
    break;
  }

  const bodyLines = lines.slice(i);
  if (!bodyLines.join("\n").trim()) return String(abcText);
  return bodyLines.join("\n").trimStart() + "\n";
}

/* ============================================================
   K: tag normalization (input like "Eminor" -> "Emin")
   ============================================================ */

function normalizeKValue(k) {
  k = String(k || "").trim();
  if (!k) return "";

  const tonicMatch = k.match(/^([A-Ga-g])\s*([#b]?)(.*)$/);
  if (!tonicMatch) return k;

  const tonic = tonicMatch[1].toUpperCase() + (tonicMatch[2] || "");
  let rest = (tonicMatch[3] || "").trim().toLowerCase();

  if (!rest) return tonic + "maj";
  rest = rest.replace(/^[:\s]+/, "");

  const shortToken = rest.match(/^(maj|min|dor|mix|phr|lyd|loc)\b/);
  if (shortToken) return tonic + shortToken[1];

  const mode = normalizeMode(rest);
  return tonic + (mode || "maj");
}

function normalizeMode(mode) {
  mode = String(mode || "").trim().toLowerCase();
  if (!mode) return "";

  if (mode === "major" || mode === "maj" || mode === "ionian") return "maj";
  if (mode === "minor" || mode === "min" || mode === "aeolian") return "min";
  if (mode === "dorian" || mode === "dor") return "dor";
  if (mode === "mixolydian" || mode === "mix") return "mix";
  if (mode === "phrygian" || mode === "phr") return "phr";
  if (mode === "lydian" || mode === "lyd") return "lyd";
  if (mode === "locrian" || mode === "loc") return "loc";

  if (/^(maj|min|dor|mix|phr|lyd|loc)$/.test(mode)) return mode;

  if (mode.includes("minor")) return "min";
  if (mode.includes("major")) return "maj";
  if (mode.includes("dorian")) return "dor";
  if (mode.includes("mixolyd")) return "mix";
  if (mode.includes("phryg")) return "phr";
  if (mode.includes("lyd")) return "lyd";
  if (mode.includes("locr")) return "loc";

  return "";
}

/* ============================================================
   UI wiring
   ============================================================ */

let lastResult = null;

function safeFilename(s) {
  return String(s || "tune")
    .replace(/[^\w\-]+/g, "_")
    .replace(/_+/g, "_")
    .replace(/^_+|_+$/g, "")
    .slice(0, 80) || "tune";
}

function enableActions(on) {
  $("btnCopy").disabled = !on;
  $("btnDownload").disabled = !on;
  $("btnOpenInTools").disabled = !on;
}

function capitalizeFirst(str) {
  if (!str) return str;
  const [first, ...rest] = str;
  return first.toUpperCase() + rest.join("");
}

$("btnFetch").addEventListener("click", async () => {
  const url = $("tuneUrl").value.trim();
  const onlyChords = !!onlyChordsEl.checked;

  enableActions(false);
  outEl.value = "";
  lastResult = null;

  clearStatus("Fetching and building ABC…");

  try {
    const result = await fetchTuneOrBookmarksAsABC(url, { onlyChords });
    lastResult = result;

    outEl.value = result.combined;

    // Status summary
    clearStatus("Success!\n");

    if (isSessionTuneUrl(url)) {
      appendStatus(`- Title: ${result.tuneTitle}`);
      appendStatus(`- Type: ${capitalizeFirst((result.tuneType || "(varies / not provided)"))}`);
    } else {
      appendStatus("- Source: Bookmarks");
      if (result.bookmarkItemsCount != null) appendStatus(`- Bookmark items fetched: ${result.bookmarkItemsCount}`);
      if (result.bookmarkSettingsCount != null) appendStatus(`- Bookmarked tune settings found: ${result.bookmarkSettingsCount}`);
    }

    appendStatus(`- # of Settings: ${result.settingsCount}`);

    if (onlyChords) appendStatus(`- Skipped (no chords): ${result.skippedNoChords || 0}`);
    if (result.skippedNotFound != null && result.skippedNotFound > 0) appendStatus(`- Skipped (missing tune setting): ${result.skippedNotFound}`);

    appendStatus("");

    // Test URL length and enable/disable the open in ABC Transcriptions Tool button as required
    if (testOpenInAbcTools(outEl.value)){
      enableActions(true);
      appendStatus("You can now copy/download the ABC settings or open them in the ABC Transcription Tools.");
    }
    else{
      // Disable the open in ABC tools
      enableActions(true);
      $("btnOpenInTools").disabled = true;
      appendStatus("You can now copy/download the ABC settings.");      
    }
  } catch (e) {
    console.error(e);
    clearStatus(e && e.message ? e.message : String(e));
  }
});

$("btnCopy").addEventListener("click", async () => {
  try {
    await navigator.clipboard.writeText(outEl.value);
    clearStatus("Copied ABC to clipboard.");
  } catch (e) {
    clearStatus("Copy failed (browser permission). You can still select-all and copy manually.");
  }
});

$("btnDownload").addEventListener("click", () => {
  if (!lastResult) return;

  // If bookmarks, make filename reflect that
  const baseName = (lastResult.tuneTitle && lastResult.tuneTitle !== "Bookmarks") ? lastResult.tuneTitle : "bookmarks";

  const blob = new Blob([outEl.value], { type: "text/plain;charset=utf-8" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `${safeFilename(baseName)}_thesession${lastResult.tuneId ? ("_" + lastResult.tuneId) : ""}.abc`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(function(){
    URL.revokeObjectURL(a.href);
  },1000);
});

$("btnOpenInTools").addEventListener("click", () => {
  try {
    if (!lastResult) return;
    openInAbcTools(outEl.value);
    clearStatus("ABC opened in the ABC Transcription Tools.");
  } catch (e) {
    console.error(e);
    clearStatus("Open in ABC Transcription Tools failed: " + (e && e.message ? e.message : String(e)));
  }
});

/* ============================================================
   Base64/Base64URL helpers for Deflate mode
   ============================================================ */

function def_bytesToBase64(bytes) {
  var binary = "";
  var len = bytes.length;
  for (var i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function def_bytesToBase64URL(bytes) {
  return def_bytesToBase64(bytes)
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
}

/* ============================================================
   Open the tunes in the ABC Transcription Tools
   ============================================================ */

function testOpenInAbcTools(theABC) {
  var m = String(theABC).match(/^\s*T\s*:\s*(.+)\s*$/m);
  var tuneTitle = (m && m[1]) ? m[1].trim() : "tune";
  tuneTitle = encodeURIComponent(tuneTitle.replace(/\s+/g, "_"));

  var encoder = new TextEncoder();
  var utf8Bytes = encoder.encode(theABC);
  var deflated = pako.deflate(utf8Bytes, { level: 6 });
  var abc_compressed = def_bytesToBase64URL(deflated);

  var url =
    "https://michaeleskin.com/abctools/abctools.html?def=" + abc_compressed +
    "&format=noten&ssp=0" +
    "&name=" + tuneTitle +
    "&editor=1";

  if (url.length < 8100) {
    return true;
  } else {
    return false;
  }
}

function openInAbcTools(theABC) {
  var m = String(theABC).match(/^\s*T\s*:\s*(.+)\s*$/m);
  var tuneTitle = (m && m[1]) ? m[1].trim() : "tune";
  tuneTitle = encodeURIComponent(tuneTitle.replace(/\s+/g, "_"));

  var encoder = new TextEncoder();
  var utf8Bytes = encoder.encode(theABC);
  var deflated = pako.deflate(utf8Bytes, { level: 6 });
  var abc_compressed = def_bytesToBase64URL(deflated);

  var url =
    "https://michaeleskin.com/abctools/abctools.html?def=" + abc_compressed +
    "&format=noten&ssp=0" +
    "&name=" + tuneTitle +
    "&editor=1";

  if (url.length < 8100) {
    window.open(url, "_blank", "noopener,noreferrer");
  } else {
    DayPilot.Modal.alert(
      '<p style="text-align:center;font-family:helvetica;font-size:12pt;">The Share URL is too long to open in ABC Transcription Tools.<br/><br/>Instead, copy and paste the ABC or save it to an ABC file and load it from the tools.</p>',
      { theme: "modal_flat", top: 230, scrollWithPage: false }
    );
  }
}

tuneUrlInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    $("btnFetch").click();
  }
});

// Instructions modal
$("btnHelp").addEventListener("click", () => {

  // scrollable inner content
  const content =
    '  <div style="margin-bottom:16px;">' +
    '    Enter either a thesession.org tune URL, or a member bookmarks page URL into the <b>thesession.org URL</b> field and click <b>Fetch</b>.' +
    '  </div>' +
    '  <div style="margin-bottom:16px;">' +
    '    You can copy the results to the clipboard, save them to a .ABC file, or if the ShareURL length would be less than 8100 characters, open the results directly in the <a href="https://michaeleskin.com/abctools/abctools.html" target="_blank" rel="noopener noreferrer">ABC Transcription Tools.</a>' +
    '  </div>' +

    '  <div style="margin-bottom:16px;">' +
    '    <div style="font-weight:700; margin-bottom:6px;">Examples (click to fill the thesession.org URL field):</div>' +
    '    <div style="margin-bottom:6px;">' +
    '      <a href="https://thesession.org/tunes/1" class="exampleLink" data-fill-url="https://thesession.org/tunes/1">https://thesession.org/tunes/1</a>' +
    '    </div>' +
    '    <div>' +
    '      <a href="https://thesession.org/members/22376/bookmarks" class="exampleLink" data-fill-url="https://thesession.org/members/22376/bookmarks">https://thesession.org/members/22376/bookmarks</a>' +
    '    </div>' +
    '  </div>' +

    '  <div style="margin-bottom:16px;">' +
    '    <div style="font-weight:700; margin-bottom:6px;">Guitar chords filter</div>' +
    '    <div>' +
    '      If <b>“Only include tune settings that have chords”</b> is checked, the tool will ' +
    '      include only settings that contain guitar-style chord annotations ' +
    '      (for example <code>"Em"</code>, <code>"D"</code>, <code>"G/B"</code>, etc.) in the ABC.' +
    '    </div>' +
    '    <div style="opacity:0.8; margin-top:6px;">' +
    '      This is useful if you want to quickly collect settings with chords ' +
    '      and skip melody-only versions.' +
    '    </div>' +
    '  </div>' +

    '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

    '  <div style="text-align:center; font-size:15pt; font-weight:700; margin-bottom:10px;">Tip Jars</div>' +
    '  <div style="text-align:center; margin-bottom:12px;">' +
    '    If you find this tool useful, please consider buying me a beer<br/>' +
    '    by tossing a few bucks into one of my virtual tip jars:' +
    '  </div>' +

    '  <div style="text-align:center; margin-bottom:10px;">' +
    '    <div style="font-weight:700;">PayPal</div>' +
    '    <div><a href="https://paypal.me/MichaelEskin" target="_blank" rel="noopener noreferrer">https://paypal.me/MichaelEskin</a></div>' +
    '  </div>' +

    '  <div style="text-align:center; margin-bottom:16px;">' +
    '    <div style="font-weight:700;">Venmo</div>' +
    '    <div>@MichaelEskin</div>' +
    '  </div>' +

    '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

    '  <div style="margin-bottom:6px; text-align:center;"><b>The source code for this tool is available on GitHub:</b></div>' +
    '  <div style="margin-bottom:6px; text-align:center;">' +
    '    <a href="https://github.com/seisiuneer/abctools/blob/main/tools/mustard_scraper.html" target="_blank" rel="noopener noreferrer">' +
    '      mustard_scraper.html' +
    '    </a>' +
    '  </div>';

  const html =
    '<div style="font-family:Helvetica, Arial, sans-serif; font-size:12.5pt; line-height:1.6;">' +
    '  <div style="text-align:center; font-size:16pt; font-weight:700; margin-bottom:14px;">Instructions</div>' +

    // scroll container (keeps dialog from getting super tall)
    '<div style="' +
      'width:100%;' +
      'max-height:min(60vh, 520px);' +
      'overflow:auto;' +
      '-webkit-overflow-scrolling:touch;' +
      'padding:0 12px 2px 12px;' +
      'padding-left:30px !important;' +
      'box-sizing:border-box;' +
    '">' +
    content +
    '  </div>' +
    '</div>';

  DayPilot.Modal.alert(html, {
    theme: "modal_flat",
    top: 50,
    scrollWithPage: false
  });
});

</script>

<script type="text/javascript" src="pako.min.js?v=9"></script>
<script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=9"></script>

</body>
</html>
