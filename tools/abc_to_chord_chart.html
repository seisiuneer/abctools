<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="Cache-Control" content="no-cache, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="profile" href="http://gmpg.org/xfn/11">
  <title>ABC Chord Chart Generator</title>
  <link rel='dns-prefetch' href='//fonts.googleapis.com' />
  <link rel='dns-prefetch' href='//s.w.org' />
  <link rel='preconnect' href='https://secureservercdn.net' crossorigin />

  <meta property="og:type" content="website" />
  <meta property="og:title" content="ABC Chord Chart Generator" />
  <meta property="og:description" content="ABC Chord Chart Generator" />
  <meta property="og:url" content="https://michaeleskin.com/tools/abc_to_chord_chart.html" />
  <meta property="og:site_name" content="ABC Chord Chart Generator" />
  <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png"/>

  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">
  <link rel="manifest" href="https://michaeleskin.com/abctools/img/abc-manifest.json">

  <style>
    /* ============================================================
       Theme + base tokens
       ============================================================ */
    :root{
      color-scheme: light;

      /* Typography */
      --fs-base: clamp(15px, 1.05vw + 12px, 17px);
      --fs-small: var(--fs-base);
      --fs-h2: clamp(20px, 1.2vw + 16px, 24px);
      --fs-h3: clamp(17px, 1.05vw + 14px, 20px);

      /* Layout */
      --page-pad: 32px;
      --gap: 14px;

      /* Visual */
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --bd: 1px solid rgba(127,127,127,.35);
      --btn-bg: rgba(127,127,127,.12);

      /* Fixed help bar */
      --helpbar-pad-y: 12px;
      --helpbar-est-height: 64px;

      /* Card padding (keep in sync with .card padding below) */
      --card-pad: 14px;
    }

    html, body{ height:100%; margin:0; }
    *, *::before, *::after{ box-sizing:border-box; }

    /* ============================================================
       Page shell
       ============================================================ */
    body{
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      font-size: var(--fs-base);
      line-height: 1.35;
      color:#000;
      -webkit-text-size-adjust: 100%;

      padding:
        calc(var(--page-pad) + env(safe-area-inset-top))
        calc(var(--page-pad) + env(safe-area-inset-right))
        calc(var(--page-pad) + env(safe-area-inset-bottom))
        calc(var(--page-pad) + env(safe-area-inset-left));

      overflow:hidden;
    }

    /* Common “can shrink” fix for flex children */
    .app, .main, .left, .right, .card, .taWrap, .chartsWrap{ min-width:0; }

    .app{
      height: calc(100vh - (2 * var(--page-pad)));
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      overflow:hidden;
      min-height:0;

      /* Reserve space for fixed Instructions bar */
      padding-bottom: calc(var(--helpbar-est-height) + env(safe-area-inset-bottom));
    }

    @supports (height: 100dvh){
      .app{
        height: calc(
          100dvh
          - (2 * var(--page-pad))
          - env(safe-area-inset-top)
          - env(safe-area-inset-bottom)
        );
      }
    }

    /* ============================================================
       Typography helpers
       ============================================================ */
    h2{ margin:0 0 8px; font-size: var(--fs-h2); }
    h3{ margin:0; font-size: var(--fs-h3); }
    .card_label{ margin:0 0 12px; font-size: var(--fs-h3); }

    p{ margin:0; }
    .muted{ opacity:0.75; line-height:2.0; }
    .small{ font-size: var(--fs-small); }

    code{
      background: rgba(127,127,127,.15);
      padding:2px 5px;
      border-radius:4px;
      font-size:0.95em;
    }

    /* ============================================================
       Main 2-column layout
       ============================================================ */
    .main{
      flex:1;
      display:flex;
      gap: var(--gap);
      overflow:hidden;
      min-height:0;
      min-width:0;
    }

    .left, .right{
      flex:1;
      display:flex;
      flex-direction:column;
      gap: var(--gap);
      min-height:0;
      min-width:0;
    }

    .left  { flex: 2 1 0; }
    .right { flex: 3 1 0; }

    /* Short-but-wide screens: left column scrolls; cards don't collapse */
    .left{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: calc(var(--helpbar-est-height) + 16px);
    }
    .left > .card{ flex: 0 0 auto; }

    /* Right side: output scrolls inside .chartsWrap */
    .right{ overflow:hidden; }
    .right > .card{ min-height:0; }

    /* ============================================================
       Cards + rows
       ============================================================ */
    .card{
      border: var(--bd);
      border-radius:12px;
      padding: var(--card-pad);
      overflow:hidden;
      background: transparent;
      min-width:0;
    }

    .row{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      min-width:0;
    }

    /* ============================================================
       Controls
       ============================================================ */
    input, textarea, button, select{
      font:inherit;
      color:inherit;
      max-width:100%;
    }

    input[type="text"], input[type="number"], select{
      -webkit-appearance:none;
      appearance:none;
      border: var(--bd);
      background:#fff;
      color:#000;
      border-radius:10px;
      padding:10px 12px;
      line-height:1.2;
      min-width:0;
    }

    select{
      padding:10px 52px 10px 12px;
      cursor:pointer;
      background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20viewBox%3D%270%200%2024%2024%27%3E%3Cpolygon%20points%3D%276%2C9%2018%2C9%2012%2C17%27%20fill%3D%27%23000%27%2F%3E%3C%2Fsvg%3E");
      background-repeat:no-repeat;
      background-position:right 16px center;
      background-size:22px 22px;
    }

    button{
      -webkit-appearance:none;
      appearance:none;
      border: var(--bd);
      background: var(--btn-bg);
      border-radius:12px;
      padding:10px 14px;
      line-height:1.15;
      font-weight:600;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      min-width:0;
    }
    button:active{ transform: translateY(0.5px); }
    button:disabled{ opacity:0.4; cursor:default; transform:none; }

    .row button{
      white-space:normal;
      text-align:center;
      flex: 1 1 180px;
    }

    .primary{
      background:#111;
      color:#fff;
      border-color:#111;
    }

    input[type="file"]::file-selector-button{
      padding: 10px 16px;
      border-radius: 12px;
      border: var(--bd);
      background: var(--btn-bg);
      font-weight: 600;
      cursor: pointer;
    }

    /* ============================================================
       ABC Input card: only this card flexes tall
       ============================================================ */
    #cardInput{
      flex: 1 1 auto !important;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 260px !important;
    }

    #cardInput .taWrap{
      flex: 1 1 auto;
      min-height: 160px;
    }

    /* Sticky header inside cardInput (no extra horizontal padding) */
    #cardInput > .row{
      flex-wrap: nowrap;
      gap: 18px !important; /* override inline */
      position: sticky;
      top: 0;
      z-index: 5;
      background: Canvas;
      padding: 4px 0 10px;
      margin-left: 0 !important; /* override inline */
    }

    #cardInput > .row h3{
      white-space: nowrap;
      flex: 0 0 auto;
      min-width: 9ch;
    }

    #cardInput > .row > .row{
      display:flex;
      flex: 1 1 auto;
      min-width:0;
      overflow:hidden;
      align-items:center;
      gap: 10px !important; /* override inline */
      justify-content:flex-start;
    }

    #cardInput > .row > .row .muted.small{
      flex: 0 1 auto; /* do not grow */
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      margin-right:0;
    }

    #fileIn{
      flex: 0 0 auto !important;
      min-width: 260px;
      max-width: 100%;
    }

    /* If your HTML still has inline margin-top on .taWrap, this neutralizes it */
    #cardInput .taWrap{ margin-top: 0 !important; }

    /* ============================================================
       Text areas + output
       ============================================================ */
    .taWrap{
      flex:1;
      min-height:0;
      overflow:hidden;
      border: var(--bd);
      background: Canvas;
      display:flex;
      padding:1px;
    }

    textarea{
      flex:1 1 auto;
      min-height:0;
      padding:12px;
      border:0;
      background:transparent;
      resize:none;
      overflow:auto;
      font-family: var(--mono);
      font-size:0.98em;
      line-height:1.35;
      overflow-wrap:anywhere;
      -webkit-overflow-scrolling: touch;
      display:block;
    }

    .chartsWrap{
      flex:1;
      min-height:0;
      border-radius:10px;
      overflow:auto;
      border: var(--bd);
      background: Canvas;
      padding:12px;
      -webkit-overflow-scrolling: touch;
    }

    .chart{
      border: var(--bd);
      border-radius:12px;
      padding:14px;
      background:#fff;
      margin:0 0 12px;
      overflow:hidden;
    }
    .chart:last-child{ margin-bottom:0; }

    .chart h3{
      margin:0 0 10px;
      font-size: clamp(18px, 1vw + 16px, 22px);
    }

    .chart pre{
      margin:0;
      font-family: var(--mono);
      white-space: pre;
      tab-size: 2;
      font-size: 18px;
      line-height: 1.35;
      overflow-x:auto;
      padding-bottom:6px;
    }

    .status{
      white-space:pre-wrap;
      font-family: var(--mono);
      overflow:auto;
      max-height:240px;
      font-size:0.95em;
      line-height:1.45;
      overflow-wrap:anywhere;
      word-break:break-word;
      -webkit-overflow-scrolling: touch;
      opacity:0.85;
    }

    .errorText{ color:#b00020; opacity:1; }

    /* ============================================================
       Fixed bottom help bar
       ============================================================ */
    #cardHelp{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      z-index:1000;
      margin:0;
      border-radius:0;
      border-left:none;
      border-right:none;
      border-bottom:none;
      background: Canvas;

      padding:
        var(--helpbar-pad-y)
        calc(var(--page-pad) + env(safe-area-inset-right))
        calc(var(--helpbar-pad-y) + env(safe-area-inset-bottom))
        calc(var(--page-pad) + env(safe-area-inset-left));
    }

    #btnHelp{ width:100%; }

    .exampleLink{
      color: inherit;
      text-decoration: underline;
      cursor: pointer;
      word-break: break-all;
    }

    /* ============================================================
       DayPilot modal theme
       ============================================================ */
    .modal_flat_background{ background-color:#000; opacity:0.4; }
    .modal_flat_main{ border:1px solid #333; box-shadow:0 0 15px -2px rgba(0,0,0,0.75); }
    .modal_flat_main, .modal_flat_main input, .modal_flat_main button{ font-size:16px; }
    .modal_flat_main input, .modal_flat_main button{ padding:6px; box-sizing:border-box; }
    .modal_flat_inner{ padding:16px; background:#fff; color:#000; }
    .modal_flat_content{ font-family: Helvetica, Arial, sans-serif; margin:20px 0; }
    .modal_flat_input{ margin:20px 0; }
    .modal_flat_buttons{ text-align:center; margin-top:40px; }
    .modal_flat_main button{
      background-color:#ccc;
      color:#000;
      padding:10px 20px;
      border:0;
      cursor:pointer;
      outline:none;
      width:100px;
      border-radius:10px;
    }
    .modal_flat_cancel{ margin-left:6px; }

    /* Modal width on desktop */
    @media (min-width: 721px){
      .modal_flat_main{
        width: min(740px, calc(100vw - 80px)) !important;
        max-width: min(740px, calc(100vw - 80px)) !important;
      }
    }

    /* ============================================================
       Responsive (stacked layout)
       ============================================================ */
    @media (max-width: 980px){
      body{
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: calc(var(--page-pad) + env(safe-area-inset-bottom) + 12px);
      }

      .app{
        height:auto;
        overflow:visible;
        padding-bottom: calc(var(--helpbar-est-height) + env(safe-area-inset-bottom));
      }

      .main{
        flex-direction:column;
        overflow:visible;
        min-height:auto;
      }

      .left, .right{
        overflow:visible;
        min-height:auto;
        padding-bottom:0;
      }

      .taWrap{ height: 48vh; min-height: 320px; }
      .chartsWrap{ height: 55vh; min-height: 320px; }

      #instructions_div{
        margin-bottom: calc(env(safe-area-inset-bottom) + var(--page-pad));
      }

      .left > .card{ flex: 0 0 auto; }
      #cardInput{ flex: 0 0 auto !important; min-height: auto !important; }
    }

    @media (max-width: 720px){
      .row{ gap:10px; }
      .row button{ flex-basis:100%; }

      .taWrap{ height: 52vh; min-height: 300px; }
      .chartsWrap{ height: 60vh; min-height: 300px; }

      #instructions_div{
        margin-bottom: calc(env(safe-area-inset-bottom) + var(--page-pad));
      }

      .modal_flat_main{
        width: calc(100vw - 24px) !important;
        max-width: calc(100vw - 24px) !important;
        max-height: calc(100dvh - 24px) !important;
        overflow: hidden !important;
      }

      .modal_flat_inner{
        max-height: calc(100dvh - 24px) !important;
        overflow: auto !important;
        -webkit-overflow-scrolling: touch;
      }

      .modal_flat_buttons{
        margin-top: 16px !important;
        position: sticky;
        bottom: 0;
        background: #fff;
        padding: 12px 0 6px;
      }
    }

    /* ============================================================
       Large/tall screens: taller ABC input area
       ============================================================ */
    @media (min-width: 1100px) and (min-height: 800px){
      #cardInput{ min-height: 340px !important; }
      #cardInput .taWrap{ min-height: 240px; }
    }

    @media (min-width: 1100px) and (min-height: 950px){
      #cardInput{ min-height: 400px !important; }
      #cardInput .taWrap{ min-height: 300px; }
    }

    /* ============================================================
       Print
       ============================================================ */
    @media print{
      body{
        margin:0;
        padding:0;
        overflow:visible !important;
      }

      .app{
        height:auto;
        overflow:visible !important;
        padding-bottom:0 !important;
      }

      .main{ display:block !important; }

      .noprint,
      #cardControls,
      #cardInput,
      #cardStatus,
      #cardHelp{
        display:none !important;
      }

      .left{ display:none !important; }

      .right{
        width:100% !important;
        display:block !important;
      }

      .right > .card{
        border:none !important;
        padding:0 !important;
        background:transparent !important;
        overflow:visible !important;
      }

      .right > .card > .row{ display:none !important; }

      #out.chartsWrap,
      .chartsWrap{
        border:none !important;
        padding:0 !important;
        margin:0 !important;
        overflow:visible !important;
        background:transparent !important;
      }

      .chart{
        border:none !important;
        padding:0 !important;
        background:transparent !important;
        overflow:visible !important;
        break-inside: avoid;
        page-break-inside: avoid;
      }

      .chart pre{
        border:none !important;
        padding:0 !important;
        margin:0 !important;
        overflow:visible !important;
        background:transparent !important;
      }

      *::-webkit-scrollbar{ width:0 !important; height:0 !important; }

      body:not(.oneTunePerPagePrint) .chart{ margin:0 0 30pt 0 !important; }
      body:not(.oneTunePerPagePrint) .chart:last-child{ margin-bottom:0 !important; }

      body.oneTunePerPagePrint .chart{
        margin:0 !important;
        break-after:page;
        page-break-after:always;
      }

      body.oneTunePerPagePrint .chart:last-child{
        break-after:auto;
        page-break-after:auto;
      }

      .chart h3{
        font-size:24pt;
        margin:0 0 12pt 0;
      }
    }

    @media (min-width: 981px) and (max-width: 1099px){
      #cardInput{ min-height: 340px !important; }
      #cardInput .taWrap{ min-height: 240px; }
    }

    @media (max-width: 980px){
      /* keep input roughly consistent instead of 48vh */
      .taWrap{
        height: clamp(220px, 28vh, 300px);
        min-height: 220px;
      }

      /* charts can still be bigger than input, but not huge */
      .chartsWrap{
        height: clamp(320px, 45vh, 520px);
        min-height: 320px;
      }
    }

    @media (max-width: 720px){
      .taWrap{
        height: clamp(220px, 30vh, 300px);
        min-height: 220px;
      }

      .chartsWrap{
        height: clamp(340px, 50vh, 560px);
        min-height: 340px;
      }
    }

  </style>

  <style id="pageStyle">@page { size: letter portrait; margin: 0.5in; }</style>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>
  <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-VM0N9HL3MK');
  </script>

</head>

<body>
<div class="app">

  <div class="noprint">
    <h2>ABC Chord Chart Generator</h2>
    <p class="muted small" style="margin-top:6px">
      This tool can generate, copy, save, and print chord charts for one or more ABC tunes.<br/>
      Enter some ABC or open an ABC file, then click <strong>Generate Charts</strong>.
    </p>
  </div>

  <div class="main">

    <div class="left noprint">

      <div id="cardInput" class="card">
        <div class="row" style="gap:40px; align-items:center; justify-content:flex-start; flex-wrap:nowrap;">
          <h3>ABC Input</h3>

          <div class="row" style="gap:10px; align-items:center; justify-content:flex-start; flex-wrap:nowrap;">
            <span class="muted small" style="white-space:nowrap;">Open an ABC file:</span>
            <input id="fileIn" type="file" accept=".abc,.txt,text/plain" />
          </div>
        </div>

        <div class="taWrap" style="margin-top:10px;">
          <textarea id="abcIn" spellcheck="false" placeholder="Type or paste ABC tunes here..."></textarea>
        </div>
      </div>

      <div id="cardControls" class="card">
        <div class="row">
          <button id="generateBtn" class="primary" title="Generate chord charts from the ABC Input text">Generate Charts</button>
          <button id="copyBtn" title="Copy the generated chord charts to the clipboard" disabled>Copy</button>
          <button id="saveBtn" title="Save the generated chord charts to a file" disabled>Save</button>
          <button id="printBtn" title="Print the generated charts" disabled>Print</button>
          <button id="clearBtn" title="Clear input and output">Clear</button>
        </div>
      </div>

      <div id="cardStatus" class="card">
        <h3 class="card_label">Status</h3>
        <div id="status" class="status muted" style="margin-top:8px">Ready.</div>
      </div>

      <div class="card">
        
        <h3 class="card_label">Chord Chart Settings</h3>

        <div class="row" style="margin-top:10px;">
          <label for="slotWidth"><strong>Extra spacing (chars)</strong></label>
          <input id="slotWidth" type="number" min="0" max="8" value="1"
                 title="Extra spaces after barlines and chords" style="width:100px;" />
        </div>

        <div class="row" style="margin-top:10px;">
          <label for="appendRhythm"><strong>Append tune style (R:) to titles</strong></label>
          <select id="appendRhythm" title="Append the R: tag in parentheses after the tune title">
            <option value="1" selected>Yes</option>
            <option value="0">No</option>
          </select>
        </div>

        <div class="row" style="margin-top:10px;">
          <label for="emptyMeasurePlaceholder"><strong>Empty measure placeholder</strong></label>
          <select id="emptyMeasurePlaceholder"
                  title="Character to insert when a measure has no chord">
            <option value="">None</option>
            <option value="/" selected>&nbsp;&nbsp;&nbsp;/</option>
            <option value="%">&nbsp;&nbsp;&nbsp;%</option>
          </select>
        </div>

        <div class="row" style="margin-top:10px;">
          <label for="suppressPickup"><strong>Suppress pickups</strong></label>
          <select id="suppressPickup" title="If enabled, suppress leading pickup notes before the first barline (when no chords are present in the pickup)">
            <option value="0">No</option>
            <option value="1" selected>Yes</option>
          </select>

          <label for="pickupMaxNotes" style="margin-left:6px;"><strong>Max pickup notes</strong></label>
          <select id="pickupMaxNotes" title="If pickup suppression is enabled, treat the selected number of note-events or fewer before the first barline as a pickup">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
        </div>

      </div>

      <div class="card">
        <h3 class="card_label">Print Settings</h3>

        <div class="row">
          <label for="paperSize"><strong>Paper size</strong></label>
          <select id="paperSize" title="Paper size">
            <option value="letter">Letter</option>
            <option value="a4">A4</option>
            <option value="legal">Legal</option>
            <option value="tabloid">Tabloid</option>
          </select>

          <label for="orientation" style="margin-left:6px;"><strong>Orientation</strong></label>
          <select id="orientation" title="Orientation">
            <option value="portrait">Portrait</option>
            <option value="landscape">Landscape</option>
          </select>
        </div>

        <div class="row" style="margin-top:10px;">
          <label for="printTitleSize"><strong>Tune title font size</strong></label>
          <input id="printTitleSize"
                 type="number"
                 min="12"
                 max="72"
                 value="24"
                 title="Printed tune title font size"
                 style="width:100px;" />

          <label for="printFontSize"><strong>Tune chords font size</strong></label>
          <input id="printFontSize" type="number" min="12" max="72" value="20" title="Printed tune chords font size" style="width:100px;" />

        </div>

        <div class="row" style="margin-top:10px;">
          <label for="oneTunePerPage"><strong>Print one tune/page</strong></label>
          <select id="oneTunePerPage" title="Force each tune to start on a new printed page">
            <option value="0" selected>No</option>
            <option value="1" >Yes</option>
          </select>
        </div>
      </div>

    </div>

    <div class="right">
      <div class="card" style="flex:1; display:flex; flex-direction:column; min-height:0;">
        <div class="row noprint" style="justify-content:space-between;">
          <h3>Chord Charts</h3>
        </div>
        <div id="out" class="chartsWrap" style="margin-top:10px;"></div>
      </div>
    </div>

  </div>
</div>

<div id="cardHelp" class="card noprint">
  <button id="btnHelp" title="Show instructions">Instructions</button>
</div>

<script>

/* ============================================================
   Utilities
   ============================================================ */

// Are we on iOS?
//
function isIOS() {
  if (/iPad|iPhone|iPod/.test(navigator.platform)) {
    return true;
  } else {
    return navigator.maxTouchPoints &&
      navigator.maxTouchPoints > 2 &&
      /MacIntel/.test(navigator.platform);
  }
}

const gIsIOS = isIOS();

//console.log("gIsIOS: "+gIsIOS);

//
// Is local storage available?
//
let gLocalStorageAvailable = localStorageIsUsable();

//console.log("gLocalStorageAvailable: "+gLocalStorageAvailable);

/* ============================================================
   Settings persistence (localStorage) — SETTINGS ONLY (no ABC text)
   Add this whole block anywhere after your "$" helper is defined.
   Then add the small wire-up calls noted at the bottom of this block.
   ============================================================ */

const LS_KEY = "abcChordChartGenerator_settings_v1";

function localStorageIsUsable() {
  try {
    if (!window.localStorage) return false;
    const k = "__ls_test__" + String(Date.now());
    localStorage.setItem(k, "1");
    localStorage.removeItem(k);
    return true;
  } catch {
    return false;
  }
}

function getUIStateForSave_SettingsOnly() {
  // IMPORTANT: do NOT include abcIn value or file input (cannot be restored anyway)
  return {
    v: 1,

    // Chord Chart Settings
    slotWidth: $("slotWidth") ? $("slotWidth").value : "1",
    appendRhythm: $("appendRhythm") ? $("appendRhythm").value : "1",
    emptyMeasurePlaceholder: $("emptyMeasurePlaceholder") ? $("emptyMeasurePlaceholder").value : "/",
    suppressPickup: $("suppressPickup") ? $("suppressPickup").value : "1",
    pickupMaxNotes: $("pickupMaxNotes") ? $("pickupMaxNotes").value : "3",

    // Print Settings
    paperSize: $("paperSize") ? $("paperSize").value : "letter",
    orientation: $("orientation") ? $("orientation").value : "portrait",
    printTitleSize: $("printTitleSize") ? $("printTitleSize").value : "24",
    printFontSize: $("printFontSize") ? $("printFontSize").value : "20",
    oneTunePerPage: $("oneTunePerPage") ? $("oneTunePerPage").value : "0",

  };
}

function applyUIStateFromObj_SettingsOnly(st) {
  if (!st || typeof st !== "object") return;

  // Chord Chart Settings
  if ($("slotWidth") && st.slotWidth != null) $("slotWidth").value = String(st.slotWidth);
  if ($("appendRhythm") && st.appendRhythm != null) $("appendRhythm").value = String(st.appendRhythm);
  if ($("emptyMeasurePlaceholder") && st.emptyMeasurePlaceholder != null) $("emptyMeasurePlaceholder").value = String(st.emptyMeasurePlaceholder);
  if ($("suppressPickup") && st.suppressPickup != null) $("suppressPickup").value = String(st.suppressPickup);
  if ($("pickupMaxNotes") && st.pickupMaxNotes != null) $("pickupMaxNotes").value = String(st.pickupMaxNotes);

  // Print Settings
  if ($("paperSize") && st.paperSize != null) $("paperSize").value = String(st.paperSize);
  if ($("orientation") && st.orientation != null) $("orientation").value = String(st.orientation);
  if ($("printTitleSize") && st.printTitleSize != null) $("printTitleSize").value = String(st.printTitleSize);
  if ($("printFontSize") && st.printFontSize != null) $("printFontSize").value = String(st.printFontSize);
  if ($("oneTunePerPage") && st.oneTunePerPage != null) $("oneTunePerPage").value = String(st.oneTunePerPage);

}

function saveUIStateToLocalStorage_SettingsOnly() {
  if (!localStorageIsUsable()) return;
  try {
    const st = getUIStateForSave_SettingsOnly();
    localStorage.setItem(LS_KEY, JSON.stringify(st));
  } catch {
    // ignore
  }
}

function loadUIStateFromLocalStorage_SettingsOnly() {
  if (!localStorageIsUsable()) return false;
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const st = JSON.parse(raw);
    if (!st || typeof st !== "object") return false;
    applyUIStateFromObj_SettingsOnly(st);
    return true;
  } catch {
    return false;
  }
}

function clearSavedUIStateFromLocalStorage_SettingsOnly() {
  if (!localStorageIsUsable()) return;
  try {
    localStorage.removeItem(LS_KEY);
  } catch {
    // ignore
  }
}

// Debounced saver so multiple changes don't spam localStorage
let _saveTimer_SettingsOnly = null;
function saveStateSoon_SettingsOnly() {
  if (!localStorageIsUsable()) return;
  if (_saveTimer_SettingsOnly) clearTimeout(_saveTimer_SettingsOnly);
  _saveTimer_SettingsOnly = setTimeout(() => {
    _saveTimer_SettingsOnly = null;
    saveUIStateToLocalStorage_SettingsOnly();
  }, 250);
}

/* ============================================================
   Wire-up helpers
   Call these from inside wireUp()
   ============================================================ */

// Call once during init (after you set your default control values)
function restoreSavedSettingsIntoUI_SettingsOnly() {
  // Returns true if something was restored
  return loadUIStateFromLocalStorage_SettingsOnly();
}

// Call once after all event listeners are registered
function enableAutoSaveForSettings_SettingsOnly() {
  // Save when any SETTING changes. (Do NOT bind to abcIn.)
  const ids = [
    "slotWidth",
    "appendRhythm",
    "emptyMeasurePlaceholder",
    "suppressPickup",
    "pickupMaxNotes",
    "paperSize",
    "orientation",
    "printTitleSize",
    "printFontSize",
    "oneTunePerPage"
  ];

  ids.forEach(id => {
    const el = $(id);
    if (!el) return;
    el.addEventListener("change", saveStateSoon_SettingsOnly);
    // Inputs like number fields can also be saved on input for responsiveness:
    if (el.tagName === "INPUT") el.addEventListener("input", saveStateSoon_SettingsOnly);
  });

}

const $ = (id) => document.getElementById(id);

function setStatus(msg, isError=false) {
  const el = $("status");
  if (!el) return;
  el.textContent = String(msg || "");
  el.classList.toggle("errorText", !!isError);
  el.scrollTop = el.scrollHeight;
}

//
// Send gtag analytics
//
function sendGoogleAnalytics(theCategory, theAction, theLabel) {

  //console.log("sendGoogleAnalytics category: "+theCategory+" action: "+theAction+" label: "+theLabel);

  // Don't send analytics if offline
  if (!navigator.onLine) {
    //console.log("sendGoogleAnalytics - Offline: Not sending info ")
    return;
  }

  // Don't send analytics on iOS Safari
  if (gIsIOS) {
    return;
  }

  // Don't send analytics if local storage not available
  if (!gLocalStorageAvailable) {
    return;
  }

  if (typeof gtag !== "undefined") {

    if ((gtag) && (gtag instanceof Function)) {

      if (!theLabel) {
        theLabel = "none";
      }

      gtag('event', 'chords_' + theCategory + "_" + theAction, {
          event_category: theCategory,
          event_action: theAction,
          event_label: theLabel
        });
    }
  }
}

/* ============================================================
   Default tune with chords
   ============================================================ */
const DEFAULT_ABC = `%
% Example ABC tunes with chords
%
X: 1
T: The Kesh
C: Traditional
R: Jig
M: 6/8
L: 1/8
Q: 3/8=120
K: Gmaj
|:"G"GAG GAB|"D"ABA ABd|"G"edd gdd|"C"edB "D"dBA|
"G"GAG GAB|"D"ABA ABd|"G"edd gdB|"D"AGF "G"G3:|
|:"G"BAB dBd|"C"ege "D"dBA|"G"BAB dBG|"D"ABA AGA|
"G"BAB dBd|"C"ege "G"dBd|"C"gfg "D"aga|"G"bgf g3:|

X: 2
T: Cooley's
C: Traditional
R: Reel
M: 4/4
L: 1/8
Q: 1/2=90
K: Edor
|:"Em"EBBA B2 EB|B2 AB dBAG|"D"F/E/D AD BDAD|F/E/D AD BAGF|
"Em"EBBA B2 EB|B2 AB defg|"D"afge dBAF|1 DEFD "Em"E3D:|2 DEFD "Em"E2gf||
|:"Em"eB (3BBB eBgf|eBB2 gedB|"D"A/A/A FA DAFA|A/A/A FA defg|
"Em"eB (3BBB eBgf|eBBB defg|"D"afge dBAF|1 DEFD "Em"E2gf:|2 DEFD "Em"E4|]

X: 3
T: Alexander's
C: Traditional
R: Hornpipe
M: 4/4
L: 1/8
Q: 1/2=80
K: Dmaj
|:"D"dAFA DFAd|fdcd Adef|"G"g2 ge "D"fdcd|"A"(3efe (3dcB A2 (3gfe|
"D"dAFA DFAd|fdcd Adef|"G"g2 ge "D"fdcd|1 "A"(3efe dc"D"d2 (3gfe:|2 "A"(3efe dc"D"d2 AG||
|:"D"FAdA FAdA|"G"GBdB GBdB|"A"Acec Acec|"D"dfaf "A"(3gfe (3dAG|
"D"FAdA FAdA|"G"GBdB GBdB|"A"Acef gecd|1 (3efe dc"D"d2AG:|2 (3efe dc"D"d4|]`;

/* ============================================================
   Save chord chart state
   ============================================================ */
let gLoadedFileName = "";
let gSavedChordFileName = "";

/* ============================================================
   Print auto-fit state
   ============================================================ */
let gRequestedPrintPt = 20;

/* ---------------------------------
   Filename helpers
---------------------------------- */
function stripExt(name) {
  const s = String(name || "").trim();
  const idx = s.lastIndexOf(".");
  return (idx > 0) ? s.slice(0, idx) : s;
}
function ensureTxtExt(name) {
  const s = String(name || "").trim();
  if (!s) return s;
  return /\.[A-Za-z0-9]{1,8}$/.test(s) ? s : (s + ".txt");
}
function sanitizeForDownloadName(s) {
  return String(s || "")
    .replace(/[\u0000-\u001F\u007F]/g, "")
    .replace(/[\\\/:*?"<>|]/g, "_")
    .replace(/\s+/g, " ")
    .trim();
}
function validateFileName(name) {
  const s = sanitizeForDownloadName(name);
  if (!s) return { ok:false, msg:"Please enter a file name." };
  if (s === "." || s === "..") return { ok:false, msg:"Please enter a valid file name." };
  if (s.length > 120) return { ok:false, msg:"File name is too long. Please use 120 characters or fewer." };
  return { ok:true, value:s };
}
function computeDefaultChordFileName() {
  if (gSavedChordFileName) return gSavedChordFileName;
  if (gLoadedFileName) {
    const base = stripExt(gLoadedFileName);
    return `${base}_chords.txt`;
  }
  return "chords.txt";
}
function buildRawChordTextForSave() {
  const out = $("out");
  if (!out) return "";
  const sections = Array.from(out.querySelectorAll("section.chart"));
  if (!sections.length) return "";

  const parts = [];
  for (const sec of sections) {
    const h3 = sec.querySelector("h3");
    const pre = sec.querySelector("pre");
    const title = h3 ? h3.textContent : "";
    const text  = pre ? pre.textContent : "";
    if (title) parts.push(title);
    if (text)  parts.push(text);
    parts.push("");
  }
  return parts.join("\n").replace(/\s+$/g, "") + "\n";
}
function downloadTextFile(filename, text) {
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/* ---------------------------------
   Split ABC into tunes (by X:)
---------------------------------- */
function splitAbcIntoTunes(abcText) {
  const s = (abcText || "").replace(/\r\n?/g, "\n");
  const starts = [];
  const re = /^X:.*$/gm;
  let m;
  while ((m = re.exec(s)) !== null) starts.push(m.index);
  if (starts.length === 0) return [];
  const tunes = [];
  for (let i = 0; i < starts.length; i++) {
    const a = starts[i];
    const b = (i + 1 < starts.length) ? starts[i + 1] : s.length;
    const block = s.slice(a, b).trim();
    if (block) tunes.push(block);
  }
  return tunes;
}

function getHeaderValue(block, tag) {
  const re = new RegExp("^" + tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + ":(.*)$", "m");
  const m = block.match(re);
  return m ? m[1].trim() : "";
}

function getTuneBody(block) {
  const lines = block.replace(/\r\n?/g, "\n").split("\n");
  let kIndex = -1;

  for (let i = 0; i < lines.length; i++) {
    if (/^K:/.test(lines[i])) { kIndex = i; break; }
  }

  if (kIndex === -1) {
    return lines
      .filter(l => l.trim() !== "")
      .filter(l => !/^[A-Za-z+]:/.test(l))
      .filter(l => !/^\s*w:/.test(l))
      .join("\n");
  }

  return lines.slice(kIndex + 1).join("\n");
}

function segmentHasRealChordQuotes(segment) {
  const s = String(segment || "");

  const re = /"([^"]*)"/g;
  let m;
  while ((m = re.exec(s)) !== null) {
    const chord = (m[1] || "").trim();
    if (!chord) continue;
    if (/^[\^_<>@]/.test(chord)) continue;
    return true;
  }
  return false;
}

function countNoteEventsInAbcFragment(fragment) {
  let s = String(fragment || "");

  // Remove chord quotes
  s = s.replace(/"[^"]*"/g, "");

  // Remove grace notes { ... }
  s = s.replace(/\{[^}]*\}/g, "");

  // Remove !decorations!
  s = s.replace(/![^!]*!/g, "");

  // Remove bracket groups [..] conservatively (often note-chords)
  // If you WANT to count notes inside [CEG], delete this line.
  s = s.replace(/\[[^\]]*\]/g, " ");

  // Count note/rest tokens (A-G a-g, rests z/x)
  const re = /(?:\^+|_+|=+)?([A-Ga-gzZxX])/g;

  let count = 0;
  while (re.exec(s) !== null) count++;
  return count;
}

function parseMusicLineToBarsAndChords(
  line,
  extraSpace = 0,
  emptyPlaceholder = "/",
  pickupHeuristic = null
) {
  const s = String(line || "");

  const boundaries = [];
  const contents = [];

  const extra = Math.max(0, Math.min(40, parseInt(extraSpace, 10) || 0));
  const intraChordSep = " ".repeat(1 + extra);

  function extractChordText(segment) {
    const out = [];
    const re = /"([^"]*)"/g;
    let m;

    while ((m = re.exec(segment)) !== null) {
      let chord = (m[1] || "").trim();
      if (!chord) continue;
      if (/^[\^_<>@]/.test(chord)) continue;
      out.push(chord);
    }

    if (out.length === 0) return (emptyPlaceholder ?? "");
    return out.join(intraChordSep);
  }

  function readEndingAt(idx) {
    const a = s[idx] || "";
    const b = s[idx + 1] || "";
    if (a === "1" || a === "2") return { suffix: a, len: 1 };
    if (a === "[" && (b === "1" || b === "2")) return { suffix: "[" + b, len: 2 };
    return { suffix: "", len: 0 };
  }

  // Tokenize barlines and repeat markers with positions
  const tokens = [];
  let i = 0;

  while (i < s.length) {
    const ch = s[i];

    if (ch === "[" && (s[i + 1] === "1" || s[i + 1] === "2")) {
      tokens.push({ token: "[" + s[i + 1], pos: i, srcLen: 2 });
      i += 2;
      continue;
    }

    if (ch === "|") {
      if (s[i + 1] === "]") { tokens.push({ token: "|]", pos: i, srcLen: 2 }); i += 2; continue; }
      if (s[i + 1] === ":") { tokens.push({ token: "|:", pos: i, srcLen: 2 }); i += 2; continue; }
      if (s[i + 1] === "|") { tokens.push({ token: "||", pos: i, srcLen: 2 }); i += 2; continue; }

      const end = readEndingAt(i + 1);
      let tok = "|";
      let srcLen = 1;

      if (end.suffix) {
        tok = "|" + end.suffix.replace("[", "");
        srcLen = 1 + end.len;
      }

      tokens.push({ token: tok, pos: i, srcLen });
      i += srcLen;
      continue;
    }

    if (ch === ":" && s[i + 1] === "|") {
      const end = readEndingAt(i + 2);
      let tok = ":|";
      let srcLen = 2;

      if (end.suffix) {
        tok = ":|" + end.suffix.replace("[", "");
        srcLen = 2 + end.len;
      }

      tokens.push({ token: tok, pos: i, srcLen });
      i += srcLen;
      continue;
    }

    i += 1;
  }

  // Track whether we suppressed a pickup on THIS line
  let pickupWasSuppressed = false;

  // NEW: if we suppress a pickup on a line that is ONLY "|:pickup|",
  // carry the |: forward to the next real line.
  let carryStartRepeat = false;

  // No bar tokens:
  if (!tokens.length) {
    const c = extractChordText(s);
    if (!c) return { boundaries: [], contents: [], pickupWasSuppressed, carryStartRepeat };

    boundaries.push("|");
    contents.push(c);
    boundaries.push("");
    return { boundaries, contents, pickupWasSuppressed, carryStartRepeat };
  }

  // Build measures by slicing between token positions
  let cursor = 0;
  const firstTok = tokens[0];

  // If line starts with a start-repeat (|:), allow pickup suppression
  // on the segment *after* the |: and before the next barline.
  if (firstTok.pos === 0) {
    boundaries.push(firstTok.token);
    cursor = firstTok.pos + firstTok.srcLen;

    if (
      pickupHeuristic &&
      pickupHeuristic.enabled &&
      firstTok.token === "|:" &&
      tokens.length >= 2
    ) {
      const nextTok = tokens[1];
      const pickupSeg = s.slice(cursor, nextTok.pos);

      const maxNotes = Math.max(1, Math.min(4, parseInt(pickupHeuristic.maxNotes, 10) || 3));
      const hasChord = segmentHasRealChordQuotes(pickupSeg);
      const nNotes = countNoteEventsInAbcFragment(pickupSeg);

      if (!hasChord && nNotes > 0 && nNotes <= maxNotes) {
        pickupWasSuppressed = true;

        // If line is just "|:pickup|" (no real content after that barline),
        // carry the |: forward and skip this line entirely.
        const tailAfterPickupBar = s.slice(nextTok.pos + nextTok.srcLen);
        if (/^[\s\\$]*$/.test(tailAfterPickupBar)) {
          carryStartRepeat = true;
          return { boundaries: [], contents: [], pickupWasSuppressed, carryStartRepeat };
        }

        // Otherwise: drop the pickup segment AND drop the barline that ended the pickup.
        // Start consuming measures after that barline.
        cursor = nextTok.pos + nextTok.srcLen;

        for (let t = 2; t < tokens.length; t++) {
          const cur = tokens[t];
          contents.push(extractChordText(s.slice(cursor, cur.pos)));
          boundaries.push(cur.token);
          cursor = cur.pos + cur.srcLen;
        }

        const tailSeg = s.slice(cursor);
        if (tailSeg.trim().length > 0) {
          contents.push(extractChordText(tailSeg));
          boundaries.push("");
        }

        return { boundaries, contents, pickupWasSuppressed, carryStartRepeat };
      }
    }
  } else {
    const leadingSeg = s.slice(0, firstTok.pos);

    // Optional: suppress pickup if:
    // - enabled
    // - pickup has NO real chord quotes
    // - note-events <= maxNotes
    let suppressPickup = false;

    if (pickupHeuristic && pickupHeuristic.enabled) {
      const maxNotes = Math.max(1, Math.min(4, parseInt(pickupHeuristic.maxNotes, 10) || 3));
      const hasChord = segmentHasRealChordQuotes(leadingSeg);
      const nNotes = countNoteEventsInAbcFragment(leadingSeg);

      if (!hasChord && nNotes > 0 && nNotes <= maxNotes) {
        suppressPickup = true;
      }
    }

    if (suppressPickup) {
      pickupWasSuppressed = true;

      // If this line is just "pickup |" (i.e., no real content after the barline),
      // skip the entire line so it doesn't become an empty measure in the chart.
      const tail = s.slice(firstTok.pos + firstTok.srcLen);
      if (/^[\s\\$]*$/.test(tail)) {
        return { boundaries: [], contents: [], pickupWasSuppressed, carryStartRepeat };
      }

      boundaries.push(firstTok.token);
      cursor = firstTok.pos + firstTok.srcLen;
    } else {
      boundaries.push("|");
      contents.push(extractChordText(leadingSeg));
      boundaries.push(firstTok.token);
      cursor = firstTok.pos + firstTok.srcLen;
    }
  }

  for (let t = 1; t < tokens.length; t++) {
    const cur = tokens[t];
    contents.push(extractChordText(s.slice(cursor, cur.pos)));
    boundaries.push(cur.token);
    cursor = cur.pos + cur.srcLen;
  }

  const tailSeg = s.slice(cursor);
  if (tailSeg.trim().length > 0) {
    contents.push(extractChordText(tailSeg));
    boundaries.push("");
  }

  return { boundaries, contents, pickupWasSuppressed, carryStartRepeat };
}

function renderAlignedText(
  abcBody,
  {
    rightPadSpaces = 2,
    extraSpace = 0,
    emptyPlaceholder = "/",
    pickupHeuristic = null,
    pickupOnlyAtTuneStart = false
  } = {}
) {
  const srcLines = String(abcBody || "").split(/\r?\n/);
  const parsedLines = [];

  let inBeginTextBlock = false;

  // "Tune start" here means: we haven't emitted any real (non-blank) parsed line yet.
  let atTuneStart = true;

  // NEW: if we suppressed a pickup on a line that was only "|:pickup|",
  // carry the |: forward to the next real line.
  let pendingStartRepeat = false;

  for (const srcLine of srcLines) {
    let rawLine = String(srcLine || "");

    if (/^\s*%%begintext\b/i.test(rawLine)) { inBeginTextBlock = true; continue; }
    if (/^\s*%%endtext\b/i.test(rawLine))   { inBeginTextBlock = false; continue; }
    if (inBeginTextBlock) continue;

    if (!rawLine.trim()) {
      parsedLines.push({ isBlank: true, boundaries: [], contents: [] });
      continue;
    }

    if (/^\s*%/.test(rawLine)) continue;

    rawLine = rawLine.replace(/\s*[\\$]\s*$/, "");
    const line = rawLine.replace(/%.*$/, "");
    const trimmed = line.trim();
    if (!trimmed) continue;

    if (/^[A-Za-z]:/.test(trimmed)) continue;

    const hasBar = /[|:]/.test(line);
    const hasQuote = line.indexOf('"') !== -1;
    if (!hasBar && !hasQuote) continue;

    const startsWithStartRepeat = /^\s*\|:/.test(trimmed);

    // If pickupOnlyAtTuneStart is true:
    // - allow pickup suppression at tune start, AND also after a start-repeat "|:"
    //   (this is what fixes your "|:gf|" case).
    // If pickupOnlyAtTuneStart is false:
    // - allow anywhere (legacy/alternate behavior).
    const allowPickup =
      pickupHeuristic &&
      pickupHeuristic.enabled &&
      (pickupOnlyAtTuneStart ? (atTuneStart || startsWithStartRepeat) : true);

    const { boundaries, contents, pickupWasSuppressed, carryStartRepeat } =
      parseMusicLineToBarsAndChords(
        line,
        extraSpace,
        emptyPlaceholder,
        allowPickup ? pickupHeuristic : null
      );

    // If we suppressed a "|:pickup|" line, carry |: to the next real line
    if (carryStartRepeat) {
      pendingStartRepeat = true;
    }

    if (!boundaries.length && !contents.length) continue;

    // Apply pending |: to the next real line we emit
    if (pendingStartRepeat && boundaries && boundaries.length) {
      if (String(boundaries[0] || "") === "|") boundaries[0] = "|:";
      else if (String(boundaries[0] || "") === "") boundaries[0] = "|:";
      pendingStartRepeat = false;
    }

    parsedLines.push({ isBlank: false, boundaries, contents });

    // Once we emit the first real line of content, we're no longer at tune start
    atTuneStart = false;
  }

  if (!parsedLines.length) return "";

  let maxMeasures = 0;
  let maxBoundaries = 0;

  for (const pl of parsedLines) {
    if (pl.isBlank) continue;
    maxMeasures = Math.max(maxMeasures, pl.contents.length);
    maxBoundaries = Math.max(maxBoundaries, pl.boundaries.length);
  }

  const boundaryWidth = new Array(Math.max(1, maxBoundaries)).fill(0);
  const contentWidth  = new Array(Math.max(1, maxMeasures)).fill(0);

  const padEnd = (s, w) => String(s ?? "").padEnd(w, " ");
  const normTok = (t) => String(t ?? "");

  const extra = Math.max(0, Math.min(40, parseInt(extraSpace, 10) || 0));
  const endPad = " ".repeat(Math.max(0, parseInt(rightPadSpaces, 10) || 0));

  for (const pl of parsedLines) {
    if (pl.isBlank) continue;

    for (let k = 0; k < pl.boundaries.length; k++) {
      const tok = normTok(pl.boundaries[k]);
      boundaryWidth[k] = Math.max(boundaryWidth[k], tok.length);
    }
    for (let j = 0; j < pl.contents.length; j++) {
      const c = String(pl.contents[j] ?? "");
      contentWidth[j] = Math.max(contentWidth[j], c.length);
    }
  }

  const lastBoundaryHasAnyToken = (() => {
    const last = maxMeasures;
    for (const pl of parsedLines) {
      if (pl.isBlank) continue;
      if ((pl.boundaries[last] || "").trim().length) return true;
    }
    return false;
  })();

  for (let k = 0; k < boundaryWidth.length; k++) {
    const isLast = (k === maxMeasures);
    if (!isLast) boundaryWidth[k] += extra;
    else if (lastBoundaryHasAnyToken) boundaryWidth[k] += extra;
  }
  for (let j = 0; j < contentWidth.length; j++) {
    contentWidth[j] += extra;
  }

  const outLines = [];

  for (const pl of parsedLines) {
    if (pl.isBlank) { outLines.push(""); continue; }

    const b = pl.boundaries.slice();
    const c = pl.contents.slice();

    while (b.length < (c.length + 1)) b.push("");
    while (c.length < maxMeasures) c.push("");
    while (b.length < (maxMeasures + 1)) b.push("");

    let lineOut = "";
    lineOut += padEnd(normTok(b[0]), boundaryWidth[0] || 0);

    for (let j = 0; j < maxMeasures; j++) {
      const cw = contentWidth[j] || 0;
      lineOut += " " + padEnd(c[j], cw) + " ";
      const bw = boundaryWidth[j + 1] || 0;
      lineOut += padEnd(normTok(b[j + 1]), bw);
    }

    outLines.push(lineOut.replace(/\s+$/g, "") + endPad);
  }

  return outLines.join("\n");
}

/* ---------------------------------
   Print settings (page size/orientation + 1/page toggle)
---------------------------------- */
function setPageStyle(paperSize, orientation) {
  $("pageStyle").textContent =
    `@page { size: ${paperSize} ${orientation}; margin: 0.5in; }`;
}

function setPrintFontSize(bodyPt, titlePt) {
  gRequestedPrintPt = parseInt(bodyPt, 10) || 20;

  const safeBody  = Math.max(12, Math.min(40, parseInt(bodyPt, 10) || 20));
  const safeTitle = Math.max(16, Math.min(60, parseInt(titlePt, 10) || 24));

  let el = document.getElementById("printFontOverride");
  if (!el) {
    el = document.createElement("style");
    el.id = "printFontOverride";
    document.head.appendChild(el);
  }

  el.textContent = `
    @media print{
      .chart h3 { font-size: ${safeTitle}pt !important; }
      .chart pre{ font-size: ${safeBody}pt !important; }
    }
  `;
}

function setOneTunePerPagePrint(enabled) {
  document.body.classList.toggle("oneTunePerPagePrint", !!enabled);
}

/* ============================================================
   Share-link decode (LZW or Deflate)
   ============================================================ */
function base64UrlToUint8Array(b64url) {
  let s = String(b64url || "").replace(/-/g, "+").replace(/_/g, "/");
  const pad = s.length % 4;
  if (pad) s += "=".repeat(4 - pad);
  const bin = atob(s);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
  return bytes;
}

function tryDecodeShareLinkIntoEditor() {
  const params = new URLSearchParams(location.search);
  const lzw = params.get("lzw");
  const def = params.get("def");

  if (!lzw && !def) return false;

  function setLoadedStatus(sourceLabel, abcText) {
    const tunes = splitAbcIntoTunes(abcText);
    const nTunes = tunes.length;

    if (nTunes === 0) {
      setStatus(`Loaded ${sourceLabel}. No tunes found.`, true);
    } else if (nTunes === 1) {
      setStatus(`Loaded ${sourceLabel}. Found 1 tune.`);
    } else {
      setStatus(`Loaded ${sourceLabel}. Found ${nTunes} tunes.`);
    }
  }

  try {
    if (lzw) {
      if (!window.LZString || !LZString.decompressFromEncodedURIComponent) {
        setStatus("Share link has lzw=..., but LZString isn't loaded.", true);
        return false;
      }
      const abc = LZString.decompressFromEncodedURIComponent(lzw);
      if (!abc) {
        setStatus("Unable to decode lzw= share link.", true);
        return false;
      }
      $("abcIn").value = abc;
      setLoadedStatus("ABC from the share link", abc);
      return true;
    }

    if (def) {
      if (!window.pako) {
        setStatus("Share link has def=..., but pako isn't loaded.", true);
        return false;
      }
      const bytes = base64UrlToUint8Array(def);
      const inflated = pako.inflate(bytes);
      const abc = new TextDecoder("utf-8").decode(inflated);
      if (!abc) {
        setStatus("Unable to decode share link.", true);
        return false;
      }
      $("abcIn").value = abc;
      setLoadedStatus("ABC from the share link", abc);
      return true;
    }
  } catch (e) {
    setStatus("Error decoding share link: " + (e && e.message ? e.message : String(e)), true);
  }

  return false;
}

/* ============================================================
   Save Chord Chart (DayPilot prompt)
   ============================================================ */
async function promptForSaveFileName(defaultName) {
  if (!window.DayPilot || !DayPilot.Modal || typeof DayPilot.Modal.prompt !== "function") {
    const v = window.prompt("Save chord chart as:", defaultName || "");
    return (v === null) ? null : String(v);
  }

  if (typeof DayPilot.Modal.prompt === "function") {
    const res = await DayPilot.Modal.prompt("Save chord chart as:", defaultName || "", {
      theme: "modal_flat",
      top: 80,
      scrollWithPage: false
    });
    if (!res || res.canceled) return null;
    return String(res.result || "");
  }

  const form = [{ name: "File name", id: "name", type: "text", value: defaultName || "" }];
  const res2 = await DayPilot.Modal.form(form, { name: defaultName || "" }, {
    theme: "modal_flat",
    top: 80,
    scrollWithPage: false
  });
  if (!res2 || res2.canceled) return null;
  return String(res2.result && res2.result.name ? res2.result.name : "");
}

async function saveChordChart() {
  if (!$("out").children.length) {
    generateCharts();
  }
  if (!$("out").children.length) {
    setStatus("Nothing to save. Generate chord charts first.", true);
    return;
  }

  const raw = buildRawChordTextForSave();
  if (!raw.trim()) {
    setStatus("Nothing to save. Generate chord charts first.", true);
    return;
  }

  const suggested = computeDefaultChordFileName();
  let name = await promptForSaveFileName(suggested);
  if (name === null) return;

  name = sanitizeForDownloadName(name);
  name = ensureTxtExt(name);

  const v = validateFileName(name);
  if (!v.ok) {

    if (!window.DayPilot || !DayPilot.Modal || typeof DayPilot.Modal.alert !== "function") {
      alert(v.msg);
      return;
    }

    DayPilot.Modal.alert(v.msg, { theme:"modal_flat", top: 120, scrollWithPage:false });
    return;
  }

  const finalName = v.value;
  downloadTextFile(finalName, raw);
  gSavedChordFileName = finalName;
  setStatus(`Saved "${finalName}".`);
}

function buildPrintHtml({ paperSize, orientation, requestedPt, requestedTitlePt, oneTunePerPage }) {
  const safeSize   = String(paperSize || "letter");
  const safeOrient = String(orientation || "portrait");
  const safePt     = Math.max(10, Math.min(72, parseInt(requestedPt, 10) || 20));
  const safeTitle  = Math.max(12, Math.min(72, parseInt(requestedTitlePt, 10) || 24));

  return `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Print</title>
<style>
  @page { size: ${safeSize} ${safeOrient}; }

  html, body { margin:0; padding:0; }
  body { color:#000; -webkit-print-color-adjust: exact; print-color-adjust: exact; }

  /* One tune per page */
  body.oneTunePerPage .chart { margin:0; break-after: page; page-break-after: always; }
  body.oneTunePerPage .chart:last-child { break-after: auto; page-break-after: auto; }

  /* Continuous mode spacing */
  body:not(.oneTunePerPage) .chart { margin: 0 0 30pt 0; }
  body:not(.oneTunePerPage) .chart:last-child { margin-bottom: 0; }

  .chart { break-inside: avoid; page-break-inside: avoid; }

  h3{
    font: 700 ${safeTitle}pt system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    margin: 0 0 12pt 0;
  }

  pre{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size: ${safePt}pt; /* starting point; JS will fit PER-PRE */
    line-height: 1.35;
    margin: 0;
    white-space: pre;
  }

  /* Print-width probe (must have non-zero size) */
  #probeWrap{
    position: relative;
    width: 100%;
    height: 1px;
    overflow: hidden;
    visibility: hidden;
  }
  #probe{
    width: 100%;
    height: 1px;
    display: block;
  }

  /* Offscreen measurer */
  #measurer{
    position: fixed;
    left: -100000px;
    top: -100000px;
    white-space: pre;
    visibility: hidden;
    pointer-events: none;
  }

  /* Diagnostics overlay */
  body.showDiag #diag{ display:block; }
  #diag{
    display:none;
    position: fixed;
    left: 8px;
    bottom: 8px;
    z-index: 999999;
    background: rgba(255,255,200,0.95);
    color: #000;
    border: 1px solid rgba(0,0,0,0.35);
    border-radius: 8px;
    padding: 10px 12px;
    font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    max-width: min(92vw, 760px);
    white-space: pre-wrap;
  }

  * { overflow: visible !important; }
</style>
</head>

<body class="${oneTunePerPage ? "oneTunePerPage" : ""}">
  <div id="probeWrap"><div id="probe"></div></div>
  <div id="printRoot"></div>
  <div id="measurer"></div>
  <div id="diag"></div>

<script>
(function(){
  const DIAG_DEFAULT_ON = false;
  let _requestedPt = ${safePt};

  function diag(msg){
    try{
      const el = document.getElementById("diag");
      if (el) el.textContent = String(msg || "");
      console.log("[PRINT_DIAG]", msg);
    }catch(e){}
  }

  function rtrimLine(s){ return String(s || "").replace(/[ \\t]+$/g, ""); }

  function trimAllPreTrailingSpaces(){
    document.querySelectorAll("pre").forEach(pre => {
      const lines = (pre.textContent || "").split("\\n").map(rtrimLine);
      pre.textContent = lines.join("\\n");
    });
  }

  function measureUsableWidthPx(){
    const probe = document.getElementById("probe");
    if (probe){
      const r = probe.getBoundingClientRect();
      if (r && r.width && r.width > 1){
        return Math.max(0, Math.floor(r.width - 24)); // small safety
      }
    }
    const cw = document.documentElement ? document.documentElement.clientWidth : 0;
    return Math.max(0, Math.floor(cw - 24));
  }

  function getMaxLineTextTrimmed(text){
    const lines = String(text || "").split("\\n");
    let max = "";
    for (const line of lines){
      const t = rtrimLine(line);
      if (t.length > max.length) max = t;
    }
    return max;
  }

  function measureLineWidthPx(pre, line){
    const meas = document.getElementById("measurer");
    if (!meas) return 0;

    const cs = getComputedStyle(pre);
    meas.style.fontFamily = cs.fontFamily;
    meas.style.fontSize = cs.fontSize;
    meas.style.fontWeight = cs.fontWeight;
    meas.style.fontStyle = cs.fontStyle;
    meas.style.letterSpacing = cs.letterSpacing;
    meas.style.fontVariant = cs.fontVariant;

    meas.textContent = line || "";
    return meas.getBoundingClientRect().width || 0;
  }

  function setPreFontSizePt(pre, pt){
    pre.style.fontSize = pt + "pt";
  }

  function fitEachPreIndependently(){
    const usableW = measureUsableWidthPx();
    const pres = Array.from(document.querySelectorAll("pre"));
    const startPt = Math.max(6, Math.min(48, parseInt(_requestedPt, 10) || ${safePt}));
    const MIN_PT = 10;
    const SAFETY = 0.985;

    let worst = { w: 0, title: "", startW: 0, startChars: 0, fitPt: startPt };
    let minApplied = Infinity;
    let maxApplied = 0;

    pres.forEach(pre => setPreFontSizePt(pre, startPt));

    pres.forEach(pre => {
      const maxLine = getMaxLineTextTrimmed(pre.textContent || "");
      if (!maxLine) return;

      const startWpx = measureLineWidthPx(pre, maxLine);
      const chars = maxLine.length;

      let fitPt = startPt;

      if (usableW > 0 && startWpx > 0 && startWpx > usableW){
        const ratio = usableW / startWpx;
        fitPt = Math.floor((startPt * ratio * SAFETY) * 100) / 100;
        fitPt = Math.max(MIN_PT, Math.min(startPt, fitPt));
        setPreFontSizePt(pre, fitPt);
      } else {
        setPreFontSizePt(pre, startPt);
      }

      minApplied = Math.min(minApplied, fitPt);
      maxApplied = Math.max(maxApplied, fitPt);

      if (startWpx > worst.startW){
        const chart = pre.closest(".chart");
        const h3 = chart ? chart.querySelector("h3") : null;
        worst = {
          startW: startWpx,
          title: h3 ? h3.textContent : "(unknown)",
          startChars: chars,
          fitPt
        };
      }
    });

    if (!isFinite(minApplied)) minApplied = startPt;

    // diag(
    //   "PRINT DIAGNOSTICS (per-tune fit)\\n" +
    //   "media:               " + (window.matchMedia && window.matchMedia("print").matches ? "print" : "screen/unknown") + "\\n" +
    //   "doc.clientWidth:     " + (document.documentElement ? document.documentElement.clientWidth : 0) + "\\n" +
    //   "usableW(px):         " + usableW + "\\n" +
    //   "requestedPt:         " + startPt + "\\n" +
    //   "appliedPt(min..max): " + minApplied.toFixed(2) + " .. " + maxApplied.toFixed(2) + "\\n" +
    //   "\\nWORST (forces smallest)\\n" +
    //   "title:               " + worst.title + "\\n" +
    //   "maxChars(line):      " + worst.startChars + "\\n" +
    //   "maxLinePx@reqPt:     " + Math.round(worst.startW) + "\\n" +
    //   "fitPt(worst):        " + worst.fitPt.toFixed(2) + "\\n" +
    //   "pre.count:           " + pres.length + "\\n"
    // );
  }

  window.addEventListener("beforeprint", () => {
    try{
      trimAllPreTrailingSpaces();
      fitEachPreIndependently();
    }catch(e){
      diag("beforeprint error: " + (e && e.message ? e.message : e));
    }
  });

  window.__PRINT_API__ = {
    setHtml(html){
      document.getElementById("printRoot").innerHTML = html || "";
    },
    setOneTunePerPage(enabled){
      document.body.classList.toggle("oneTunePerPage", !!enabled);
    },
    setDiagnostics(enabled){
      document.body.classList.toggle("showDiag", !!enabled);
    },
    trimAllPreTrailingSpaces,

    fitAndPrint(requestedPt){
      _requestedPt = requestedPt;
      this.setDiagnostics(DIAG_DEFAULT_ON);
      document.querySelectorAll("pre").forEach(pre => pre.style.fontSize = (parseInt(_requestedPt,10)||${safePt}) + "pt");
      requestAnimationFrame(() => requestAnimationFrame(() => window.print()));
    }
  };
})();
<\/script>
</body>
</html>`;
}

function printViaIframe({
  paperSize,
  orientation,
  requestedPt = 20,
  requestedTitlePt = 24,
  oneTunePerPage = true
} = {}) {

  const out = document.getElementById("out");
  if (!out) return;

  if (!out.children.length && typeof generateCharts === "function") {
    generateCharts();
  }
  if (!out.children.length) return;

  const sections = Array.from(out.querySelectorAll("section.chart"));
  const esc = (s) => String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");

  const html = sections.map(sec => {
    const h3 = sec.querySelector("h3");
    const pre = sec.querySelector("pre");
    const title = h3 ? h3.textContent : "";
    const text  = pre ? pre.textContent : "";
    return `<section class="chart"><h3>${esc(title)}</h3><pre>${esc(text)}</pre></section>`;
  }).join("");

  const iframe = document.createElement("iframe");
  iframe.style.position = "fixed";
  iframe.style.left = "-10000px";
  iframe.style.top = "0";
  iframe.style.width = "1000px";
  iframe.style.height = "1000px";
  iframe.style.border = "0";
  iframe.style.opacity = "0";
  iframe.style.pointerEvents = "none";

  iframe.srcdoc = buildPrintHtml({
    paperSize,
    orientation,
    requestedPt,
    requestedTitlePt,
    oneTunePerPage
  });

  const cleanup = () => { try { iframe.remove(); } catch {} };

  iframe.onload = () => {
    const w = iframe.contentWindow;
    if (!w || !w.__PRINT_API__) { cleanup(); return; }
    w.__PRINT_API__.setHtml(html);
    w.__PRINT_API__.setOneTunePerPage(oneTunePerPage);
    w.__PRINT_API__.trimAllPreTrailingSpaces();
    w.onafterprint = cleanup;
    w.__PRINT_API__.fitAndPrint(requestedPt);
  };

  document.body.appendChild(iframe);
}

function hasRealChordQuotes(abcBody) {
  const lines = String(abcBody || "").split(/\r?\n/);
  let inBeginTextBlock = false;

  for (let rawLine of lines) {
    let line = String(rawLine || "");

    if (/^\s*%%begintext\b/i.test(line)) { 
      inBeginTextBlock = true; 
      continue; 
    }
    if (/^\s*%%endtext\b/i.test(line)) { 
      inBeginTextBlock = false; 
      continue; 
    }
    if (inBeginTextBlock) continue;

    if (!line.trim()) continue;
    if (/^\s*%/.test(line)) continue;

    const trimmed = line.trim();
    if (/^[A-Za-z]:/.test(trimmed)) continue;

    // Strip trailing "\" or "$"
    line = line.replace(/\s*[\\$]\s*$/, "");

    if (!line.trim()) continue;

    const hasBar = /[|:]/.test(line);
    const hasQuote = line.indexOf('"') !== -1;
    if (!hasBar && !hasQuote) continue;

    const re = /"([^"]*)"/g;
    let m;
    while ((m = re.exec(line)) !== null) {
      const chord = (m[1] || "").trim();
      if (!chord) continue;
      if (/^[\^_<>@]/.test(chord)) continue;
      return true;
    }
  }

  return false;
}

function generateCharts() {
  setStatus("Working…");

  const abcText = $("abcIn").value || "";
  const out = $("out");
  out.innerHTML = "";

  // Disable Copy/Save/Print until we know we have output
  syncActionButtons();

  const tunes = splitAbcIntoTunes(abcText);
  if (tunes.length === 0) {
    setStatus("No tunes found.", true);
    syncActionButtons();
    return;
  }

  const extraSpace = parseInt($("slotWidth").value, 10) || 0;
  const appendRhythm = $("appendRhythm") ? ($("appendRhythm").value === "1") : true;

  const placeholder =
    $("emptyMeasurePlaceholder")
      ? $("emptyMeasurePlaceholder").value
      : "/";

  const suppressPickup = $("suppressPickup") ? ($("suppressPickup").value === "1") : false;
  const pickupMaxNotes = $("pickupMaxNotes") ? (parseInt($("pickupMaxNotes").value, 10) || 3) : 3;

  const pickupHeuristic = {
    enabled: !!suppressPickup,
    maxNotes: Math.max(1, Math.min(4, pickupMaxNotes))
  };

  let renderedCount = 0;
  let skippedNoChords = 0;
  let skippedEmptyOut = 0;

  for (const block of tunes) {
    let title = getHeaderValue(block, "T") || "Untitled";
    let rhythm = getHeaderValue(block, "R");

    if (appendRhythm && rhythm) {
      rhythm = rhythm.trim().toLowerCase();
      rhythm = rhythm.charAt(0).toUpperCase() + rhythm.slice(1);
      title += ` (${rhythm})`;
    }

    const body = getTuneBody(block);

    if (!hasRealChordQuotes(body)) {
      skippedNoChords++;
      continue;
    }

    const txt = renderAlignedText(body, {
      rightPadSpaces: 2,
      extraSpace,
      emptyPlaceholder: placeholder,
      pickupHeuristic,
      pickupOnlyAtTuneStart: true
    });

    if (!txt.trim()) {
      skippedEmptyOut++;
      continue;
    }

    const section = document.createElement("section");
    section.className = "chart";

    const h3 = document.createElement("h3");
    h3.textContent = title;
    section.appendChild(h3);

    const pre = document.createElement("pre");
    pre.textContent = txt;
    section.appendChild(pre);

    out.appendChild(section);
    renderedCount++;
  }

  if (renderedCount === 0) {
    const skippedTotal = skippedNoChords + skippedEmptyOut;
    if (skippedTotal > 0) {
      setStatus(`No chord charts generated. Skipped ${skippedTotal} tune(s) without chords.`, true);
    } else {
      setStatus("No chord charts generated.", true);
    }
    syncActionButtons();
    return;
  }

  const skippedTotal = skippedNoChords + skippedEmptyOut;

  if (skippedTotal > 0) {
    setStatus(`Done. Generated ${renderedCount} chord chart(s). Skipped ${skippedTotal} tune(s) without chords.`);
  } else {
    setStatus(`Done. Generated ${renderedCount} chord chart(s).`);
  }

  syncActionButtons();
}

//
// Copy chord charts to the clpboard
//
async function copyChordChartsToClipboard() {
  const btn = $("copyBtn");
  const originalLabel = btn ? btn.textContent : "";

  function showCopiedFeedback() {
    if (!btn) return;
    btn.textContent = "Copied!";
    btn.disabled = true;

    setTimeout(() => {
      btn.textContent = originalLabel;
      syncActionButtons();
    }, 1200);
  }

  // If nothing rendered yet, generate first
  if (!$("out").children.length) {
    generateCharts();
  }
  if (!$("out").children.length) {
    setStatus("Nothing to copy. Generate chord charts first.", true);
    return;
  }

  const text = buildRawChordTextForSave();
  if (!text.trim()) {
    setStatus("Nothing to copy. Generate chord charts first.", true);
    return;
  }

  // Modern Clipboard API
  try {
    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(text);
      setStatus("Copied chord charts to the clipboard.");
      showCopiedFeedback();
      return;
    }
  } catch (e) {
    // fall through to legacy method
  }

  // Legacy fallback
  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.select();
    ta.setSelectionRange(0, ta.value.length);

    const ok = document.execCommand("copy");
    ta.remove();

    if (ok) {
      setStatus("Copied chord charts to the clipboard.");
      showCopiedFeedback();
    } else {
      setStatus("Copy failed. Your browser blocked clipboard access.", true);
    }
  } catch (e2) {
    setStatus("Copy failed: " + (e2 && e2.message ? e2.message : String(e2)), true);
  }
}

/* ---------------------------------
   File open
---------------------------------- */
function handleFileOpen(file) {
  if (!file) return;

  const nameLower = (file.name || "").toLowerCase();
  const ok =
    nameLower.endsWith(".abc") ||
    nameLower.endsWith(".txt") ||
    (file.type && file.type.startsWith("text/"));

  if (!ok) {
    setStatus("Please choose a .abc or .txt file.", true);
    return;
  }

  // Clear previous output immediately when a new file is selected
  $("out").innerHTML = "";
  gSavedChordFileName = "";
  syncActionButtons(); // <-- disable Copy/Save/Print

  const reader = new FileReader();

  reader.onload = () => {
    const text = String(reader.result || "");
    $("abcIn").value = text;

    const shownName = file.name || "file";

    gLoadedFileName = shownName;

    const tunes = splitAbcIntoTunes(text);
    const nTunes = tunes.length;

    if (nTunes === 0) {
      setStatus(`Loaded "${shownName}". No tunes found.`, true);
    } else if (nTunes === 1) {
      setStatus(`Loaded "${shownName}". Found 1 tune.`);
    } else {
      setStatus(`Loaded "${shownName}". Found ${nTunes} tunes.`);
    }

    // Still disabled until user generates charts
    syncActionButtons();
  };

  reader.onerror = () => {
    setStatus("Unable to read file.", true);
    syncActionButtons();
  };

  reader.readAsText(file);
}

/* ---------------------------------
   Wire up UI
---------------------------------- */

function hasChartsRendered() {
  const out = $("out");
  if (!out) return false;
  return !!out.querySelector("section.chart");
}

function syncActionButtons() {
  const enabled = hasChartsRendered();

  const ids = ["copyBtn", "saveBtn", "printBtn"];
  for (const id of ids) {
    const b = $(id);
    if (b) b.disabled = !enabled;
  }
}

function wireUp() {

  function applyPrintSettings() {
    setPageStyle($("paperSize").value, $("orientation").value);
    setPrintFontSize($("printFontSize").value, $("printTitleSize").value);

    const onePerPage = $("oneTunePerPage")
      ? ($("oneTunePerPage").value === "1")
      : true;

    setOneTunePerPagePrint(onePerPage);
  }

  // ------------------------------------------------------------
  // Full page initialization (used ONLY on load/pageshow)
  // ------------------------------------------------------------
  function initializePageState() {

    // Clear output + file input
    $("out").innerHTML = "";
    $("fileIn").value = "";

    // Reset controls
    $("slotWidth").value = "1";
    if ($("appendRhythm")) $("appendRhythm").value = "1";

    $("paperSize").value = "letter";
    $("orientation").value = "portrait";
    $("printTitleSize").value = "24";
    $("printFontSize").value = "20";
    if ($("oneTunePerPage")) $("oneTunePerPage").value = "0";

    if ($("suppressPickup")) $("suppressPickup").value = "1";
    if ($("pickupMaxNotes")) $("pickupMaxNotes").value = "3";

    // Reset internal state
    gLoadedFileName = "";
    gSavedChordFileName = "";
    gRequestedPrintPt = 20;

    restoreSavedSettingsIntoUI_SettingsOnly();

    // Load share link OR default sample
    const loadedFromLink = tryDecodeShareLinkIntoEditor();
    if (!loadedFromLink) {
      $("abcIn").value = DEFAULT_ABC;
      setStatus("Ready.");
    }

    applyPrintSettings();

    if (gIsIOS) {
      document.getElementById("fileIn").removeAttribute("accept");
    }

    // No charts yet => disable Copy/Save/Print
    syncActionButtons();

  }

  // ------------------------------------------------------------
  // Hard clear (used ONLY by Clear button)
  // ------------------------------------------------------------
  function clearAll() {
    $("abcIn").value = "";
    $("out").innerHTML = "";
    $("fileIn").value = "";

    gLoadedFileName = "";
    gSavedChordFileName = "";

    setStatus("Ready.");

    // Cleared output => disable Copy/Save/Print
    syncActionButtons();

  }

  // Initial load reset
  initializePageState();

  // Firefox/Safari BFCache restore protection
  window.addEventListener("pageshow", function (e) {
    if (e && e.persisted) {
      initializePageState();
    }
  });

  // ------------------------------------------------------------
  // Button wiring
  // ------------------------------------------------------------

  $("generateBtn").addEventListener("click", function () {

    sendGoogleAnalytics("action", "generate");

    applyPrintSettings();
    generateCharts();
    if ($("out").children.length) {
      $("out").scrollIntoView({ block: "start", behavior: "smooth" });
    }
  });

  $("copyBtn").addEventListener("click", async function () {

    sendGoogleAnalytics("action", "copy");

    applyPrintSettings();
    
    try {
      await copyChordChartsToClipboard();
    } catch (e) {
      setStatus("Copy failed: " + (e && e.message ? e.message : String(e)), true);
    }

  });

  $("saveBtn").addEventListener("click", async function () {

    sendGoogleAnalytics("action", "save");

    applyPrintSettings();
    try {
      await saveChordChart();
    } catch (e) {
      setStatus("Save failed: " + (e && e.message ? e.message : String(e)), true);
    }
  });

  $("clearBtn").addEventListener("click", function () {
    clearAll();
  });

  $("printBtn").addEventListener("click", function () {

    if (gIsIOS) {

      var thePrompt = "Printing is not supported on iOS";
      thePrompt = '<p style="font-size:12pt;line-height:18pt;font-family:helvetica;text-align:center">' + thePrompt + '</p>';

      if (window.DayPilot && DayPilot.Modal && typeof DayPilot.Modal.alert === "function") {
        DayPilot.Modal.alert(thePrompt, { theme:"modal_flat", top:100, scrollWithPage:false, width:500 });
      } else {
        alert("Printing is not supported on iOS");
      }

      return;
    }

    sendGoogleAnalytics("action", "print");

    applyPrintSettings();

    const paperSize = $("paperSize").value;
    const orientation = $("orientation").value;
    const requestedPt = parseInt($("printFontSize").value, 10) || 20;
    const requestedTitlePt = parseInt($("printTitleSize").value, 10) || 24;
    const oneTunePerPage = $("oneTunePerPage")
      ? ($("oneTunePerPage").value === "1")
      : true;

    printViaIframe({
      paperSize,
      orientation,
      requestedPt,
      requestedTitlePt,
      oneTunePerPage
    });
  });

  // ------------------------------------------------------------
  // Live control changes
  // ------------------------------------------------------------

  $("paperSize").addEventListener("change", applyPrintSettings);
  $("orientation").addEventListener("change", applyPrintSettings);
  $("printFontSize").addEventListener("change", applyPrintSettings);
  $("printTitleSize").addEventListener("change", applyPrintSettings);

  $("slotWidth").addEventListener("change", function () {
    if ($("out").children.length) generateCharts();
  });

  if ($("oneTunePerPage")) {
    $("oneTunePerPage").addEventListener("change", applyPrintSettings);
  }

  if ($("appendRhythm")) {
    $("appendRhythm").addEventListener("change", function () {
      if ($("out").children.length) generateCharts();
    });
  }

  if ($("emptyMeasurePlaceholder")) {
    $("emptyMeasurePlaceholder").addEventListener("change", function () {
      if ($("out").children.length) generateCharts();
    });
  }

  $("fileIn").addEventListener("change", function (e) {

    sendGoogleAnalytics("action", "loadfile");

    handleFileOpen(e.target.files && e.target.files[0]);
  });

  if ($("suppressPickup")) {
    $("suppressPickup").addEventListener("change", function () {
      if ($("out").children.length) generateCharts();
    });
  }

  if ($("pickupMaxNotes")) {
    $("pickupMaxNotes").addEventListener("change", function () {
      if ($("out").children.length) generateCharts();
    });
  }

  // Help modal (unchanged)
  $("btnHelp").addEventListener("click", function () {

    if (!window.DayPilot || !DayPilot.Modal || typeof DayPilot.Modal.alert !== "function") {
      alert("DayPilot.Modal is not loaded. Instructions are not available.");
      return;
    }

    sendGoogleAnalytics("action", "instructions");

    const content =
      '  <div style="margin-bottom:14px;">' +
      '    This utility extracts the chords from ABC tunes and generates clean, printable chord charts.' +
      '    The printed barlines and line breaks match the original ABC exactly.' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>First: Load some ABC tunes</b><br/>' +
      '    Paste one or more ABC tunes into the editor, or open a <code>.abc</code> / <code>.txt</code> file.<br/>' +
      '    <span class="muted">Tip: Chord charts are generated from chord symbols in quotes<br/>(for example: <code>"G"</code>, <code>"Am"</code>).</span>' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>Next: Generate the chord charts</b><br/>' +
      '    Click <b>Generate Charts</b>. The charts will appear in the <b>Chord Charts</b> area on the right.<br/>' +
      '    Tunes with no chords are skipped.<br/>Measures with no chords are shown as empty (or with your selected placeholder).' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>Once the chord charts have been generated, you can do the following:</b>' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>1) Copy chord charts to the clipboard</b><br/>' +
      '    Click <b>Copy</b> to copy the generated chord charts to the system clipboard.' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>2) Save the chord charts to a text file</b><br/>' +
      '    Click <b>Save</b> to save the generated chord charts to a text file.' +
      '  </div>' +

      '  <div style="margin-bottom:14px;">' +
      '    <b>3) Print chord charts or generate a PDF</b><br/>' +
      '    Click <b>Print</b> to print the generated chord charts from the browser.<br/>' +
      '    You may also save a PDF of the charts using the browser\'s native <b>Print-to-PDF</b> feature.' +
      '  </div>' +

      '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

      '  <div style="margin-bottom:14px;">' +
      '    <div style="font-weight:700; font-size:14pt; margin-bottom:10px;">Chord Chart Settings</div>' +

      '    <b>Extra spacing</b><br/>' +
      '    Adds extra spacing to make charts easier to read while keeping all barlines aligned.' +
      '    (This increases spacing after barlines/chord cells, and also increases spacing between multiple chords that occur in the same measure.)<br/><br/>' +

      '    <b>Append tune style (R:) to titles</b><br/>' +
      '    Optionally appends the tune rhythm/style tag in parentheses after the tune title.<br/><br/>' +

      '    <b>Empty measure placeholder</b><br/>' +
      '    Character (or none) to show in measures without chords.<br/>' +
      '    Default is: /<br/>' +
      '    This does not affect tunes that contain no chords at all (those are skipped).<br/><br/>' +

      '    <b>Suppress pickups</b><br/>' +
      '    When enabled, short partial measure pickup notes before the first barline or after a repeat (that contain no chord symbols) ' +
      '    will not be shown as a separate measure in the chord chart.<br/>' +
      '    This can make the chord charts look more natural.<br/><br/>' +

      '    <b>Max pickup notes</b><br/>' +
      '    When pickup suppression is enabled, treat 1–5 leading note-events or fewer before the first barline as a pickup.<br/>' +
      '    Default is: 3<br/>' +
      '    Increase this value if a tune begins with a slightly longer pickup.' +
      '  </div>' +

      '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

      '  <div style="margin-bottom:14px;">' +
      '    <div style="font-weight:700; font-size:14pt; margin-bottom:10px;">Print Settings</div>' +
      '    Set the paper size/orientation and the title/body font sizes, then click <b>Print</b>.<br/>' +
      '    The print view auto-shrinks the chord text only if needed to avoid clipping.<br/>' +
      '    You may export a PDF file by using the browser\'s native <b>Print-to-PDF</b> feature.' +
      '  </div>' +

      '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

      '  <div style="text-align:center; font-size:15pt; font-weight:700; margin-bottom:10px;">Tip Jars</div>' +
      '  <div style="text-align:center; margin-bottom:12px;">' +
      '    If you find this tool useful, please consider buying me a beer<br/>' +
      '    by tossing a few bucks into one of my virtual tip jars:' +
      '  </div>' +

      '  <div style="text-align:center; margin-bottom:10px;">' +
      '    <div style="font-weight:700;">PayPal</div>' +
      '    <div><a href="https://paypal.me/MichaelEskin" target="_blank" rel="noopener noreferrer">https://paypal.me/MichaelEskin</a></div>' +
      '  </div>' +

      '  <div style="text-align:center; margin-bottom:16px;">' +
      '    <div style="font-weight:700;">Venmo</div>' +
      '    <div>@MichaelEskin</div>' +
      '  </div>' +

      '  <hr style="border:0; border-top:1px solid #ccc; margin:18px 0;">' +

      '  <div style="margin-bottom:6px; text-align:center;"><b>The source code for this tool is available on GitHub:</b></div>' +
      '  <div style="margin-bottom:6px; text-align:center;">' +
      '    <a href="https://github.com/seisiuneer/abctools/blob/main/tools/abc_to_chord_chart.html" target="_blank" rel="noopener noreferrer">' +
      '      abc_to_chord_chart.html' +
      '    </a>' +
      '  </div>';

      const html =
      '<div id="instructions_div" style="font-family:Helvetica, Arial, sans-serif; font-size:12.5pt; line-height:1.6;">' +
      '  <div style="text-align:center; font-size:16pt; font-weight:700; margin-bottom:14px;">Instructions</div>' +
      '  <div style="width:100%; max-height:min(60vh, 520px); overflow:auto; -webkit-overflow-scrolling:touch; padding:0 12px 2px 30px; box-sizing:border-box;">' +
      content +
      '  </div>' +
      '</div>';
      
    DayPilot.Modal.alert(html, {
      theme: "modal_flat",
      top: 50,
      scrollWithPage: false
    });
  });

  enableAutoSaveForSettings_SettingsOnly();

}

function WaitForReady(fn) {
  if (document.readyState !== 'loading') { fn(); return; }
  document.addEventListener('DOMContentLoaded', fn);
}

WaitForReady(wireUp);

</script>

<script type="text/javascript" src="lz-string.min.js"></script>
<script type="text/javascript" src="pako.min.js"></script>
<script type="text/javascript" src="daypilot-modal.min-3.10.1.js"></script>

</body>
</html>