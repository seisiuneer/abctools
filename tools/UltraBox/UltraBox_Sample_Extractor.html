<!DOCTYPE html>
<html lang="en"><head>

  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="icon" type="image/x-icon" href="https://ultraabox.github.io/favicon.ico">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#CCCCCC">
  <meta property="og:image" content="/icon_maskable_192.png">
  <meta name="description" content="UltraBox is a mod of BeepBox that aims to combine every other beepmod into one.">
  <title>UltraBox Sample Extractor</title>
  <head>
    <style>
      :root {
      --close-symbol: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="-13 -13 26 26"><path fill="gray" d="M -7.07 -5.66 L -5.66 -7.07 L 0 -1.4 L 5.66 -7.07 L 7.07 -5.66 L 1.4 0 L 7.07 5.66 L 5.66 7.07 L 0 1.4 L -5.66 7.07 L -7.07 5.66 L -1.4 0 z"/></svg>');
      }
      
      html {
      background: black;
      overflow-x: hidden;
      font-size: large;
      font-family: sans-serif;
      line-height: 1.4;
      color: white;
      }
      
      body {
      margin: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      align-content: center;
      }
      
      main {
      width: 100%;
      max-width: 800px;
      padding-left: 30px;
      padding-right: 30px;
      }
      
      h1 {
      font-size: 1.7rem;
      text-align: center;
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      -webkit-text-stroke-width: 0;
      }
      
      h2 {
      font-size: 1.5rem;
      text-align: center;
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      -webkit-text-stroke-width: 0;
      }

      h3 {
      font-size: 1.25em;
      margin-top: .3em;
      margin-bottom: .47em;
      color: #000;
      text-align: center;
      }

      .accent-text {
      color: #FF8EC5;
      }
      
      .accent-text-2 {
      color: #FF8EC5;
      margin-top: 0em;
      }

      .center {
      margin-left: auto;
      margin-right: auto;
      text-align: center;
      }
      
      a {
      color: #98f;
      }
      
      button, input {
      font-size: large;
      }
      
      .sample-list {
      width: 100%;
      padding: 1em;
      font-size: large;
      }
      
      .welcome-area, .sample-list-area, .footer-area {
      padding: 1em;
      }
      
      .sample-list-area .columns .column {
      width: 100%;
      }
      
      .sample-list {
      height: 30em;
      }
      
      .sample-list-collection-filename {
      word-break: break-all;
      }
      
      .export-option-row {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
      }
      
      .output-sample-rate {
      text-align: center;
      }
      
      aside {
      font-size: small;
      }
      
      .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
      }
      
      .prompt {
      margin: auto;
      text-align: center;
      background: rgb(0, 0, 0);
      border-radius: 15px;
      border: 4px solid rgb(255, 255, 255);
      padding: 20px;
      display: flex;
      flex-direction: column;
      position: relative;
      box-shadow: 5px 5px 20px 10px rgba(0, 0, 0, 0.5);
      max-width: 600px;
      box-sizing: border-box;
      word-break: break-word;
      }
      
      .prompt .close-button {
      float: right;
      width: 26px;
      height: 26px;
      position: absolute;
      top: 8px;
      right: 8px;
      margin: 0;
      border: none;
      border-radius: 5px;
      background: #444;
      color: inherit;
      font-size: inherit;
      font-family: inherit;
      font-weight: inherit;
      cursor: pointer;
      }
      
      .prompt .close-button::before {
      content: "";
      position: absolute;
      width: 26px;
      height: 26px;
      left: 0;
      top: 0;
      pointer-events: none;
      background: currentColor;
      mask-image: var(--close-symbol);
      mask-repeat: no-repeat;
      mask-position: center;
      -webkit-mask-image: var(--close-symbol);
      -webkit-mask-repeat: no-repeat;
      -webkit-mask-position: center;
      }
      
      .prompt h2 {
      font-size: 2em;
      margin: 0 16px;
      font-weight: normal;
      }
      
      .prompt p {
      text-align: left;
      margin: 1em 0;
      }
      
      .prompt ul {
      text-align: left;
      }
      
      /* wide screen */
      @media (min-width: 800px) {
        html {
        width: 100%;
        }
        
        body {
        width: 100%;
        }
        
        .sample-list-area .columns {
        display: flex;
        flex-direction: row;
        align-content: center;
        gap: 25px;
        margin-bottom: 1em;
        }
      }
      
      /* narrow screen */
      @media (max-width: 800px) {
        body {
        width: 100%;
        }
        
        p {
        margin: 1em 0.5em;
        }
      }
    
    .modal_flat_background { background-color: #000; opacity: 0.4; }
    .modal_flat_main { border: 1px solid #333; box-shadow: 0px 0px 15.5px -2px rgba(0, 0, 0, 0.75); }
    .modal_flat_main, .modal_flat_main input, .modal_flat_main button { font-size: 16.8px; }
    .modal_flat_main input, .modal_flat_main button { padding: 5.25px; box-sizing: border-box; }
    .modal_flat_inner { padding: 25px; background: #fff; color: #000; }
    .modal_flat_content { font-family: "Helvetica"; margin: 21px 0px; }
    .modal_flat_input { margin: 21px 0px; }
    .modal_flat_buttons { text-align: center; margin-top: 20px; margin-bottom: 20px; }
    .modal_flat_main button { background-color: #ccc; color: #000; padding: 10.5px 21px; border: 0px; cursor: pointer; outline: none; width: 105px; }

    .modal_flat_cancel { margin-left: 5.25px; }

    .instr-modal { text-align: left; background-color: #f5ffff; max-height: 70vh; overflow: auto; padding: 12px; border: 1px solid #e1e1e1; border-radius: 4px; }
    .instr-modal p { margin: 0 0 12px 0; }

    .abc-instructions a {
      color: rgb(0, 0, 238) !important;
    }

    </style>

    <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=1"></script>

  </head>

  <body>
    <main>
      <div class="welcome-area">
        <h1 class="accent-text">UltraBox Sample Extractor</h1>

        <p>This utility helps you take sounds from larger files with several sounds inside (such as <a href="https://en.wikipedia.org/wiki/SoundFont">soundfonts</a>, with their well-known <code>.sf2</code> file extension), and save them as individual <a href="https://en.wikipedia.org/wiki/WAV"><code>.wav</code></a> files, for use in your <a href="https://ultraabox.github.io/">UltraBox</a> songs.</p>
        <!-- Button to open the instructions modal -->
        <p class="center">
          <button id="show-abc-instructions">How to use extracted samples with the ABC Transcription Tools Custom Instrument Builder</button>
        </p>
        <p>To start, drop a file (in one of the <a class="supported-formats-link" href="#">supported formats</a>) on this page, or use your browser's file picker:</p>
        <div class="center">
          <input type="file" multiple="" id="file-picker">
        </div>
      </div>
      <div class="sample-list-area" style="display: none;">
        <h2 class="accent-text-2">Extracting from <code class="sample-list-collection-filename">filename.sf2</code></h2>
        <p>Select one or more samples:</p>
        <div class="columns">
          <div class="column">
          <select multiple="multiple" class="sample-list" size="10"></select>
        </div>
        <div class="column">
        <ul class="sample-info-container"></ul>
        <div class="export-area" style="display: none;">
          <p class="export-option-row center">
            <label>
              <strong>Resample:</strong>
              <input class="resample-box" type="checkbox">
            </label>
          </p>
          <p class="export-option-row center output-sample-rate-row" style="display: none;">
            <strong>Output sample rate:</strong>
            <input class="output-sample-rate" type="number" value="44100" step="1">
          </p>
          <p class="export-option-row center">
            <label>
              <strong>Export samples with instrument name:</strong>
              <input class="instrument-name-box" type="checkbox" checked="checked">
            </label>
          </p>
        <ul class="center output-sample-info-container" style="display: none;"></ul>
        <p class="center">
          <button class="play-note">Play</button>
          <button class="export-as-wav">Export as .wav</button>
          <button class="export-as-zip" style="display: none;">Export .wav files as .zip</button>
        </p>
      </div>
    </main>
    <section class="overlay" style="display: none;">
      <div class="prompt">
        <button class="close-button"></button>
        <h2>Supported Formats</h2>
        <ul>
          <li>
            <a href="https://en.wikipedia.org/wiki/SoundFont"><code>.sf2</code></a>
          </li>
          <li>
            <code>.js</code>:
            <a href="https://ultraabox.github.io/">UltraBox</a> built-in sample script<br>
            Should also work with the sample scripts from <a href="https://paandorasbox.github.io/">Pandora's Box</a>
          </li>
          <li>
            <code>.txt</code>:
            <a href="https://ultraabox.github.io/archives/thurmbox/pandoras-jummbox-40.html">Pandora's BeepBox</a> sample file<br>
            You can see the sample list <a href="https://ultraabox.github.io/archives/thurmbox/sample_docs.html">here</a>.<br>
            <!-- The sample URL format is <code>https://pandoras-box-archive.neptendo.repl.co/get_sample.php?sample_name=SAMPLE_NAME</code>. -->
          </li>
          <li>
            <a href="https://en.wikipedia.org/wiki/WAV"><code>.wav</code></a>:
            Loadable for convenience, in case resampling is
            needed. Loop points are also saved/loaded, so they can be consulted
            after exporting.
          </li>
          <li>
            <a href="https://en.wikipedia.org/wiki/MP3"><code>.mp3</code></a>: Supported via the Web Audio API. Resampled to 44100hz on load. No loop point info.
          </li>
          <li>
            <a href="https://en.wikipedia.org/wiki/Ogg"><code>.ogg</code></a>: Supported via the Web Audio API. Resampled to 44100hz on load. No loop point info.
          </li>
          <li>
            <a href="https://en.wikipedia.org/wiki/FLAC"><code>.flac</code></a>: Supported via the Web Audio API. Resampled to 44100hz on load. No loop point info.
          </li>
        </ul>
      </div>
    </section>

    <script src="wavefile.js"></script>
    <script src="index.js"></script>

    <script>

      (function () {
        const instructionsHTML = `
            <div class="abc-instructions" style="max-width:600px;margin:0 auto;">
              <h3 style="text-align:center; margin-top:0; margin-bottom:0.8em; color:black;">
                Using Extracted Samples in the ABC Transcription Tools
              </h3>
              <p>To create a custom instrument for the <a href="https://michaeleskin.com/abctools/abctools.html" target="_blank">ABC Transcription Tools</a> from the extracted samples, first save a .zip of extracted instrument .wav files from the .sf2 file.</p>
              <p>The <strong>ABC Transcription Tools Custom Instrument Builder</strong> can directly import and pitch-map samples that have the MIDI note number before the file extension (e.g., Piano-60.wav):</p>
              <p style="text-align: center;"><a href="https://michaeleskin.com/tools/custom_instrument_builder.html" target="_blank">ABC Transcription Tools - Custom Instrument Builder</a></p>
              <p>Ideally, you'll want to have only a single instrument with no duplicate MIDI pitch numbers in the filenames in the .zip file.</p>
              <p>If there are no duplicate pitch numbers in the extracted sample filenames, you can directly import the saved .zip file using the <strong>Import Custom Instrument</strong> feature of the <strong>Custom Instrument Builder</strong>.</p>
              <p>If there are duplicate pitch numbers in the filenames, or you wish to pick and choose the samples to use for a custom instrument, you can unzip the .zip file exported by this tool into a directory and then open the specfic samples you want to use in the <strong>Custom Instrument Builder</strong> from that directory.</p>
              <p style="font-size: .25rem;">&nbsp;</p>
            </div>
          `;

        function showInstructionsModal() {
          DayPilot.Modal.alert(instructionsHTML, {
            theme: "modal_flat",
            top: 100,
            width: 640,          // keeps lines tidy on desktop; modal is responsive
            scrollWithPage: false
          });
        }

        const btn = document.getElementById("show-abc-instructions");
        if (btn) {
          btn.addEventListener("click", showInstructionsModal);
        }
      })();

      // https://cdn.jsdelivr.net/npm/@logue/sf2synth@latest/dist/sf2synth.umd.js
      // Modified slightly to not error on SoundFont 2.04 files (though the 24-bit samples
      // aren't handled correctly (yet)).
      /**
       * @logue/sf2synth
       *
       * @description SoundFont2 Synthesizer
       * @author iyama, Logue
       * @license MIT
       * @version 0.5.7
       * @see {@link https://github.com/logue/sf2synth.js}
       */
    
      (function(global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
          typeof define === 'function' && define.amd ? define(factory) :
          (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SoundFont = factory());
      })(this, (function() {
        'use strict';

        /**
         * SynthesizerNote Class
         *
         * @author imaya
         * @private
         */
        class SynthesizerNote {
          /**
           * @param {AudioContext} ctx
           * @param {AudioNode} destination
           * @param {{
           *   channel: number;
           *   key: number;
           *   sample: Uint8Array;
           *   basePlaybackRate: number;
           *   loopStart: number;
           *   loopEnd: number;
           *   volume: number;
           *   panpot: number;
           * }} instrument
           */
          constructor(ctx, destination, instrument) {
            /** @type {AudioContext} */
            this.ctx = ctx;
            /** @type {AudioNode} */
            this.destination = destination;
            /**
             * @type {{
             *   channel: number;
             *   key: number;
             *   sample: Uint8Array;
             *   basePlaybackRate: number;
             *   loopStart: number;
             *   loopEnd: number;
             *   volume: number;
             *   panpot: number;
             * }}
             */
            this.instrument = instrument;
            /** @type {number} */
            this.channel = instrument['channel'];
            /** @type {number} */
            this.key = instrument['key'];
            /** @type {number} */
            this.velocity = instrument['velocity'];
            /** @type {Uint8Array} */
            this.buffer = instrument['sample'];
            /** @type {number} */
            this.playbackRate = instrument['basePlaybackRate'];
            /** @type {number} */
            this.loopStart = instrument['loopStart'];
            /** @type {number} */
            this.loopEnd = instrument['loopEnd'];
            /** @type {number} */
            this.sampleRate = instrument['sampleRate'];
            /** @type {number} */
            this.volume = instrument['volume'];
            /** @type {number} */
            this.panpot = instrument['panpot'];
            /** @type {number} */
            this.pitchBend = instrument['pitchBend'];
            /** @type {number} */
            this.pitchBendSensitivity = instrument['pitchBendSensitivity'];
            /** @type {number} */
            this.modEnvToPitch = instrument['modEnvToPitch'];
            /** @type {number} */
            this.expression = instrument['expression'];
            /** @type {number} */
            this.modulation = instrument['modulation'];
            /** @type {number} */
            this.cutOffFrequency = instrument['cutOffFrequency'];
            /** @type {number} */
            this.hermonicContent = instrument['hermonicContent'];

            /** @type {import('@logue/reverb').default} */
            this.reverb = instrument['reverb'];

            // state
            /** @type {number} */
            this.startTime = ctx.currentTime;
            /** @type {number} */
            this.computedPlaybackRate = this.playbackRate | 0;
            /** @type {boolean} */
            this.noteOffState = false;

            // ---------------------------------------------------------------------------
            // audio node
            // ---------------------------------------------------------------------------

            /** @type {AudioBuffer} */
            this.audioBuffer = null;
            /** @type {AudioBufferSourceNode} */
            this.bufferSource = ctx.createBufferSource();
            /** @type {PannerNode} */
            this.panner = ctx.createPanner();
            /** @type {GainNode} */
            this.outputGainNode = ctx.createGain();
            /** @type {GainNode} */
            this.expressionGainNode = ctx.createGain();
            /** @type {BiquadFilterNode} */
            this.filter = ctx.createBiquadFilter();
            /** @type {BiquadFilterNode} */
            this.modulator = ctx.createBiquadFilter();
          }

          /** Note on */
          noteOn() {
            /** @type {AudioContext} */
            const ctx = this.ctx;
            /**
             * @type {{
             *   channel: number;
             *   key: number;
             *   sample: Uint8Array;
             *   basePlaybackRate: number;
             *   loopStart: number;
             *   loopEnd: number;
             *   volume: number;
             *   panpot: number;
             * }}
             */
            const instrument = this.instrument;
            /** @type {number} */
            const now = this.ctx.currentTime || 0;
            /** @type {number} */
            const volDelay = now + instrument['volDelay'];
            /** @type {number} */
            const modDelay = now + instrument['modDelay'];
            /** @type {number} */
            const volAttack = volDelay + instrument['volAttack'];
            /** @type {number} */
            const modAttack = volDelay + instrument['modAttack'];
            /** @type {number} */
            const volHold = volAttack + instrument['volHold'];
            /** @type {number} */
            const modHold = modAttack + instrument['modHold'];
            /** @type {number} */
            const volDecay = volHold + instrument['volDecay'];
            /** @type {number} */
            const modDecay = modHold + instrument['modDecay'];
            /** @type {number} */
            const loopStart = instrument['loopStart'] / this.sampleRate;
            /** @type {number} */
            const loopEnd = instrument['loopEnd'] / this.sampleRate;
            /** @type {number} */
            const startTime = instrument['start'] / this.sampleRate;
            // TODO: ドラムパートのPanが変化した場合、その計算をしなければならない
            // http://cpansearch.perl.org/src/PJB/MIDI-SoundFont-1.08/doc/sfspec21.html#8.4.6
            /** @type {number} */
            const pan = instrument['pan'] !== 0 ? instrument['pan'] : this.panpot;

            const sample = this.buffer.subarray(
              0,
              this.buffer.length + instrument['end']
            );
            /** @type {AudioBuffer} */
            const buffer = (this.audioBuffer = ctx.createBuffer(
              1,
              sample.length,
              this.sampleRate
            ));
            /** @type {Float32Array} */
            const channelData = buffer.getChannelData(0);
            channelData.set(sample);

            // buffer source
            /** @type {AudioBufferSourceNode} */
            const bufferSource = this.bufferSource;
            bufferSource.buffer = buffer;
            bufferSource.loop = instrument['sampleModes'] || 0;
            bufferSource.loopStart = loopStart;
            bufferSource.loopEnd = loopEnd;
            this.updatePitchBend(this.pitchBend);

            // Output
            /** @type {GainNode} */
            const output = this.outputGainNode;

            // expression
            this.expressionGainNode.gain.value = this.expression / 127;

            // panpot
            /** @type {PannerNode} */
            const panner = this.panner;
            panner.panningModel = 'equalpower';
            panner.distanceModel = 'inverse';
            panner.positionX.setValueAtTime(Math.sin((pan * Math.PI) / 2), 0);
            panner.positionY.setValueAtTime(0, 0);
            panner.positionZ.setValueAtTime(Math.cos((pan * Math.PI) / 2), 0);

            // ---------------------------------------------------------------------------
            // Delay, Attack, Hold, Decay, Sustain
            // ---------------------------------------------------------------------------

            /** @type {number} */
            let volume =
              this.volume *
              (this.velocity / 127) *
              (1 - instrument['initialAttenuation'] / 1000);
            if (volume < 0) {
              volume = 0;
            }

            /** @type {AudioParam} volume envelope */
            const outputGain = output.gain;
            outputGain.setValueAtTime(0, now);
            outputGain.setValueAtTime(0, volDelay);
            outputGain.setTargetAtTime(volume, volDelay, instrument['volAttack']);
            outputGain.setValueAtTime(volume, volHold);
            outputGain.linearRampToValueAtTime(
              volume * (1 - instrument['volSustain']),
              volDecay
            );

            // modulation envelope
            /** @type {number} */
            const baseFreq = instrument['initialFilterFc'];
            /** @type {number} */
            const peekFreq =
              instrument['initialFilterFc'] + instrument['modEnvToFilterFc'];
            /** @type {number} */
            const sustainFreq =
              baseFreq + (peekFreq - baseFreq) * (1 - instrument['modSustain']);

            /** @type {BiquadFilterNode} */
            const modulator = this.modulator;
            modulator.Q.setValueAtTime(10 ** (instrument['initialFilterQ'] / 200), now);
            modulator.frequency.value = baseFreq;
            modulator.type = 'lowpass';
            modulator.frequency.setTargetAtTime(
              baseFreq / 127,
              this.ctx.currentTime,
              0.5
            );
            modulator.frequency.setValueAtTime(baseFreq, now);
            modulator.frequency.setValueAtTime(baseFreq, modDelay);
            modulator.frequency.setTargetAtTime(
              peekFreq,
              modDelay,
              parseFloat(instrument['modAttack'])
            );
            modulator.frequency.setValueAtTime(peekFreq, modHold);
            modulator.frequency.exponentialRampToValueAtTime(sustainFreq, modDecay);

            // Vibrato
            /* * @type {GainNode} LFO Depth * /
            const lfoDepth = this.ctx.createGain();
            /* * @type {OscillatorNode} LFO Oscillator * /
            const lfo = this.ctx.createOscillator();
            // Set parameters for LFO
            lfo.type = 'sine';
            lfoDepth.gain.value = 1;
            lfo.frequency.value = this.instrument['freqVibLFO'];

            if (this.modulation) {
              // Effector (Vibrato) ON
              lfo.start(0);
            } else {
              // Effector (Vibrato) Off
              lfo.stop(0);
            }
            // OscillatorNode (LFO) -> GainNode (Depth) -> frequency (AudioParam)
            lfo.connect(lfoDepth);

            // connect
            bufferSource.connect(lfoDepth);
            lfoDepth.connect(modulator);
            modulator.connect(panner);
            panner.connect(this.expressionGainNode);
            */
            bufferSource.connect(modulator);
            modulator.connect(panner);
            panner.connect(this.expressionGainNode);

            if (!instrument['mute']) {
              this.connect();
            }

            this.expressionGainNode.connect(output);

            // fire
            bufferSource.start(0, startTime);
          }

          /**
           * @param {number} val
           * @return {number}
           */
          amountToFreq(val) {
            return 2 ** ((val - 6900) / 1200) * 440;
          }

          /** Note off */
          noteOff() {
            this.noteOffState = true;
          }

          /** @return {boolean} */
          isNoteOff() {
            return this.noteOffState;
          }

          /** @return {void} */
          release() {
            /**
             * @type {{
             *   channel: number;
             *   key: number;
             *   sample: Uint8Array;
             *   basePlaybackRate: number;
             *   loopStart: number;
             *   loopEnd: number;
             *   volume: number;
             *   panpot: number;
             * }}
             */
            const instrument = this.instrument;
            /** @type {AudioBufferSourceNode} */
            const bufferSource = this.bufferSource;
            /** @type {GainNode} */
            const output = this.outputGainNode;
            /** @type {number} */
            const now = this.ctx.currentTime;
            /** @type {number} */
            const release = instrument['releaseTime'] - 64;

            // ---------------------------------------------------------------------------
            // volume release time
            // ---------------------------------------------------------------------------
            /** @type {number} */
            const volEndTimeTmp = instrument['volRelease'] * output.gain.value;
            /** @type {number} */
            const volEndTime =
              now + volEndTimeTmp * (1 + release / (release < 0 ? 64 : 63));
            //   now + instrument['volRelease'] * (1 - instrument['volSustain']);

            // ---------------------------------------------------------------------------
            // modulation release time
            // ---------------------------------------------------------------------------
            /** @type {BiquadFilterNode} */
            const modulator = this.modulator;
            /** @type {number} */
            const baseFreq = instrument['initialFilterFc'];
            /** @type {number} */
            const peekFreq =
              instrument['initialFilterFc'] + instrument['modEnvToFilterFc'];
            /** @type {number} */
            const modEndTime =
              now +
              instrument['modRelease'] *
              (baseFreq === peekFreq ?
                1 :
                (modulator.frequency.value - baseFreq) / (peekFreq - baseFreq));

            // const modEndTime =
            //   now + instrument['modRelease'] * (1 - instrument['modSustain']);

            if (!this.audioBuffer) {
              return;
            }

            // ---------------------------------------------------------------------------
            // Release
            // ---------------------------------------------------------------------------

            switch (instrument['sampleModes']) {
              case 0:
                // ループしない
                bufferSource.loop = false;
                break;
              case 1:
                // ループさせる
                output.gain.cancelScheduledValues(0);
                output.gain.setValueAtTime(output.gain.value, now);
                output.gain.linearRampToValueAtTime(0, volEndTime);

                modulator.frequency.cancelScheduledValues(0);
                modulator.frequency.setValueAtTime(modulator.frequency.value, now);
                modulator.frequency.exponentialRampToValueAtTime(baseFreq, modEndTime);

                bufferSource.playbackRate.cancelScheduledValues(0);
                bufferSource.playbackRate.setValueAtTime(
                  bufferSource.playbackRate.value,
                  now
                );
                bufferSource.playbackRate.exponentialRampToValueAtTime(
                  this.computedPlaybackRate,
                  modEndTime
                );

                bufferSource.stop(volEndTime);
                break;
              case 2:
                // 未定義
                throw Error('[SynthesizerNote] Detect unused sampleModes');
              case 3:
                // ノートオフまでループさせる
                output.gain.cancelScheduledValues(0);
                output.gain.setValueAtTime(output.gain.value, now);
                output.gain.linearRampToValueAtTime(0, volEndTime);

                modulator.frequency.cancelScheduledValues(0);
                modulator.frequency.setValueAtTime(modulator.frequency.value, now);
                modulator.frequency.exponentialRampToValueAtTime(baseFreq, modEndTime);

                bufferSource.playbackRate.cancelScheduledValues(0);
                bufferSource.playbackRate.setValueAtTime(
                  bufferSource.playbackRate.value,
                  now
                );
                bufferSource.playbackRate.exponentialRampToValueAtTime(
                  this.computedPlaybackRate,
                  modEndTime
                );
                bufferSource.loop = false;
                bufferSource.buffer = null;
                break;
              default:
                throw Error(
                  `[SynthesizerNote] ${instrument['sampleModes']} is undefined sampleModes.`
                );
            }
          }

          /** Connect AudioContext */
          connect() {
            this.reverb.connect(this.outputGainNode).connect(this.destination);
          }

          /** Disconnect AudioContext */
          disconnect() {
            this.outputGainNode.disconnect(0);
          }

          /** Caluclate playback rate */
          schedulePlaybackRate() {
            /** @type {AudioParam} */
            const playbackRate = this.bufferSource.playbackRate;
            /** @type {number} */
            const computed = this.computedPlaybackRate;
            /** @type {number} */
            const start = this.startTime;
            /** @type {Object} */
            const instrument = this.instrument;
            /** @type {number} */
            const modAttack = start + instrument['modAttack'];
            /** @type {number} */
            const modDecay = modAttack + instrument['modDecay'];
            /** @type {number} */
            const peekPitch =
              computed *
              1.0594630943592953 ** // Math.pow(2, 1 / 12)
              (this.modEnvToPitch * this.instrument['scaleTuning']);

            playbackRate.cancelScheduledValues(0);
            playbackRate.setValueAtTime(computed, start);
            playbackRate.linearRampToValueAtTime(peekPitch, modAttack);
            playbackRate.linearRampToValueAtTime(
              computed + (peekPitch - computed) * (1 - instrument['modSustain']),
              modDecay
            );
          }

          /** @param {number} expression */
          updateExpression(expression) {
            this.expressionGainNode.gain.value = (this.expression = expression) / 127;
          }

          /** @param {number} pitchBend */
          updatePitchBend(pitchBend) {
            this.computedPlaybackRate =
              this.playbackRate *
              1.0594630943592953 ** // Math.pow(2, 1 / 12)
              ((pitchBend / (pitchBend < 0 ? 8192 : 8191)) *
                this.pitchBendSensitivity *
                this.instrument['scaleTuning']);
            this.schedulePlaybackRate();
          }
        }

        const INV_MAX = 1 / 2 ** 32;
        class ARandom {
          float(norm = 1) {
            return this.int() * INV_MAX * norm;
          }
          norm(norm = 1) {
            return (this.int() * INV_MAX - 0.5) * 2 * norm;
          }
          normMinMax(min, max) {
            const x = this.minmax(min, max);
            return this.float() < 0.5 ? x : -x;
          }
          minmax(min, max) {
            return this.float() * (max - min) + min;
          }
          minmaxInt(min, max) {
            min |= 0;
            max |= 0;
            return min + ((this.float() * (max - min)) | 0);
          }
        }

        const random = Math.random;
        /**
         * A `Math.random()` based {@link IRandom} implementation. Also @see
         * {@link SYSTEM}.
         */
        class SystemRandom extends ARandom {
          int() {
            return (random() * 4294967296) /* 2**32 */ >>> 0;
          }
          float(norm = 1) {
            return random() * norm;
          }
          norm(norm = 1) {
            return (random() - 0.5) * 2 * norm;
          }
        }
        /**
         * Used as default PRNG throughout most other thi.ng projects, though usually is
         * configurable.
         */
        const SYSTEM = new SystemRandom();

        const DEFAULT_OPTS = {
          bins: 2,
          scale: 1,
          rnd: SYSTEM,
        };

        const preseed = (n, scale, rnd) => {
          const state = new Array(n);
          for (let i = 0; i < n; i++) {
            state[i] = rnd.norm(scale);
          }
          return state;
        };
        const sum = (src) => src.reduce((sum, x) => sum + x, 0);

        function* interleave(a, b) {
          const src = [a[Symbol.iterator](), b[Symbol.iterator]()];
          for (let i = 0; true; i ^= 1) {
            const next = src[i].next();
            if (next.done)
              return;
            yield next.value;
          }
        }

        /**
         * High-pass filtered noise. Opposite of {@link red}.
         *
         * @param opts -
         */
        function* blue(opts) {
          const {
            bins,
            scale,
            rnd
          } = {
            ...DEFAULT_OPTS,
            ...opts,
          };
          const state = preseed(bins, scale, rnd);
          state.forEach((x, i) => (state[i] = i & 1 ? x : -x));
          const invN = 1 / bins;
          let acc = sum(state);
          for (let i = 0, sign = -1; true; ++i >= bins && (i = 0)) {
            acc -= state[i];
            acc += state[i] = sign * rnd.norm(scale);
            sign ^= 0xfffffffe;
            yield sign * acc * invN;
          }
        }

        /**
         * Band-pass filtered noise (interleaved blue noise). Opposite of
         * {@link violet}.
         *
         * @param opts -
         */
        const green = (opts) => interleave(blue(opts), blue(opts));

        /**
         * Returns number of 1 bits in `x`.
         *
         * @param x -
         */
        const ctz32 = (x) => {
          let c = 32;
          x &= -x;
          x && c--;
          x & 0x0000ffff && (c -= 16);
          x & 0x00ff00ff && (c -= 8);
          x & 0x0f0f0f0f && (c -= 4);
          x & 0x33333333 && (c -= 2);
          x & 0x55555555 && (c -= 1);
          return c;
        };

        /**
         * Exponential decay (1/f) noise, based on Voss-McCarthy algorithm.
         *
         * @remarks
         * The number of internal states should be in the [4..32] range (default: 8).
         * Due to JS integer limitations, `n` > 32 are meaningless.
         *
         * References:
         *
         * - https://www.dsprelated.com/showarticle/908.php
         * - https://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney
         *
         * @param opts -
         */
        function* pink(opts) {
          const {
            bins,
            scale,
            rnd
          } = {
            ...DEFAULT_OPTS,
            bins: 8,
            ...opts,
          };
          const state = preseed(bins, scale, rnd);
          const invN = 1 / bins;
          let acc = sum(state);
          for (let i = 0; true; i = (i + 1) >>> 0) {
            const id = ctz32(i) % bins;
            acc -= state[id];
            acc += state[id] = rnd.norm(scale);
            yield acc * invN;
          }
        }

        /**
         * Low-pass filtered noise (same as brown noise). Opposite of {@link blue}.
         *
         * @param opts -
         */
        function* red(opts) {
          const {
            bins,
            scale,
            rnd
          } = {
            ...DEFAULT_OPTS,
            ...opts,
          };
          const state = preseed(bins, scale, rnd);
          const invN = 1 / bins;
          let acc = sum(state);
          for (let i = 0; true; ++i >= bins && (i = 0)) {
            acc -= state[i];
            acc += state[i] = rnd.norm(scale);
            yield acc * invN;
          }
        }

        /**
         * Band-stop filtered noise (interleaved red noise). Opposite of {@link green}.
         *
         * @param opts -
         */
        const violet = (opts) => interleave(red(opts), red(opts));

        /**
         * Unfiltered noise w/ uniform distribution. Merely yields samples from
         * given PRNG.
         *
         * @param opts -
         */
        function* white(opts) {
          const {
            scale,
            rnd
          } = {
            ...DEFAULT_OPTS,
            ...opts
          };
          while (true) {
            yield rnd.norm(scale);
          }
        }

        const implementsFunction = (x, fn) => x != null && typeof x[fn] === "function";

        const ensureTransducer = (x) => implementsFunction(x, "xform") ? x.xform() : x;

        const isIterable = (x) => x != null && typeof x[Symbol.iterator] === "function";

        class Reduced {
          constructor(val) {
            this.value = val;
          }
          deref() {
            return this.value;
          }
        }
        const reduced = (x) => new Reduced(x);
        const isReduced = (x) => x instanceof Reduced;
        const ensureReduced = (x) => x instanceof Reduced ? x : new Reduced(x);
        const unreduced = (x) => (x instanceof Reduced ? x.deref() : x);

        /**
         * Convenience helper for building a full {@link Reducer} using the identity
         * function (i.e. `(x) => x`) as completion step (true for 90% of all
         * bundled transducers).
         *
         * @param init - init step of reducer
         * @param rfn - reduction step of reducer
         */
        const reducer = (init, rfn) => [init, (acc) => acc, rfn];

        function push(xs) {
          return xs ?
            [...xs] :
            reducer(() => [], (acc, x) => (acc.push(x), acc));
        }

        /**
         * Takes a transducer and input iterable. Returns iterator of
         * transformed results.
         *
         * @param xform -
         * @param xs -
         */
        function* iterator(xform, xs) {
          const rfn = ensureTransducer(xform)(push());
          const complete = rfn[1];
          const reduce = rfn[2];
          for (let x of xs) {
            const y = reduce([], x);
            if (isReduced(y)) {
              yield* unreduced(complete(y.deref()));
              return;
            }
            if (y.length) {
              yield* y;
            }
          }
          yield* unreduced(complete([]));
        }

        /**
         * Reducer composition helper, internally used by various transducers
         * during initialization. Takes existing reducer `rfn` (a 3-tuple) and a
         * reducing function `fn`. Returns a new reducer tuple.
         *
         * @remarks
         * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.
         * `fn` accepts values of type `C` and produces interim results of type
         * `B`, which are then (possibly) passed to the "inner" `rfn[2]`
         * function. Therefore the resulting reducer takes inputs of `C` and an
         * accumulator of type `A`.
         *
         * It is assumed that `fn` internally calls `rfn[2]` to pass its own
         * results for further processing by the nested reducer `rfn`.
         *
         * @example
         * ```ts
         * compR(rfn, fn)
         * // [rfn[0], rfn[1], fn]
         * ```
         *
         * @param rfn -
         * @param fn -
         */
        const compR = (rfn, fn) => [rfn[0], rfn[1], fn];

        function take(n, src) {
          return isIterable(src) ?
            iterator(take(n), src) :
            (rfn) => {
              const r = rfn[2];
              let m = n;
              return compR(rfn, (acc, x) => --m > 0 ?
                r(acc, x) :
                m === 0 ?
                ensureReduced(r(acc, x)) :
                reduced(acc));
            };
        }

        /**
         * @logue/reverb
         *
         * @description JavaScript Reverb effect class
         * @author Logue <logue@hotmail.co.jp>
         * @copyright 2019-2023 By Masashi Yoshikawa All rights reserved.
         * @license MIT
         * @version 1.2.14
         * @see {@link https://github.com/logue/Reverb.js}
         */


        const defaults = {
          noise: "white",
          scale: 1,
          peaks: 2,
          randomAlgorithm: SYSTEM,
          decay: 2,
          delay: 0,
          reverse: false,
          time: 2,
          filterType: "allpass",
          filterFreq: 2200,
          filterQ: 1,
          mix: 0.5,
          once: false
        };

        const meta$1 = {
          version: "1.2.14",
          date: "2023-06-02T11:55:08.307Z"
        };

        const Noise = {
          /** Blue noise */
          blue: "blue",
          /** Brown noise (same as red noise) */
          brown: "red",
          /** Green noise */
          green: "green",
          /** Pink noise */
          pink: "pink",
          /** Red noise */
          red: "red",
          /** Violet noise */
          violet: "violet",
          /** White noise */
          white: "white"
        };

        class Reverb {
          /** Version strings */
          static version = meta$1.version;
          /** Build date */
          static build = meta$1.date;
          /** AudioContext */
          ctx;
          /** Wet Level (Reverberated node) */
          wetGainNode;
          /** Dry Level (Original sound node) */
          dryGainNode;
          /** Impulse response filter */
          filterNode;
          /** Convolution node for applying impulse response */
          convolverNode;
          /** Output gain node */
          outputNode;
          /** Option */
          options;
          /** Connected flag */
          isConnected;
          /** Noise Generator */
          noise = white;
          /**
           * Constructor
           *
           * @param ctx - Root AudioContext
           * @param options - Configure
           */
          constructor(ctx, options) {
            this.ctx = ctx;
            this.options = Object.assign(defaults, options);
            this.wetGainNode = this.ctx.createGain();
            this.dryGainNode = this.ctx.createGain();
            this.filterNode = this.ctx.createBiquadFilter();
            this.convolverNode = this.ctx.createConvolver();
            this.outputNode = this.ctx.createGain();
            this.isConnected = false;
            this.filterType(this.options.filterType);
            this.setNoise(this.options.noise);
            this.buildImpulse();
            this.mix(this.options.mix);
          }
          /**
           * Connect the node for the reverb effect to the original sound node.
           *
           * @param sourceNode - Input source node
           */
          connect(sourceNode) {
            if (this.isConnected && this.options.once) {
              this.isConnected = false;
              return this.outputNode;
            }
            this.convolverNode.connect(this.filterNode);
            this.filterNode.connect(this.wetGainNode);
            sourceNode.connect(this.convolverNode);
            sourceNode.connect(this.dryGainNode).connect(this.outputNode);
            sourceNode.connect(this.wetGainNode).connect(this.outputNode);
            this.isConnected = true;
            return this.outputNode;
          }
          /**
           * Disconnect the reverb node
           *
           * @param sourceNode - Input source node
           */
          disconnect(sourceNode) {
            if (this.isConnected) {
              this.convolverNode.disconnect(this.filterNode);
              this.filterNode.disconnect(this.wetGainNode);
            }
            this.isConnected = false;
            return sourceNode;
          }
          /**
           * Dry/Wet ratio
           *
           * @param mix - Ratio (0~1)
           */
          mix(mix) {
            if (!this.inRange(mix, 0, 1)) {
              throw new RangeError("[Reverb.js] Dry/Wet ratio must be between 0 to 1.");
            }
            this.options.mix = mix;
            this.dryGainNode.gain.value = 1 - this.options.mix;
            this.wetGainNode.gain.value = this.options.mix;
          }
          /**
           * Set Impulse Response time length (second)
           *
           * @param value - IR length
           */
          time(value) {
            if (!this.inRange(value, 1, 50)) {
              throw new RangeError(
                "[Reverb.js] Time length of inpulse response must be less than 50sec."
              );
            }
            this.options.time = value;
            this.buildImpulse();
          }
          /**
           * Impulse response decay rate.
           *
           * @param value - Decay value
           */
          decay(value) {
            if (!this.inRange(value, 0, 100)) {
              throw new RangeError(
                "[Reverb.js] Inpulse Response decay level must be less than 100."
              );
            }
            this.options.decay = value;
            this.buildImpulse();
          }
          /**
           * Delay before reverberation starts
           *
           * @param value - Time[ms]
           */
          delay(value) {
            if (!this.inRange(value, 0, 100)) {
              throw new RangeError(
                "[Reverb.js] Inpulse Response delay time must be less than 100."
              );
            }
            this.options.delay = value;
            this.buildImpulse();
          }
          /**
           * Reverse the impulse response.
           *
           * @param reverse - Reverse IR
           */
          reverse(reverse) {
            this.options.reverse = reverse;
            this.buildImpulse();
          }
          /**
           * Filter for impulse response
           *
           * @param type - Filiter Type
           */
          filterType(type = "allpass") {
            this.filterNode.type = this.options.filterType = type;
          }
          /**
           * Filter frequency applied to impulse response
           *
           * @param freq - Frequency
           */
          filterFreq(freq) {
            if (!this.inRange(freq, 20, 2e4)) {
              throw new RangeError(
                "[Reverb.js] Filter frequrncy must be between 20 and 20000."
              );
            }
            this.options.filterFreq = freq;
            this.filterNode.frequency.value = this.options.filterFreq;
          }
          /**
           * Filter quality.
           *
           * @param q - Quality
           */
          filterQ(q) {
            if (!this.inRange(q, 0, 10)) {
              throw new RangeError(
                "[Reverb.js] Filter quality value must be between 0 and 10."
              );
            }
            this.options.filterQ = q;
            this.filterNode.Q.value = this.options.filterQ;
          }
          /**
           * set IR source noise peaks
           *
           * @param p - Peaks
           */
          peaks(p) {
            this.options.peaks = p;
            this.buildImpulse();
          }
          /**
           * set IR source noise scale.
           *
           * @param s - Scale
           */
          scale(s) {
            this.options.scale = s;
            this.buildImpulse();
          }
          /**
           * set IR source noise generator.
           *
           * @param a - Algorithm
           */
          randomAlgorithm(a) {
            this.options.randomAlgorithm = a;
            this.buildImpulse();
          }
          /**
           * Inpulse Response Noise algorithm.
           *
           * @param type - IR noise algorithm type.
           */
          setNoise(type) {
            this.options.noise = type;
            switch (type) {
              case Noise.blue:
                this.noise = blue;
                break;
              case Noise.green:
                this.noise = green;
                break;
              case Noise.pink:
                this.noise = pink;
                break;
              case Noise.red:
              case Noise.brown:
                this.noise = red;
                break;
              case Noise.violet:
                this.noise = violet;
                break;
              default:
                this.noise = white;
            }
            this.buildImpulse();
          }
          /**
           * Set Random Algorythm
           *
           * @param algorithm - Algorythm
           */
          setRandomAlgorythm(algorithm) {
            this.options.randomAlgorithm = algorithm;
            this.buildImpulse();
          }
          /**
           * Return true if in range, otherwise false
           *
           * @param x - Target value
           * @param min - Minimum value
           * @param max - Maximum value
           */
          inRange(x, min, max) {
            return (x - min) * (x - max) <= 0;
          }
          /** Utility function for building an impulse response from the module parameters. */
          buildImpulse() {
            const rate = this.ctx.sampleRate;
            const duration = Math.max(rate * this.options.time, 1);
            const delayDuration = rate * this.options.delay;
            const impulse = this.ctx.createBuffer(2, duration, rate);
            const impulseL = new Float32Array(duration);
            const impulseR = new Float32Array(duration);
            const noiseL = this.getNoise(duration);
            const noiseR = this.getNoise(duration);
            for (let i = 0; i < duration; i++) {
              let n = 0;
              if (i < delayDuration) {
                impulseL[i] = 0;
                impulseR[i] = 0;
                n = this.options.reverse ?? false ? duration - (i - delayDuration) : i - delayDuration;
              } else {
                n = this.options.reverse ?? false ? duration - i : i;
              }
              impulseL[i] = (noiseL[i] ?? 0) * (1 - n / duration) ** this.options.decay;
              impulseR[i] = (noiseR[i] ?? 0) * (1 - n / duration) ** this.options.decay;
            }
            impulse.getChannelData(0).set(impulseL);
            impulse.getChannelData(1).set(impulseR);
            this.convolverNode.buffer = impulse;
          }
          /**
           * Noise source
           *
           * @param duration - length of IR.
           */
          getNoise(duration) {
            return [
              ...take(
                duration,
                this.noise({
                  bins: this.options.peaks,
                  scale: this.options.scale,
                  rnd: this.options.randomAlgorithm
                })
              )
            ];
          }
        }
        if (!window.Reverb) {
          window.Reverb = Reverb;
        }

        /**
         * Riff Parser class
         *
         * @author imaya
         */
        class Riff {
          /**
           * @param {ArrayBuffer} input Input buffer.
           * @param {Object} [optParams] Option parameters.
           */
          constructor(input, optParams = {}) {
            /** @type {ArrayBuffer} */
            this.input = input;
            /** @type {number} */
            this.ip = optParams.index || 0;
            /** @type {number} */
            this.length = optParams.length || input.byteLength - this.ip;
            /** @type {RiffChunk[]} */
            this.chunkList = [];
            /** @type {number} */
            this.offset = this.ip;
            /** @type {boolean} */
            this.padding = optParams.padding !== void 0 ? optParams.padding : true;
            /** @type {boolean} */
            this.bigEndian =
              optParams.bigEndian !== void 0 ? optParams.bigEndian : false;
          }

          /** @returns {void} */
          parse() {
            /** @type {number} */
            const length = this.length + this.offset;

            this.chunkList = [];

            while (this.ip < length) {
              this.parseChunk();
            }
          }

          /** @returns {void} */
          parseChunk() {
            /** @type {ArrayBuffer} */
            const input = this.input;
            /** @type {number} */
            let ip = this.ip;
            /** @type {number} */
            let size;

            this.chunkList.push(
              new RiffChunk(
                String.fromCharCode(input[ip++], input[ip++], input[ip++], input[ip++]),
                (size = this.bigEndian ?
                  ((input[ip++] << 24) |
                    (input[ip++] << 16) |
                    (input[ip++] << 8) |
                    input[ip++]) >>>
                  0 :
                  (input[ip++] |
                    (input[ip++] << 8) |
                    (input[ip++] << 16) |
                    (input[ip++] << 24)) >>>
                  0),
                ip
              )
            );

            ip += size;

            // padding
            if (this.padding && ((ip - this.offset) & 1) === 1) {
              ip++;
            }

            this.ip = ip;
          }

          /**
           * @param {number} index Chunk index.
           * @returns {RiffChunk | null}
           */
          getChunk(index) {
            /** @type {RiffChunk} */
            const chunk = this.chunkList[index];

            return chunk !== undefined ? chunk : null;
          }

          /** @returns {number} */
          getNumberOfChunks() {
            return this.chunkList.length;
          }
        }

        /**
         * Riff Chunk Structure
         *
         * @interface
         */
        class RiffChunk {
          /**
           * @param {string} type
           * @param {number} size
           * @param {number} offset
           */
          constructor(type, size, offset) {
            /** @type {string} */
            this.type = type;
            /** @type {number} */
            this.size = size;
            /** @type {number} */
            this.offset = offset;
          }
        }

        /**
         * SoundFont Parser Class
         *
         * @author imaya
         */
        class Parser {
          /**
           * @param {Uint8Array} input
           * @param {Object} [optParams]
           */
          constructor(input, optParams = {}) {
            /** @type {Uint8Array} */
            this.input = input;
            /** @type {Object | undefined} */
            this.parserOption = optParams.parserOption || {};
            /** @type {Number | undefined} */
            this.sampleRate = optParams.sampleRate || 22050; // よくわからんが、OSで指定されているサンプルレートを入れないと音が切れ切れになる。

            /** @type {Object[]} */
            this.presetHeader = [];
            /** @type {Object[]} */
            this.presetZone = [];
            /** @type {Object[]} */
            this.presetZoneModulator = [];
            /** @type {Object[]} */
            this.presetZoneGenerator = [];
            /** @type {Object[]} */
            this.instrument = [];
            /** @type {Object[]} */
            this.instrumentZone = [];
            /** @type {Object[]} */
            this.instrumentZoneModulator = [];
            /** @type {Object[]} */
            this.instrumentZoneGenerator = [];
            /** @type {Object[]} */
            this.sampleHeader = [];
            /** @type {string[]} */
            this.GeneratorEnumeratorTable = Object.keys(this.getGeneratorTable());
          }

          /** @return {Object} ジェネレータとデフォルト値 */
          getGeneratorTable() {
            return Object.freeze({
              /** @type {number} サンプルヘッダの音声波形データ開始位置に加算されるオフセット(下位16bit） */
              startAddrsOffset: 0,
              /** @type {number} サンプルヘッダの音声波形データ終了位置に加算されるオフセット(下位16bit） */
              endAddrsOffset: 0,
              /** @type {number} サンプルヘッダの音声波形データループ開始位置に加算されるオフセット(下位16bit） */
              startloopAddrsOffset: 0,
              /** @type {number} サンプルヘッダの音声波形データループ開始位置に加算されるオフセット(下位16bit） */
              endloopAddrsOffset: 0,
              /** @type {number} サンプルヘッダの音声波形データ開始位置に加算されるオフセット(上位16bit） */
              startAddrsCoarseOffset: 0,
              /** @type {number} LFOによるピッチの揺れ幅 */
              modLfoToPitch: 0,
              /** @type {number} モジュレーションホイール用LFOからピッチに対しての影響量 */
              vibLfoToPitch: 0,
              /** @type {number} フィルタ・ピッチ用エンベロープからピッチに対しての影響量 */
              modEnvToPitch: 0,
              /** @type {number} フィルタのカットオフ周波数 */
              initialFilterFc: 13500,
              /** @type {number} フィルターのQ値(レゾナンス) */
              initialFilterQ: 0,
              /** @type {number} LFOによるフィルターカットオフ周波数の揺れ幅 */
              modLfoToFilterFc: 0,
              /** @type {number} フィルタ・ピッチ用エンベロープからフィルターカットオフに対しての影響量 */
              modEnvToFilterFc: 0,
              /** @type {number} サンプルヘッダの音声波形データ終了位置に加算されるオフセット(上位16bit） */
              endAddrsCoarseOffset: 0,
              /** @type {number} LFOによるボリュームの揺れ幅 */
              modLfoToVolume: 0,
              /** @type {undefined} 未使用1 */
              unused1: undefined, // 14
              /** @type {number} コーラスエフェクトのセンドレベル */
              chorusEffectsSend: 0,
              /** @type {number} リバーブエフェクトのセンドレベル */
              reverbEffectsSend: 0,
              /** @type {number} パンの位置 */
              pan: 0,
              /** @type {undefined} 未使用2 */
              unused2: undefined,
              /** @type {undefined} 未使用3 */
              unused3: undefined,
              /** @type {undefined} 未使用4 */
              unused4: undefined,
              /** @type {number} LFOの揺れが始まるまでの時間 */
              delayModLFO: -12000,
              /** @type {number} LFOの揺れの周期 */
              freqModLFO: 0,
              /** @type {number} ホイールの揺れが始まるまでの時間 */
              delayVibLFO: -12000,
              /** @type {number} ホイールの揺れの周期 */
              freqVibLFO: 0,
              /** @type {number} フィルタ・ピッチ用エンベロープのディレイ(アタックが始まるまでの時間) */
              delayModEnv: -12000,
              /** @type {number} フィルタ・ピッチ用エンベロープのアタック時間 */
              attackModEnv: -12000,
              /** @type {number} フィルタ・ピッチ用エンベロープのホールド時間(アタックが終わってからディケイが始まるまでの時間） */
              holdModEnv: -12000,
              /** @type {number} フィルタ・ピッチ用エンベロープのディケイ時間 */
              decayModEnv: -12000,
              /** @type {number} フィルタ・ピッチ用エンベロープのサステイン量 */
              sustainModEnv: 0,
              /** @type {number} フィルタ・ピッチ用エンベロープのリリース時間 */
              releaseModEnv: -12000,
              /** @type {number} キー(ノートNo)によるフィルタ・ピッチ用エンベロープのホールド時間への影響 */
              keynumToModEnvHold: 0,
              /** @type {number} キー(ノートNo)によるフィルタ・ピッチ用エンベロープのディケイ時間への影響 */
              keynumToModEnvDecay: 0,
              /** @type {number} アンプ用エンベロープのディレイ(アタックが始まるまでの時間) */
              delayVolEnv: -12000,
              /** @type {number} アンプ用エンベロープのアタック時間 */
              attackVolEnv: -12000,
              /** @type {number} アンプ用エンベロープのホールド時間(アタックが終わってからディケイが始まるまでの時間） */
              holdVolEnv: -12000,
              /** @type {number} アンプ用エンベロープのディケイ時間 */
              decayVolEnv: -12000,
              /** @type {number} アンプ用エンベロープのサステイン量 */
              sustainVolEnv: 0,
              /** @type {number} アンプ用エンベロープのリリース時間 */
              releaseVolEnv: -12000,
              /** @type {number} キー(ノートNo)によるアンプ用エンベロープのホールド時間への影響 */
              keynumToVolEnvHold: 0,
              /** @type {number} キー(ノートNo)によるアンプ用エンベロープのディケイ時間への影響 */
              keynumToVolEnvDecay: 0,
              /** @type {number} 割り当てるインストルメント(楽器) */
              instrument: null,
              /** @type {undefined} 予約済み1 */
              reserved1: undefined, // 42
              /** @type {number} マッピングするキー(ノートNo)の範囲 */
              keyRange: null,
              /** @type {number} マッピングするベロシティの範囲 */
              velRange: null,
              /** @type {number} サンプルヘッダの音声波形データループ開始位置に加算されるオフセット(上位16bit） */
              startloopAddrsCoarseOffset: 0,
              /** @type {number} どのキー(ノートNo)でも強制的に指定したキー(ノートNo)に変更する */
              keynum: null,
              /** @type {number} どのベロシティでも強制的に指定したベロシティに変更する */
              velocity: null,
              /** @type {number} 調整する音量 */
              initialAttenuation: 0,
              /** @type {undefined} 予約済み2 */
              reserved2: undefined, // 49
              /** @type {number} サンプルヘッダの音声波形データループ終了位置に加算されるオフセット(上位16bit） */
              endloopAddrsCoarseOffset: 0,
              /** @type {number} 半音単位での音程の調整 */
              coarseTune: 0,
              /** @type {number} cent単位での音程の調整 */
              fineTune: 0,
              /** @type {number} 割り当てるサンプル(音声波形) */
              sampleID: null,
              /** @type {number} サンプル(音声波形)をループさせるか等のフラグ */
              sampleModes: 0,
              /** @type {undefined} 予約済み3 */
              reserved3: undefined, // 55
              /** @type {number} キー(ノートNo)が+1されるごとに音程を何centあげるかの音階情報 */
              scaleTuning: 100,
              /** @type {number} 同時に音を鳴らさないようにするための排他ID(ハイハットのOpen、Close等に使用) */
              exclusiveClass: null,
              /** @type {number} サンプル(音声波形)の音程の上書き情報 */
              overridingRootKey: null,
              /** @type {undefined} 未使用5 */
              unuded5: undefined, // 59
              /** @type {undefined} 最後を示すオペレータ */
              endOper: undefined,
            });
          }

          /** @export */
          parse() {
            /** @type {Riff} */
            const parser = new Riff(this.input, this.parserOption);

            // parse RIFF chunk
            parser.parse();
            if (parser.chunkList.length !== 1) {
              throw new Error('wrong chunk length');
            }

            /** @type {import('./riff.js').RiffChunk | null} */
            const chunk = parser.getChunk(0);
            if (chunk === null) {
              throw new Error('chunk not found');
            }

            this.parseRiffChunk(chunk);
            // console.log(this.sampleHeader);
            this.input = null;
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseRiffChunk(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;

            // check parse target
            if (chunk.type !== 'RIFF') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            // check signature
            /** @type {string} */
            const signature = String.fromCharCode(
              data[ip++],
              data[ip++],
              data[ip++],
              data[ip++]
            );
            if (signature !== 'sfbk') {
              throw new Error('invalid signature:' + signature);
            }

            // read structure
            /** @type {import('./riff.js').Riff} */
            const parser = new Riff(data, {
              index: ip,
              length: chunk.size - 4
            });
            parser.parse();
            if (parser.getNumberOfChunks() !== 3) {
              throw new Error('invalid sfbk structure');
            }

            // INFO-list
            this.parseInfoList(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(0))
            );

            // sdta-list
            this.parseSdtaList(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(1))
            );

            // pdta-list
            this.parsePdtaList(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(2))
            );
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseInfoList(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;

            // check parse target
            if (chunk.type !== 'LIST') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            // check signature
            /** @type {string} */
            const signature = String.fromCharCode(
              data[ip++],
              data[ip++],
              data[ip++],
              data[ip++]
            );
            if (signature !== 'INFO') {
              throw new Error('invalid signature:' + signature);
            }

            // read structure
            /** @type {import('./riff.js').Riff} */
            const parser = new Riff(data, {
              index: ip,
              length: chunk.size - 4
            });
            parser.parse();
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseSdtaList(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;

            // check parse target
            if (chunk.type !== 'LIST') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            // check signature
            /** @type {string} */
            const signature = String.fromCharCode(
              data[ip++],
              data[ip++],
              data[ip++],
              data[ip++]
            );
            if (signature !== 'sdta') {
              throw new Error('invalid signature:' + signature);
            }

            // read structure
            /** @type {import('./riff.js').Riff} */
            const parser = new Riff(data, {
              index: ip,
              length: chunk.size - 4
            });
            parser.parse();
            if (parser.chunkList.length > 1) {
              console.warn("Ignoring extra sample data chunks:", parser.chunkList);
              // throw new Error('TODO');
            } else if (parser.chunkList.length < 1) {
              throw new Error("No sample data chunk");
            }
            this.samplingData =
              /** @type {{ type: string; size: number; offset: number }} */
              (parser.getChunk(0));
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parsePdtaList(chunk) {
            /** @type {Uint8Array} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;

            // check parse target
            if (chunk.type !== 'LIST') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            // check signature
            /** @type {string} */
            const signature = String.fromCharCode(
              data[ip++],
              data[ip++],
              data[ip++],
              data[ip++]
            );
            if (signature !== 'pdta') {
              throw new Error('invalid signature:' + signature);
            }

            // read structure
            /** @type {import('./riff.js').Riff} */
            const parser = new Riff(data, {
              index: ip,
              length: chunk.size - 4
            });
            parser.parse();

            // check number of chunks
            if (parser.getNumberOfChunks() !== 9) {
              throw new Error('invalid pdta chunk');
            }

            this.parsePhdr(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(0))
            );
            this.parsePbag(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(1))
            );
            this.parsePmod(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(2))
            );
            this.parsePgen(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(3))
            );
            this.parseInst(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(4))
            );
            this.parseIbag(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(5))
            );
            this.parseImod(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(6))
            );
            this.parseIgen(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(7))
            );
            this.parseShdr(
              /** @type {import('./riff.js').RiffChunk} */
              (parser.getChunk(8))
            );
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parsePhdr(chunk) {
            /** @type {Uint8Array} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {Object[]} */
            const presetHeader = (this.presetHeader = []);
            /** @type {number} */
            const size = chunk.offset + chunk.size;

            // check parse target
            if (chunk.type !== 'phdr') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            while (ip < size) {
              presetHeader.push({
                presetName: String.fromCharCode.apply(
                  null,
                  data.subarray(ip, (ip += 20))
                ),
                preset: data[ip++] | (data[ip++] << 8),
                bank: data[ip++] | (data[ip++] << 8),
                presetBagIndex: data[ip++] | (data[ip++] << 8),
                library: (data[ip++] |
                    (data[ip++] << 8) |
                    (data[ip++] << 16) |
                    (data[ip++] << 24)) >>>
                  0,
                genre: (data[ip++] |
                    (data[ip++] << 8) |
                    (data[ip++] << 16) |
                    (data[ip++] << 24)) >>>
                  0,
                morphology: (data[ip++] |
                    (data[ip++] << 8) |
                    (data[ip++] << 16) |
                    (data[ip++] << 24)) >>>
                  0,
              });
            }
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parsePbag(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {Object[]} */
            const presetZone = (this.presetZone = []);
            /** @type {number} */
            const size = chunk.offset + chunk.size;

            // check parse target
            if (chunk.type !== 'pbag') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            while (ip < size) {
              presetZone.push({
                presetGeneratorIndex: data[ip++] | (data[ip++] << 8),
                presetModulatorIndex: data[ip++] | (data[ip++] << 8),
              });
            }
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parsePmod(chunk) {
            // check parse target
            if (chunk.type !== 'pmod') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            this.presetZoneModulator = this.parseModulator(chunk);
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parsePgen(chunk) {
            // check parse target
            if (chunk.type !== 'pgen') {
              throw new Error('invalid chunk type:' + chunk.type);
            }
            this.presetZoneGenerator = this.parseGenerator(chunk);
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseInst(chunk) {
            /** @type {Uint8Array} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {Object[]} */
            const instrument = (this.instrument = []);
            /** @type {number} */
            const size = chunk.offset + chunk.size;

            // check parse target
            if (chunk.type !== 'inst') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            while (ip < size) {
              instrument.push({
                instrumentName: String.fromCharCode.apply(
                  null,
                  data.subarray(ip, (ip += 20))
                ),
                instrumentBagIndex: data[ip++] | (data[ip++] << 8),
              });
            }
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseIbag(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {Object[]} */
            const instrumentZone = (this.instrumentZone = []);
            /** @type {number} */
            const size = chunk.offset + chunk.size;

            // check parse target
            if (chunk.type !== 'ibag') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            while (ip < size) {
              instrumentZone.push({
                instrumentGeneratorIndex: data[ip++] | (data[ip++] << 8),
                instrumentModulatorIndex: data[ip++] | (data[ip++] << 8),
              });
            }
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseImod(chunk) {
            // check parse target
            if (chunk.type !== 'imod') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            this.instrumentZoneModulator = this.parseModulator(chunk);
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseIgen(chunk) {
            // check parse target
            if (chunk.type !== 'igen') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            this.instrumentZoneGenerator = this.parseGenerator(chunk);
          }

          /** @param {import('./riff.js').RiffChunk} chunk */
          parseShdr(chunk) {
            /** @type {Uint8Array} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {Object[]} */
            const samples = (this.sample = []);
            /** @type {Object[]} */
            const sampleHeader = (this.sampleHeader = []);
            /** @type {number} */
            const size = chunk.offset + chunk.size;
            /** @type {string} */
            let sampleName;
            /** @type {number} */
            let start;
            /** @type {number} */
            let end;
            /** @type {number} */
            let startLoop;
            /** @type {number} */
            let endLoop;
            /** @type {number} */
            let sampleRate;
            /** @type {number} */
            let originalPitch;
            /** @type {number} */
            let pitchCorrection;
            /** @type {number} */
            let sampleLink;
            /** @type {number} */
            let sampleType;

            // check parse target
            if (chunk.type !== 'shdr') {
              throw new Error('invalid chunk type:' + chunk.type);
            }

            while (ip < size) {
              sampleName = String.fromCharCode.apply(
                null,
                data.subarray(ip, (ip += 20))
              );
              start =
                ((data[ip++] << 0) |
                  (data[ip++] << 8) |
                  (data[ip++] << 16) |
                  (data[ip++] << 24)) >>>
                0;
              end =
                ((data[ip++] << 0) |
                  (data[ip++] << 8) |
                  (data[ip++] << 16) |
                  (data[ip++] << 24)) >>>
                0;
              startLoop =
                ((data[ip++] << 0) |
                  (data[ip++] << 8) |
                  (data[ip++] << 16) |
                  (data[ip++] << 24)) >>>
                0;
              endLoop =
                ((data[ip++] << 0) |
                  (data[ip++] << 8) |
                  (data[ip++] << 16) |
                  (data[ip++] << 24)) >>>
                0;
              sampleRate =
                ((data[ip++] << 0) |
                  (data[ip++] << 8) |
                  (data[ip++] << 16) |
                  (data[ip++] << 24)) >>>
                0;
              originalPitch = data[ip++];
              pitchCorrection = (data[ip++] << 24) >> 24;
              sampleLink = data[ip++] | (data[ip++] << 8);
              sampleType = data[ip++] | (data[ip++] << 8);

              let sample = new Int16Array(
                new Uint8Array(
                  data.subarray(
                    this.samplingData.offset + start * 2,
                    this.samplingData.offset + end * 2
                  )
                ).buffer
              );

              startLoop -= start;
              endLoop -= start;

              if (sampleRate > 0) {
                const adjust = this.adjustSampleData(sample, sampleRate);
                sample = adjust.sample;
                sampleRate *= adjust.multiply;
                startLoop *= adjust.multiply;
                endLoop *= adjust.multiply;
              }

              samples.push(sample);

              sampleHeader.push({
                sampleName: sampleName,
                start: start,
                end: end,
                startLoop: startLoop,
                endLoop: endLoop,
                sampleRate: sampleRate,
                originalPitch: originalPitch,
                pitchCorrection: pitchCorrection,
                sampleLink: sampleLink,
                sampleType: sampleType,
              });
            }
          }

          /**
           * @param {Int16Array} sample
           * @param {number} sampleRate
           * @return {object}
           */
          adjustSampleData(sample, sampleRate) {
            /** @type {Int16Array} */
            let newSample;
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {number} */
            let j;
            /** @type {number} */
            let multiply = 1;

            // buffer
            while (sampleRate < this.sampleRate) {
              // AudioContextのサンプルレートに変更
              newSample = new Int16Array(sample.length * 2);
              for (i = j = 0, il = sample.length; i < il; ++i) {
                newSample[j++] = sample[i];
                newSample[j++] = sample[i];
              }
              sample = newSample;
              multiply *= 2;
              sampleRate *= 2;
            }

            return {
              sample: sample,
              multiply: multiply,
            };
          }

          /**
           * @param {import('./riff.js').RiffChunk} chunk
           * @return {Object[]}
           */
          parseModulator(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {number} */
            const size = chunk.offset + chunk.size;
            /** @type {number} */
            let code;
            /** @type {string} */
            let key;
            /** @type {Object[]} */
            const output = [];

            while (ip < size) {
              // Src  Oper
              // TODO
              ip += 2;

              // Dest Oper
              code = data[ip++] | (data[ip++] << 8);
              key = this.GeneratorEnumeratorTable[code];
              if (key === void 0) {
                // Amount
                output.push({
                  type: key,
                  value: {
                    code: code,
                    amount: data[ip] | (((data[ip + 1] << 8) << 16) >> 16),
                    lo: data[ip++],
                    hi: data[ip++],
                  },
                });
              } else {
                // Amount
                switch (key) {
                  case 'keyRange':
                    /* FALLTHROUGH */
                  case 'velRange':
                    /* FALLTHROUGH */
                  case 'keynum':
                    /* FALLTHROUGH */
                  case 'velocity':
                    output.push({
                      type: key,
                      value: {
                        amount: null,
                        lo: data[ip++],
                        hi: data[ip++],
                      },
                    });
                    break;
                  default:
                    output.push({
                      type: key,
                      value: {
                        amount: data[ip++] | (((data[ip++] << 8) << 16) >> 16),
                      },
                    });
                    break;
                }
              }

              // AmtSrcOper
              // TODO
              ip += 2;

              // Trans Oper
              // TODO
              ip += 2;
            }

            return output;
          }

          /**
           * @param {import('./riff.js').RiffChunk} chunk
           * @return {Object[]}
           */
          parseGenerator(chunk) {
            /** @type {ArrayBuffer} */
            const data = this.input;
            /** @type {number} */
            let ip = chunk.offset;
            /** @type {number} */
            const size = chunk.offset + chunk.size;
            /** @type {number} */
            let code;
            /** @type {string} */
            let key;
            /** @type {Object[]} */
            const output = [];

            while (ip < size) {
              code = data[ip++] | (data[ip++] << 8);
              key = this.GeneratorEnumeratorTable[code];
              if (key === void 0) {
                output.push({
                  type: key,
                  value: {
                    code: code,
                    amount: data[ip] | (((data[ip + 1] << 8) << 16) >> 16),
                    lo: data[ip++],
                    hi: data[ip++],
                  },
                });
                continue;
              }

              switch (key) {
                case 'keynum':
                  /* FALLTHROUGH */
                case 'keyRange':
                  /* FALLTHROUGH */
                case 'velRange':
                  /* FALLTHROUGH */
                case 'velocity':
                  output.push({
                    type: key,
                    value: {
                      amount: null,
                      lo: data[ip++],
                      hi: data[ip++],
                    },
                  });
                  break;
                default:
                  output.push({
                    type: key,
                    value: {
                      amount: data[ip++] | (((data[ip++] << 8) << 16) >> 16),
                    },
                  });
                  break;
              }
            }

            return output;
          }

          /** @return {object[]} */
          createInstrument() {
            /** @type {Object[]} */
            const instrument = this.instrument;
            /** @type {Object[]} */
            const zone = this.instrumentZone;
            /** @type {Object[]} */
            const output = [];
            /** @type {number} */
            let bagIndex;
            /** @type {number} */
            let bagIndexEnd;
            /** @type {Object[]} */
            let zoneInfo;
            /** @type {{ generator: Object; generatorInfo: Object[] }} */
            let instrumentGenerator;
            /** @type {{ modulator: Object; modulatorInfo: Object[] }} */
            let instrumentModulator;
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {number} */
            let j;
            /** @type {number} */
            let jl;

            // instrument -> instrument bag -> generator / modulator
            for (i = 0, il = instrument.length; i < il; ++i) {
              bagIndex = instrument[i].instrumentBagIndex;
              bagIndexEnd = instrument[i + 1] ?
                instrument[i + 1].instrumentBagIndex :
                zone.length;
              zoneInfo = [];

              // instrument bag
              for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {
                instrumentGenerator = this.createInstrumentGenerator_(zone, j);
                instrumentModulator = this.createInstrumentModulator_(zone, j);

                zoneInfo.push({
                  generator: instrumentGenerator.generator,
                  generatorSequence: instrumentGenerator.generatorInfo,
                  modulator: instrumentModulator.modulator,
                  modulatorSequence: instrumentModulator.modulatorInfo,
                });
              }

              output.push({
                name: instrument[i].instrumentName,
                info: zoneInfo,
              });
            }

            return output;
          }

          /** @return {object[]} */
          createPreset() {
            /** @type {Object[]} */
            const preset = this.presetHeader;
            /** @type {Object[]} */
            const zone = this.presetZone;
            /** @type {Object[]} */
            const output = [];
            /** @type {number} */
            let bagIndex;
            /** @type {number} */
            let bagIndexEnd;
            /** @type {Object[]} */
            let zoneInfo;
            /** @type {number} */
            let instrument;
            /** @type {{ generator: Object; generatorInfo: Object[] }} */
            let presetGenerator;
            /** @type {{ modulator: Object; modulatorInfo: Object[] }} */
            let presetModulator;
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {number} */
            let j;
            /** @type {number} */
            let jl;

            // preset -> preset bag -> generator / modulator
            for (i = 0, il = preset.length; i < il; ++i) {
              bagIndex = preset[i].presetBagIndex;
              bagIndexEnd = preset[i + 1] ? preset[i + 1].presetBagIndex : zone.length;
              zoneInfo = [];

              // preset bag
              for (j = bagIndex, jl = bagIndexEnd; j < jl; ++j) {
                presetGenerator = this.createPresetGenerator_(zone, j);
                presetModulator = this.createPresetModulator_(zone, j);

                zoneInfo.push({
                  generator: presetGenerator.generator,
                  generatorSequence: presetGenerator.generatorInfo,
                  modulator: presetModulator.modulator,
                  modulatorSequence: presetModulator.modulatorInfo,
                });

                instrument =
                  presetGenerator.generator['instrument'] !== void 0 ?
                  presetGenerator.generator['instrument'].amount :
                  presetModulator.modulator['instrument'] !== void 0 ?
                  presetModulator.modulator['instrument'].amount :
                  null;
              }

              output.push({
                name: preset[i].presetName,
                info: zoneInfo,
                header: preset[i],
                instrument: instrument,
              });
            }

            return output;
          }

          /**
           *
           * @private
           * @param {Object[]} zone
           * @param {number} index
           * @returns {{ generator: Object; generatorInfo: Object[] }}
           */
          createInstrumentGenerator_(zone, index) {
            const modgen = this.createBagModGen_(
              zone,
              zone[index].instrumentGeneratorIndex,
              zone[index + 1] ?
              zone[index + 1].instrumentGeneratorIndex :
              this.instrumentZoneGenerator.length,
              this.instrumentZoneGenerator
            );

            return {
              generator: modgen.modgen,
              generatorInfo: modgen.modgenInfo,
            };
          }

          /**
           *
           * @private
           * @param {Object[]} zone
           * @param {number} index
           * @returns {{ modulator: Object; modulatorInfo: Object[] }}
           */
          createInstrumentModulator_(zone, index) {
            const modgen = this.createBagModGen_(
              zone,
              zone[index].presetModulatorIndex,
              zone[index + 1] ?
              zone[index + 1].instrumentModulatorIndex :
              this.instrumentZoneModulator.length,
              this.instrumentZoneModulator
            );

            return {
              modulator: modgen.modgen,
              modulatorInfo: modgen.modgenInfo,
            };
          }

          /**
           *
           * @private
           * @param {Object[]} zone
           * @param {number} index
           * @returns {{ generator: Object; generatorInfo: Object[] }}
           */
          createPresetGenerator_(zone, index) {
            const modgen = this.createBagModGen_(
              zone,
              zone[index].presetGeneratorIndex,
              zone[index + 1] ?
              zone[index + 1].presetGeneratorIndex :
              this.presetZoneGenerator.length,
              this.presetZoneGenerator
            );

            return {
              generator: modgen.modgen,
              generatorInfo: modgen.modgenInfo,
            };
          }

          /**
           *
           * @private
           * @param {Object[]} zone
           * @param {number} index
           * @returns {{ modulator: Object; modulatorInfo: Object[] }}
           */
          createPresetModulator_(zone, index) {
            /** @type {{ modgen: Object; modgenInfo: Object[] }} */
            const modgen = this.createBagModGen_(
              zone,
              zone[index].presetModulatorIndex,
              zone[index + 1] ?
              zone[index + 1].presetModulatorIndex :
              this.presetZoneModulator.length,
              this.presetZoneModulator
            );

            return {
              modulator: modgen.modgen,
              modulatorInfo: modgen.modgenInfo,
            };
          }

          /**
           *
           * @private
           * @param {Object[]} _zone
           * @param {number} indexStart
           * @param {number} indexEnd
           * @param {Array} zoneModGen
           * @returns {{ modgen: Object; modgenInfo: Object[] }}
           */
          createBagModGen_(_zone, indexStart, indexEnd, zoneModGen) {
            /** @type {Object[]} */
            const modgenInfo = [];
            /** @type {Object} */
            const modgen = {
              unknown: [],
              keyRange: {
                amount: null,
                hi: 127,
                lo: 0,
              },
            }; // TODO
            /** @type {Object} */
            let info;
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;

            for (i = indexStart, il = indexEnd; i < il; ++i) {
              info = zoneModGen[i];
              modgenInfo.push(info);

              if (info.type === 'unknown') {
                modgen.unknown.push(info.value);
              } else {
                modgen[info.type] = info.value;
              }
            }

            return {
              modgen: modgen,
              modgenInfo: modgenInfo,
            };
          }
        }

        /**
         * Synthesizer Class
         *
         * @author imaya
         */
        class Synthesizer {
          /** @param {Uint8Array} input */
          constructor(input) {
            /** @type {number} */
            let i;
            /** @type {Uint8Array} */
            this.input = input;
            /** @type {Parser} */
            this.parser;
            /** @type {number} */
            this.bank = 0;
            /** @type {Object} */
            this.bankSet = {};
            /** @type {number} */
            this.bufferSize = 2048;
            /** @type {AudioContext} */
            this.ctx = this.getAudioContext();
            /** @type {GainNode} */
            this.gainMaster = this.ctx.createGain();
            /** @type {AudioBufferSourceNode} */
            this.bufSrc = this.ctx.createBufferSource();
            /** @type {number[]} */
            this.channelInstrument = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.channelBank = [0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.channelVolume = [
              100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
              100,
            ];
            /** @type {number[]} */
            this.channelPanpot = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];
            /** @type {number[]} */
            this.channelPitchBend = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.channelPitchBendSensitivity = [
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            ];
            /** @type {number[]} */
            this.channelExpression = [
              127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
              127,
            ];
            /** @type {number[]} */
            this.channelAttack = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];
            /** @type {number[]} */
            this.channelDecay = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];
            /** @type {number[]} */
            this.channelSustin = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];
            /** @type {number[]} */
            this.channelRelease = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];

            /** @type {boolean[]} */
            this.channelHold = [
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
            ];
            /** @type {number[]} */
            this.channelHarmonicContent = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];
            /** @type {number[]} */
            this.channelCutOffFrequency = [
              64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
            ];

            /** @type {'GM'|'GM2'|'XG'|'GS'} */
            this.mode = 'GM2';

            /** @type {string[][]} */
            this.programSet = [];

            /** @type {boolean[]} */
            this.channelMute = [
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
            ];
            /** @type {SynthesizerNote[][]} */
            this.currentNoteOn = [
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
              [],
            ];
            /** @type {number} @const */
            this.baseVolume = 1 / 0xffff;
            /** @type {number} */
            this.masterVolume = 16384;

            /** @type {boolean[]} */
            this.percussionPart = [
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              true,
              false,
              false,
              false,
              false,
              false,
              false,
            ];

            /** @type {number[]} */
            this.percussionVolume = [];
            while (i === 127) {
              this.percussionVolume[i] = 127;
              i++;
            }

            /** @type {string[][]} */
            this.programSet = [];

            /** @type {Reverb[]} リバーブエフェクト（チャンネル毎に用意する） */
            this.reverb = [];

            /** @type {number[]} モジュレーション（ビブラート） */
            this.modulation = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

            /** @type {BiquadFilterNode[]} フィルタ */
            this.filter = [];

            for (i = 0; i < 16; ++i) {
              // @ts-ignore
              this.reverb[i] = new Reverb(this.ctx, {
                noise: 'violet'
              });
              // フィルタを定義
              this.filter[i] = this.ctx.createBiquadFilter();
            }

            /** 表示項目 */
            this.items = [];

            /** @type {IntersectionObserver} 交差していない */
            this.intersection = new IntersectionObserver(
              entries =>
              entries.forEach(entry => {
                // @ts-ignore
                entry.target.dataset.isIntersecting = entry.isIntersecting;
              }), {}
            );

            /** @type {number} タイマーのスレッド */
            this.timer = 0;
            /** @type {boolean} */
            this.drag = false;
          }

          /** @return {AudioContext} */
          getAudioContext() {
            /** @type {AudioContext} */
            const ctx = new AudioContext();

            // Defreeze AudioContext for iOS.
            const initAudioContext = () => {
              document.removeEventListener('touchstart', initAudioContext);
              /** @type {AudioBufferSourceNode} wake up AudioContext */
              const emptySource = ctx.createBufferSource();
              emptySource.start();
              emptySource.stop();
            };

            document.addEventListener('touchstart', initAudioContext);

            return ctx;
          }

          /**
           * System Reset
           *
           * @param {'GM'|'GM2'|'XG'|'GS'} mode 音源モード
           */
          init(mode = 'GM') {
            this.gainMaster.disconnect();

            this.refreshInstruments(this.input);

            this.mode = mode;

            for (let i = 0; i < 16; ++i) {
              this.setPercussionPart(i, i === 9);
              this.programChange(i, 0);
              this.volumeChange(i, 100);
              this.panpotChange(i, 64);
              this.pitchBend(i, 0x00, 0x40); // 8192
              this.pitchBendSensitivity(i, 2);
              this.hold(i, 0);
              this.expression(i, 127);
              this.bankSelectMsb(i, i === 9 ? 127 : 0);
              this.bankSelectLsb(i, i === 9 ? 127 : 0);
              this.attackTime(i, 64);
              this.decayTime(i, 64);
              this.sustinTime(i, 64);
              this.releaseTime(i, 64);
              this.harmonicContent(i, 64);
              this.cutOffFrequency(i, 64);
              this.reverbDepth(i, 40);
              this.modulationDepth(i, 0);

              this.updateBankSelect(i);
              this.updateProgramSelect(i);
            }

            this.setPercussionPart(9, true);

            for (let i = 0; i < 128; ++i) {
              this.percussionVolume[i] = 127;
            }

            this.setMasterVolume(8192);

            this.gainMaster.connect(this.ctx.destination);

            if (this.element) {
              /** @type {HTMLDivElement} */
              const modeElement = this.element.querySelector('.header .keys div');
              modeElement.innerText = mode + ' Mode';
              /** @type {NodeListOf<HTMLSelectElement>} */
              const bankSelectElement = this.element.querySelectorAll(
                `.instrument .bank > select`
              );

              bankSelectElement.forEach(element => (element.disabled = mode === 'GM'));
              this.element.dataset.mode = mode;
            }
          }

          /** Close AudioContext */
          async close() {
            await this.ctx.close();
          }

          /** @param {Uint8Array} input */
          refreshInstruments(input) {
            this.input = input;
            this.parser = new Parser(input, {
              sampleRate: this.ctx.sampleRate,
            });
            this.bankSet = this.createAllInstruments();
          }

          /** @returns {Object[][]} */
          createAllInstruments() {
            /** @type {Parser} */
            const parser = this.parser;
            parser.parse();
            /** @type {Array} TODO */
            const presets = parser.createPreset();
            /** @type {Array} TODO */
            const instruments = parser.createInstrument();
            /** @type {Array} */
            const banks = [];
            /** @type {Record<number, any>} */
            let bank;
            /** @type {number} */
            let bankNumber;
            /** @type {Object} */
            let instrument;
            /** @type {number} */
            let presetNumber;
            /** @type {string} */
            let presetName;

            const programSet = [];

            presets.forEach(preset => {
              presetNumber = preset.header.preset;
              bankNumber = preset.header.bank;
              presetName = preset.name.replace(/\0*$/, '');

              if (typeof preset.instrument !== 'number') {
                return;
              }

              instrument = instruments[preset.instrument];
              if (instrument.name.replace(/\0*$/, '') === 'EOI') {
                return;
              }

              // select bank
              if (banks[bankNumber] === void 0) {
                banks[bankNumber] = [];
              }
              bank = banks[bankNumber];
              bank[presetNumber] = {};
              bank[presetNumber].name = presetName;

              instrument.info.forEach(info =>
                this.createNoteInfo(parser, info, bank[presetNumber])
              );

              if (!programSet[bankNumber]) {
                programSet[bankNumber] = [];
              }
              programSet[bankNumber][presetNumber] = presetName;
            });

            this.programSet = programSet;

            return banks;
          }

          /**
           * @param {Parser} parser
           * @param {any} info
           * @param {any} preset
           */
          createNoteInfo(parser, info, preset) {
            /** @type {*} */
            const generator = info.generator;

            if (!generator.keyRange || !generator.sampleID) {
              return;
            }

            // デフォルト値
            // https://www.utsbox.com/?p=2390

            /** @type {number} 33: DelayVolEnv */
            const volDelay = this.getModGenAmount(generator, 'delayVolEnv');
            /** @type {number} 34: AttackVolEnv */
            const volAttack = this.getModGenAmount(generator, 'attackVolEnv');
            /** @type {number} 35: HoldVolEnv */
            const volHold = this.getModGenAmount(generator, 'holdVolEnv');
            /** @type {number} 36: DecayVolEnv */
            const volDecay = this.getModGenAmount(generator, 'decayVolEnv');
            /** @type {number} 37: SustainVolEnv */
            const volSustain = this.getModGenAmount(generator, 'sustainVolEnv');
            /** @type {number} 38: ReleaseVolEnv */
            const volRelease = this.getModGenAmount(generator, 'releaseVolEnv');
            /** @type {number} 25: DelayModEnv */
            const modDelay = this.getModGenAmount(generator, 'delayModEnv');
            /** @type {number} 26: AttackModEnv */
            const modAttack = this.getModGenAmount(generator, 'attackModEnv');
            /** @type {number} 27: HoldModEnv */
            const modHold = this.getModGenAmount(generator, 'holdModEnv');
            /** @type {number} 28: DecayModEnv */
            const modDecay = this.getModGenAmount(generator, 'decayModEnv');
            /** @type {number} 29: SustainModEnv */
            const modSustain = this.getModGenAmount(generator, 'sustainModEnv');
            /** @type {number} 30: ReleaseModEnv */
            const modRelease = this.getModGenAmount(generator, 'releaseModEnv');
            /** @type {number} 56: ScaleTuning */
            const scale = this.getModGenAmount(generator, 'scaleTuning') / 100;
            /** @type {number} */
            const tune =
              this.getModGenAmount(generator, 'coarseTune') +
              this.getModGenAmount(generator, 'fineTune') / 100;
            /** @type {number} */
            const sampleModes = this.getModGenAmount(generator, 'sampleModes');

            for (
              let i = generator.keyRange.lo, il = generator.keyRange.hi; i <= il;
              ++i
            ) {
              if (preset[i]) {
                continue;
              }
              /** @type {number} */
              const sampleId = this.getModGenAmount(generator, 'sampleID');
              /** @type {object} */
              const sampleHeader = parser.sampleHeader[sampleId];

              preset[i] = {
                sample: parser.sample[sampleId],
                sampleRate: sampleHeader.sampleRate,
                // 54
                sampleModes: sampleModes,
                basePlaybackRate: 1.0594630943592953 ** // Math.pow(2, 1 / 12)
                  ((i -
                      this.getModGenAmount(generator, 'overridingRootKey') +
                      tune +
                      sampleHeader.pitchCorrection / 100) *
                    scale),
                modEnvToPitch: this.getModGenAmount(generator, 'modEnvToPitch') / 100,
                scaleTuning: scale,
                start: this.getModGenAmount(generator, 'startAddrsCoarseOffset') * 32768 +
                  this.getModGenAmount(generator, 'startAddrsOffset'),
                end: this.getModGenAmount(generator, 'endAddrsCoarseOffset') * 32768 +
                  this.getModGenAmount(generator, 'endAddrsOffset'),
                loopStart:
                  // (sampleHeader.startLoop - sampleHeader.start) +
                  sampleHeader.startLoop +
                  this.getModGenAmount(generator, 'startloopAddrsCoarseOffset') *
                  32768 +
                  this.getModGenAmount(generator, 'startloopAddrsOffset'),
                loopEnd:
                  // (sampleHeader.endLoop - sampleHeader.start) +
                  sampleHeader.endLoop +
                  this.getModGenAmount(generator, 'endloopAddrsCoarseOffset') * 32768 +
                  this.getModGenAmount(generator, 'endloopAddrsOffset'),
                volDelay: 2 ** (volDelay / 1200),
                volAttack: 2 ** (volAttack / 1200),
                volHold: 2 ** (volHold / 1200) *
                  2 **
                  (((60 - i) *
                      this.getModGenAmount(generator, 'keynumToVolEnvHold')) /
                    1200),
                volDecay: 2 ** (volDecay / 1200) *
                  2 **
                  (((60 - i) *
                      this.getModGenAmount(generator, 'keynumToVolEnvDecay')) /
                    1200),
                volSustain: volSustain / 1000,
                volRelease: 2 ** (volRelease / 1200),
                modDelay: 2 ** (modDelay / 1200),
                modAttack: 2 ** (modAttack / 1200),
                modHold: 2 ** (modHold / 1200) *
                  2 **
                  (((60 - i) *
                      this.getModGenAmount(generator, 'keynumToModEnvHold')) /
                    1200),
                modDecay: 2 ** (modDecay / 1200) *
                  2 **
                  (((60 - i) *
                      this.getModGenAmount(generator, 'keynumToModEnvDecay')) /
                    1200),
                modSustain: modSustain / 1000,
                modRelease: 2 ** (modRelease / 1200),
                initialFilterFc: 8.176 *
                  Math.pow(
                    2,
                    this.getModGenAmount(generator, 'initialFilterFc') / 1200
                  ),
                modEnvToFilterFc: this.getModGenAmount(generator, 'modEnvToFilterFc') / 100,
                initialFilterQ: this.getModGenAmount(generator, 'initialFilterQ') / 10,
                reverbEffectSend: this.getModGenAmount(generator, 'reverbEffectSend') / 10,
                initialAttenuation: this.getModGenAmount(generator, 'initialAttenuation') / 10,
                freqVibLFO: 8.176 *
                  Math.pow(2, this.getModGenAmount(generator, 'freqVibLFO') / 1200),
                pan: this.getModGenAmount(generator, 'pan') / 1200,
              };
            }
          }

          /**
           * @param {Object} generator
           * @param {string} enumeratorType
           * @return {number}
           */
          getModGenAmount(generator, enumeratorType) {
            return generator[enumeratorType] ?
              generator[enumeratorType].amount :
              this.parser.getGeneratorTable()[enumeratorType];
          }

          /**
           * Start Tone Generator
           */
          start() {
            this.connect();
            this.bufSrc.start(0);
            this.setMasterVolume(16383);
          }

          /** @param {number} volume */
          setMasterVolume(volume) {
            this.masterVolume = volume;
            this.gainMaster.gain.value = this.baseVolume * (volume / 16384);
          }

          /** Connect root AudioContext */
          connect() {
            this.bufSrc.connect(this.gainMaster);
          }

          /** Disconnect root AudioContext */
          disconnect() {
            this.bufSrc.disconnect(this.gainMaster);
            this.bufSrc.buffer = null;
          }

          /** @return {HTMLDivElement} */
          drawSynth() {
            /** @type {Document} */
            const doc = window.document;
            /** @type {HTMLDivElement} */
            const wrapper = (this.element = doc.createElement('div'));
            wrapper.className = 'synthesizer';
            /** @type {HTMLDivElement} */
            const instElem = doc.createElement('div');
            instElem.className = 'instrument';
            /** @type {string[]} */
            this.items = [
              'mute',
              'bank',
              'program',
              'volume',
              'expression',
              'panpot',
              'pitchBend',
              'pitchBendSensitivity',
              'reverbDepth',
              'keys',
            ];
            /** @type {string} */
            const eventStart = 'ontouchstart' in window ? 'touchstart' : 'mousedown';
            /** @type {string} */
            const eventEnd = 'ontouchend' in window ? 'touchend' : 'mouseup';

            for (let channel = 0; channel < 16; channel++) {
              /** @type {HTMLDivElement} */
              const channelElem = doc.createElement('div');
              channelElem.className = 'channel';
              // ホールドを無効化する処理
              channelElem.addEventListener(eventStart, () => {
                this.hold(channel, 0);
              });
              for (const item in this.items) {
                if (!{}.hasOwnProperty.call(this.items, item)) {
                  continue;
                }
                /** @type {HTMLDivElement} */
                const itemElem = doc.createElement('div');
                itemElem.className = this.items[item];

                switch (this.items[item]) {
                  case 'mute': {
                    /** @type {HTMLDivElement | null} */
                    const checkboxElement = doc.createElement('div');
                    checkboxElement.className = 'form-check form-check-inline';
                    /** @type {HTMLInputElement | null} */
                    const checkbox = doc.createElement('input');
                    checkbox.ariaLabel = `Ch.${channel + 1} Mute`;
                    checkbox.setAttribute('type', 'checkbox');
                    checkbox.className = 'form-check-input';
                    checkbox.id = 'mute' + channel + 'ch';
                    checkbox.value = channel.toString();
                    checkbox.addEventListener(
                      'change',
                      event => {
                        // @ts-ignore
                        this.mute(channel, event.target.checked);
                      },
                      false
                    );
                    checkboxElement.appendChild(checkbox);
                    /** @type {HTMLLabelElement} */
                    const labelElem = doc.createElement('label');

                    labelElem.className = 'form-check-label';
                    labelElem.textContent = (channel + 1).toString();
                    labelElem.setAttribute('for', 'mute' + channel + 'ch');
                    checkboxElement.appendChild(labelElem);
                    itemElem.appendChild(checkboxElement);
                    break;
                  }
                  case 'bank': {
                    /** @type {HTMLSelectElement} Bank select */
                    const bankSelect = doc.createElement('select');
                    bankSelect.ariaLabel = `Ch.${channel + 1} Bank Select`;
                    bankSelect.className = 'form-select form-select-sm bank-select';
                    bankSelect.addEventListener(
                      'change',
                      ((synth, ch) => event => {
                        /** @type {HTMLSelectElement} */
                        const program = channelElem.querySelector('.program select');
                        // console.log(ch, event.target.value, program);
                        // @ts-ignore
                        synth.bankChange(ch, event.target.value);
                        synth.programChange(ch, parseInt(program.value));
                      })(this, channel),
                      false
                    );
                    itemElem.appendChild(bankSelect);
                    break;
                  }
                  case 'program': {
                    /** @type {HTMLSelectElement} Program change */
                    const select = doc.createElement('select');
                    select.className = 'form-select form-select-sm';
                    select.ariaLabel = `Ch.${channel + 1} Program Change`;
                    select.addEventListener(
                      'change',
                      ((synth, ch) => event => {
                        // @ts-ignore
                        synth.programChange(ch, event.target.value);
                      })(this, channel),
                      false
                    );
                    itemElem.appendChild(select);
                    break;
                  }
                  case 'volume': {
                    /** @type {HTMLElement} */
                    const volumeElem = document.createElement('var');
                    volumeElem.ariaLabel = `Ch.${channel + 1} Volume`;
                    volumeElem.innerText = '100';
                    itemElem.appendChild(volumeElem);
                    break;
                  }
                  case 'expression': {
                    /** @type {HTMLElement} */
                    const expressionElem = document.createElement('var');
                    expressionElem.ariaLabel = `Ch.${channel + 1} Expression`;
                    expressionElem.innerText = '127';
                    itemElem.appendChild(expressionElem);
                    break;
                  }
                  case 'pitchBendSensitivity': {
                    /** @type {HTMLElement} */
                    const pitchSensElem = document.createElement('var');
                    pitchSensElem.ariaLabel = `Ch.${
                    channel + 1
                  } Pitch Bend Sensitivity`;
                    pitchSensElem.innerText = '2';
                    itemElem.appendChild(pitchSensElem);
                    break;
                  }
                  case 'reverbDepth': {
                    /** @type {HTMLElement} */
                    const reverbDepthElem = document.createElement('var');
                    reverbDepthElem.ariaLabel = `Ch.${channel + 1} Reverb Depth`;
                    reverbDepthElem.innerText = '40';
                    itemElem.appendChild(reverbDepthElem);
                    break;
                  }
                  case 'panpot': {
                    /** @type {HTMLDivElement} */
                    const panpotOuter = doc.createElement('div');
                    panpotOuter.role = 'progressbar';
                    panpotOuter.ariaLabel = `Ch.${channel + 1} Panpod`;
                    panpotOuter.ariaValueMin = '0';
                    panpotOuter.ariaValueNow = '64';
                    panpotOuter.ariaValueMax = '127';
                    panpotOuter.className = 'progress';
                    const panpot = doc.createElement('div');
                    // 緑色
                    panpot.className = 'progress-bar';
                    panpotOuter.appendChild(panpot);
                    itemElem.appendChild(panpotOuter);
                    break;
                  }
                  case 'pitchBend': {
                    /** @type {HTMLDivElement} */
                    const pitchOuter = doc.createElement('div');
                    pitchOuter.className = 'progress';
                    pitchOuter.role = 'progressbar';
                    pitchOuter.ariaLabel = `Ch.${channel + 1} Pitch Bend`;
                    pitchOuter.ariaValueMin = '-8192';
                    pitchOuter.ariaValueNow = '0';
                    pitchOuter.ariaValueMax = '8192';
                    pitchOuter.className = 'progress';
                    /** @type {HTMLDivElement} */
                    const pitch = doc.createElement('div');
                    // 黄色
                    pitch.className = 'progress-bar progress-bar-animated';
                    pitchOuter.appendChild(pitch);
                    itemElem.appendChild(pitchOuter);
                    break;
                  }
                  case 'keys': {
                    // 鍵盤の描画
                    for (let key = 0; key < 127; key++) {
                      /** @type {HTMLDivElement} */
                      const keyElem = doc.createElement('div');
                      /** @type {number} */
                      const n = key % 12;
                      // 白鍵と黒鍵の色分け
                      keyElem.className =
                        'key ' + ([1, 3, 6, 8, 10].includes(n) ? 'semitone' : 'tone');
                      itemElem.appendChild(keyElem);

                      // イベント割当
                      keyElem.addEventListener(
                        eventStart,
                        ((synth, ch, k) => event => {
                          event.preventDefault();
                          synth.drag = true;
                          synth.noteOn(ch, k, 127);
                        })(this, channel, key)
                      );
                      keyElem.addEventListener(
                        'mouseover',
                        ((synth, ch, k) => event => {
                          event.preventDefault();
                          if (synth.drag) {
                            synth.noteOn(ch, k, 127);
                          }
                        })(this, channel, key)
                      );
                      keyElem.addEventListener(
                        'mouseout',
                        ((synth, ch, k) => event => {
                          event.preventDefault();
                          synth.noteOff(ch, k);
                        })(this, channel, key)
                      );
                      keyElem.addEventListener(
                        eventEnd,
                        ((synth, ch, k) => event => {
                          event.preventDefault();
                          synth.drag = false;
                          synth.noteOff(ch, k);
                        })(this, channel, key)
                      );
                    }
                    break;
                  }
                }
                channelElem.appendChild(itemElem);
              }
              instElem.appendChild(channelElem);
              this.intersection.observe(channelElem);
            }
            // ヘッダー行の描画
            const itemName = [
              'Ch.',
              'Bank',
              'Program',
              'Vol.',
              'Exp.',
              'Panpot',
              'Pitch Bend',
              '',
              'Rev.',
              '',
            ];
            /** @type {HTMLDivElement} */
            const headerElem = doc.createElement('div');
            headerElem.className = 'header';
            for (const item in this.items) {
              if (!{}.hasOwnProperty.call(this.items, item)) {
                continue;
              }
              /** @type {HTMLDivElement} */
              const itemElem = doc.createElement('div');
              itemElem.className = this.items[item];
              itemElem.textContent = itemName[item];
              if (this.items[item] === 'keys') {
                // MIDI音源のLCDのテキスト領域エミュレーター
                itemElem.appendChild(document.createElement('code'));
                // GM / GS / XG表記
                itemElem.appendChild(document.createElement('div'));
              }
              headerElem.appendChild(itemElem);
            }
            instElem.prepend(headerElem);
            wrapper.appendChild(instElem);

            // ヘッダー行のリサイズ
            const ro = new ResizeObserver(_entries => {
              this.items.forEach(item => {
                /** @type {HTMLElement} */
                const headerItem = wrapper.querySelector(`.header .${item}`);
                /** @type {HTMLElement} */
                const channelItem = wrapper.querySelector(`.channel .${item}`);

                headerItem.style.width = channelItem.offsetWidth + 'px';
              });
              /** @type {HTMLElement} */
              const keysItem = wrapper.querySelector(`.header .keys`);

              keysItem.style.display =
                document.documentElement.clientWidth <= 680 ? 'none' : 'flex';
            });
            ro.observe(wrapper);

            return wrapper;
          }

          /**
           * シンセサイザーのDOMの更新
           *
           * @param {number} channel
           * @param {number} key
           * @param {number} velocity
           */
          updateSynthElement(channel, key, velocity) {
            if (!this.element) {
              return;
            }
            /** @type {NodeListOf<HTMLDivElement>} */
            const channelElems = this.element.querySelectorAll(
              `.instrument > .channel`
            );

            if (channelElems[channel].dataset.isIntersecting) {
              /** @type {HTMLDivElement} */
              const keyElem = channelElems[channel].querySelector(
                `.key:nth-child(${key + 1})`
              );
              if (velocity === 0) {
                if (keyElem.classList.contains('note-on')) {
                  keyElem.classList.remove('note-on');
                }
                keyElem.style.opacity = '1';
              } else {
                keyElem.classList.add('note-on');
                // ベロシティに応じて透過度を調整
                keyElem.style.opacity = (velocity / 127).toFixed(2);
              }
            }
          }

          /**
           * バンクセレクタの選択ボックスの処理
           *
           * @param {number} channel
           */
          updateBankSelect(channel) {
            if (!this.element) {
              return;
            }
            /** @type {HTMLElement} */
            const bankElement = this.element
              .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.bank > select');

            while (bankElement.firstChild)
              bankElement.removeChild(bankElement.firstChild);

            for (const bankNo in this.programSet) {
              if (!{}.hasOwnProperty.call(this.programSet, bankNo)) {
                continue;
              }
              const option = document.createElement('option');
              option.value = bankNo;
              option.textContent = ('000' + parseInt(bankNo)).slice(-3);
              if (parseInt(bankNo) === this.channelBank[channel]) {
                option.selected = true;
              }
              bankElement.appendChild(option);
            }
          }

          /**
           * プログラムチェンジの選択ボックスの処理
           *
           * @param {number} channel
           */
          updateProgramSelect(channel) {
            if (!this.element) {
              return;
            }
            const dom = this.element.querySelectorAll(`.instrument > .channel`)[
              channel
            ];

            /** @type {number} */
            const bankIndex = this.channelBank[channel];
            /** @type {HTMLSelectElement} */
            const bankElement = dom.querySelector('.bank > select');
            /** @type {HTMLSelectElement} */
            const programElement = dom.querySelector('.program > select');

            bankElement.value = this.channelBank[channel].toString();
            while (programElement.firstChild)
              programElement.removeChild(programElement.firstChild);

            for (const programNo in this.programSet[bankIndex]) {
              if (!{}.hasOwnProperty.call(this.programSet[bankIndex], programNo)) {
                continue;
              }
              // TODO: 存在しないプログラムの場合、現状では空白になってしまう
              /** @type {HTMLOptionElement} */
              const option = document.createElement('option');
              option.value = programNo;
              option.textContent = `${('000' + (parseInt(programNo) + 1)).slice(-3)}:${
              this.programSet[bankIndex][programNo]
            }`;
              if (parseInt(programNo) === this.channelInstrument[channel]) {
                option.selected = true;
              }
              programElement.appendChild(option);
            }
          }

          /**
           * ノートオン
           *
           * @param {number} channel NoteOn するチャンネル.
           * @param {number} key NoteOn するキー.
           * @param {number} velocity 強さ.
           */
          noteOn(channel, key, velocity = 100) {
            /** @type {number} */
            const bankIndex = this.channelBank[channel];
            // バンクに楽器が存在しない場合は、原則的にバンク0の楽器を選択する。
            // ただし、SFX(Bank 64)は発音しない、
            // パーカッション（Bank127~128) の場合、0のStandard Kitの音を鳴らさなければならない）
            /** @type {Object} */
            const bank =
              typeof this.bankSet[bankIndex] === 'object' ?
              this.bankSet[bankIndex] :
              this.bankSet[0];

            /** @type {Object} */
            let instrument;

            if (typeof bank[this.channelInstrument[channel]] === 'object') {
              // 音色が存在する場合
              instrument = bank[this.channelInstrument[channel]];
            } else if (this.percussionPart[channel]) {
              // パーカッションバンクが選択されている場合で音色が存在しない場合Standard Kitを選択
              instrument = this.bankSet[this.mode === 'XG' ? 127 : 128][0];
            } else {
              // 通常の音色が選択されている状態で音色が存在しない場合バンク0を選択
              instrument = this.bankSet[0][this.channelInstrument[channel]];
            }

            if (instrument[key] === void 0) {
              // TODO
              console.warn(
                'instrument not found: bank=%s instrument=%s channel=%s key=%s',
                bankIndex,
                this.channelInstrument[channel],
                channel,
                key
              );
              return;
            }
            /** @type {Object} */
            const instrumentKey = instrument[key];
            /** @type {number} */
            let panpot =
              this.channelPanpot[channel] === 0 ?
              Math.floor(Math.random() * 127) // パンが0の場合ランダムとなる。
              :
              this.channelPanpot[channel] - 64;
            panpot /= panpot < 0 ? 64 : 63;

            // create note information
            instrumentKey['channel'] = channel;
            instrumentKey['key'] = key;
            instrumentKey['velocity'] = velocity;
            instrumentKey['panpot'] = panpot;
            instrumentKey['volume'] = this.channelVolume[channel] / 127;
            instrumentKey['pitchBend'] = this.channelPitchBend[channel] - 8192;
            instrumentKey['expression'] = this.channelExpression[channel];
            instrumentKey['pitchBendSensitivity'] = Math.round(
              this.channelPitchBendSensitivity[channel]
            );
            instrumentKey['mute'] = this.channelMute[channel];
            instrumentKey['releaseTime'] = this.channelRelease[channel];
            instrumentKey['cutOffFrequency'] = this.cutOffFrequency[channel];
            instrumentKey['harmonicContent'] = this.harmonicContent[channel];
            instrumentKey['reverb'] = this.reverb[channel];
            instrumentKey['modulation'] = this.modulation[channel];

            // percussion
            if (bankIndex >= 127) {
              // ドラムパートのハイハットクローズはここで定義するべきではない。
              if (key === 42 || key === 44) {
                // 42: Closed Hi-Hat
                // 44: Pedal Hi-Hat
                // 46: Open Hi-Hat
                this.noteOff(channel, 46);
              }
              if (key === 80) {
                // 80: Mute Triangle
                // 81: Open Triangle
                this.noteOff(channel, 81);
              }
              instrument['volume'] *= this.percussionVolume[key] / 127;
            }

            // note on
            /** @type {SynthesizerNote} */
            const note = new SynthesizerNote(this.ctx, this.gainMaster, instrumentKey);
            // TODO: 本来パンポットはここで指定する
            note.noteOn();
            this.currentNoteOn[channel].push(note);

            this.updateSynthElement(channel, key, velocity);
          }

          /**
           * ノートオフ
           *
           * @param {number} channel NoteOff するチャンネル.
           * @param {number} key NoteOff するキー.
           */
          noteOff(channel, key) {
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];
            /** @type {SynthesizerNote} */
            let note;
            /** @type {boolean} */
            const hold = this.channelHold[channel];

            for (i = 0, il = currentNoteOn.length; i < il; ++i) {
              note = currentNoteOn[i];
              if (note.key === key) {
                note.noteOff();
                // hold している時は NoteOff にはするがリリースはしない
                if (!hold) {
                  note.release();
                  currentNoteOn.splice(i, 1);
                  --i;
                  --il;
                }
              }
            }
            this.updateSynthElement(channel, key, 0);
          }

          /**
           * ホールド（ダンパーペダル）
           *
           * @param {number} channel ホールドするチャンネル
           * @param {number} value 値
           */
          hold(channel, value) {
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];
            /** @type {boolean} 0以外はonである。 */
            const hold = (this.channelHold[channel] = value > 64);
            /** @type {SynthesizerNote} */
            let note;
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;

            if (!hold) {
              for (i = 0, il = currentNoteOn.length; i < il; ++i) {
                note = currentNoteOn[i];
                if (note.isNoteOff()) {
                  note.release();
                  currentNoteOn.splice(i, 1);
                  --i;
                  --il;
                }
              }
            }

            if (this.element) {
              /** @type {NodeListOf<HTMLDivElement>} */
              const channelElements = this.element.querySelectorAll(
                `.instrument > .channel`
              );

              if (!channelElements[channel]) {
                return;
              }
              if (this.channelHold[channel]) {
                channelElements[channel].classList.add('hold');
              } else if (channelElements[channel].classList.contains('hold')) {
                channelElements[channel].classList.remove('hold');
              }
            }
          }

          /**
           * バンクセレクトMSB（GS音源/GM Level2用）
           *
           * @param {number} channel チャンネルのバンクセレクトMSB
           * @param {number} value 値
           */
          bankSelectMsb(channel, value) {
            // 125より値が大きい場合、パーカッションとして処理
            this.percussionPart[channel] = value >= 125;
            // 念の為バンクを0にリセット
            this.channelBank[channel] = channel === 9 ? 128 : 0;

            if (this.mode === 'GM') {
              // GM音源モードのときはバンク・セレクトを無視
              return;
            } else if (this.mode === 'XG') {
              // XG音源は、MSB→LSBの優先順でバンクセレクトをする。
              if (value === 64) {
                // Bank Select MSB #64 (Voice Type: SFX)
                this.channelBank[channel] = 125;
              } else if (value === 126 || value === 127) {
                // Bank Select MSB #126 (Voice Type: Drum)
                // Bank Select MSB #127 (Voice Type: Drum)
                this.channelBank[channel] = value;
              } else if (value === 128) {
                this.channelBank[channel] = 127;
              }
            } else {
              // GS音源
              // ※チャンネル10のバンク・セレクト命令は無視する。
              this.channelBank[channel] = channel === 9 ? 128 : value;
              this.percussionPart[channel] = value === 128;
            }
            this.updateBankSelect(channel);
          }

          /**
           * バンクセレクトLSB（XG音源）
           *
           * @param {number} channel チャンネルのバンクセレクトLSB
           * @param {number} value 値
           */
          bankSelectLsb(channel, value) {
            // XG音源以外は処理しない
            if (this.mode !== 'XG') {
              return;
            }

            if (!this.percussionPart[channel]) {
              // ドラムパートではバンクセレクトLSB命令を無視する。
              this.channelBank[channel] = value;
            }

            this.updateBankSelect(channel);
          }

          /**
           * プログラムチェンジ
           *
           * @param {number} channel 音色を変更するチャンネル.
           * @param {number} instrument 音色番号.
           */
          programChange(channel, instrument) {
            this.channelInstrument[channel] = instrument;

            this.bankChange(channel, this.channelBank[channel]);
            if (this.element) {
              /** @type {HTMLSelectElement} */
              const select = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.program > select');

              select.value = instrument.toString();
            }
          }

          /**
           * バンクセレクト
           *
           * @param {number} channel 音色を変更するチャンネル.
           * @param {number} bank バンク・セレクト.
           */
          bankChange(channel, bank) {
            /** パーカッションバンク */
            const percussionBank = this.mode === 'XG' ? 127 : 128;
            if (this.mode === 'GM') {
              // GMの場合バンクセレクトを無効化
              bank = 0;
            }
            if (channel === 9) {
              // GS、XGフラグが立っていない（拡張音源ではない）場合は、ch10はドラム固定、それ以外は0とする。
              bank = percussionBank;
            }
            if (this.bankSet[bank]) {
              this.channelBank[channel] = bank;
            } else {
              // 存在しない場合0を選択
              this.channelBank[channel] = this.percussionPart[channel] ?
                percussionBank :
                0;
            }
            // }

            if (this.element) {
              /** @type {HTMLSelectElement} バンクセレクトの値 */
              const bankSelect = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.bank > select');
              bankSelect.value = bank.toString();
            }
            // TODO: 厳密にはMIDI音源はプログラムチェンジがあったときに、バンク・セレクトの値が反映されるのでこの実装は正しくない。
            this.updateProgramSelect(channel);
          }

          /**
           * ボリューム
           *
           * @param {number} channel 音量を変更するチャンネル.
           * @param {number} volume 音量(0-127).
           */
          volumeChange(channel, volume) {
            if (this.element) {
              /** @type {HTMLElement} */
              const volumeVariable = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.volume var');
              volumeVariable.innerText = volume.toString();
            }

            this.channelVolume[channel] = volume;
          }

          /**
           * エクスプレッション
           *
           * @param {number} channel 音量を変更するチャンネル.
           * @param {number} expression 音量(0-127).
           */
          expression(channel, expression) {
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];

            for (i = 0, il = currentNoteOn.length; i < il; ++i) {
              currentNoteOn[i].updateExpression(expression);
            }

            if (this.element) {
              /** @type {HTMLElement} */
              const expressionVariabe = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.expression var');

              expressionVariabe.innerText = expression.toString();
            }

            this.channelExpression[channel] = expression;
          }

          /**
           * パンポット
           *
           * @param {number} channel Panpot を変更するチャンネル.
           * @param {number} panpot Panpot(0-127).
           */
          panpotChange(channel, panpot) {
            this.channelPanpot[channel] = panpot;
            if (this.element) {
              const dom = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.panpot');
              dom.ariaValueNow = panpot.toString();
              /** @type {HTMLDivElement} */
              const progressBar = dom.querySelector('.progress-bar');
              const percentage = (panpot / 127) * 100;
              progressBar.style.width = `${percentage}%`;
              progressBar.classList.remove('left', 'right');
              progressBar.title = panpot.toString();
              if (panpot === 64) {
                return;
              }
              dom.classList.add(panpot < 63 ? 'left' : 'right');
            }
          }

          /**
           * ピッチベンド
           *
           * @param {number} channel ピッチベンドを変更するチャンネル.
           * @param {number} lowerByte
           * @param {number} higherByte
           */
          pitchBend(channel, lowerByte, higherByte) {
            /** @type {number} */
            const bend = (lowerByte & 0x7f) | ((higherByte & 0x7f) << 7);
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;
            /** @type {import('./sound_font_synth_note').default[]} */
            const currentNoteOn = this.currentNoteOn[channel];
            /** @type {number} */
            const calculated = bend - 8192;

            for (i = 0, il = currentNoteOn.length; i < il; ++i) {
              currentNoteOn[i].updatePitchBend(calculated);
            }

            this.channelPitchBend[channel] = bend;

            if (this.element) {
              /** @type {HTMLDivElement} */
              const dom = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.pitchBend');
              dom.ariaValueNow = bend.toString();
              /** @type {HTMLDivElement} */
              const progressBar = dom.querySelector('.progress-bar');
              progressBar.style.width = `${Math.floor((bend / 16384) * 100)}%`;
              progressBar.title = calculated.toString();
              progressBar.classList.remove('high', 'low');
              if (calculated === 0) {
                return;
              }
              progressBar.classList.add(calculated < 0 ? 'low' : 'high');
            }
          }

          /**
           * ピッチベンド・センシビリティ
           *
           * @param {number} channel Pitch bend sensitivity を変更するチャンネル.
           * @param {number} sensitivity
           */
          pitchBendSensitivity(channel, sensitivity) {
            if (this.element) {
              /** @type {HTMLElement} */
              const pitchBendSensitivityVariable = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.pitchBendSensitivity > var');
              pitchBendSensitivityVariable.innerText = sensitivity.toString();
            }
            this.channelPitchBendSensitivity[channel] = sensitivity;
          }

          /**
           * アタックタイム
           *
           * @param {number} channel
           * @param {number} attackTime
           */
          attackTime(channel, attackTime) {
            this.channelAttack[channel] = attackTime;
          }

          /**
           * ディケイタイム
           *
           * @param {number} channel
           * @param {number} decayTime
           */
          decayTime(channel, decayTime) {
            this.channelDecay[channel] = decayTime;
          }

          /**
           * サスティンタイム
           *
           * @param {number} channel
           * @param {number} sustinTime
           */
          sustinTime(channel, sustinTime) {
            this.channelSustin[channel] = sustinTime;
          }

          /**
           * リリースタイム
           *
           * @param {number} channel
           * @param {number} releaseTime
           */
          releaseTime(channel, releaseTime) {
            this.channelRelease[channel] = releaseTime;
          }

          /**
           * ハーモニックコンテント（ブライトネス）
           *
           * @param {number} channel
           * @param {number} value
           */
          harmonicContent(channel, value) {
            this.channelHarmonicContent[channel] = value;
          }

          /**
           * カットオフフリクエンシー
           *
           * @param {number} channel
           * @param {number} value
           */
          cutOffFrequency(channel, value) {
            this.channelCutOffFrequency[channel] = value;
          }

          /**
           * リバーブエフェクト
           *
           * @param {number} channel
           * @param {number} depth
           */
          reverbDepth(channel, depth) {
            // リバーブ深度は、ドライ／ウェット比とする。
            this.reverb[channel].mix(depth / 127);

            if (this.element) {
              /** @type {HTMLElement} */
              const reverbVariable = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.reverbDepth var');
              reverbVariable.innerText = depth.toString();
            }
          }

          /**
           * モジュレーション（ビブラート）デプス
           *
           * @param {number} channel
           * @param {number} depth
           */
          modulationDepth(channel, depth) {
            if (this.element) {
              const dom = this.element
                .querySelectorAll(`.instrument > .channel`)[channel].querySelector('.pitchBend .progress-bar');

              // モデレーターが0でないときは、ピッチに斜め線を入れる
              if (depth !== 0) {
                dom.classList.add('progress-bar-striped');
              } else {
                dom.classList.remove('progress-bar-striped');
              }
            }
            this.modulation[channel] = depth;
          }

          /**
           * @param {number} channel Pitch bend sensitivity を取得するチャンネル.
           * @return {number}
           */
          getPitchBendSensitivity(channel) {
            return this.channelPitchBendSensitivity[channel];
          }

          /**
           * @param {number} key
           * @param {number} volume
           */
          drumInstrumentLevel(key, volume) {
            this.percussionVolume[key] = volume;
          }

          /**
           * オールノートオフ
           *
           * @param {number} channel NoteOff するチャンネル.
           */
          allNoteOff(channel) {
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];

            // ホールドを解除
            this.hold(channel, 0);

            // 再生中の音をすべて止める
            while (currentNoteOn.length > 0) {
              this.noteOff(channel, currentNoteOn[0].key);
            }
          }

          /**
           * オールサウンドオフ
           *
           * @param {number} channel 音を消すチャンネル.
           */
          allSoundOff(channel) {
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];
            /** @type {SynthesizerNote} */
            let note;

            while (currentNoteOn.length > 0) {
              note = currentNoteOn.shift();
              this.noteOff(channel, note.key);
              note.release();
              note.disconnect();
            }

            // ホールドを解除
            this.hold(channel, 0);
          }

          /**
           * リセットオールコントロール
           *
           * @param {number} channel リセットするチャンネル
           */
          resetAllControl(channel) {
            // 実装不十分では？
            this.allNoteOff(channel);
            this.expression(channel, 127);
            this.pitchBend(channel, 0x00, 0x40);
          }

          /**
           * ミュート
           *
           * @param {number} channel ミュートの設定を変更するチャンネル.
           * @param {boolean} mute ミュートにするなら true.
           */
          mute(channel, mute) {
            /** @type {SynthesizerNote[]} */
            const currentNoteOn = this.currentNoteOn[channel];
            /** @type {number} */
            let i;
            /** @type {number} */
            let il;

            this.channelMute[channel] = mute;

            if (mute) {
              for (i = 0, il = currentNoteOn.length; i < il; ++i) {
                currentNoteOn[i].disconnect();
              }
            } else {
              for (i = 0, il = currentNoteOn.length; i < il; ++i) {
                currentNoteOn[i].connect();
              }
            }
          }

          /**
           * パーカッションチャネルにする
           *
           * @param {number} channel パーカッションチャネルとしてセットするチャンネル
           * @param {boolean} sw パーカッションチャネルか通常かのスイッチ
           */
          setPercussionPart(channel, sw) {
            if (this.mode === 'GS' || this.mode === 'GM2') {
              // GM Level2 / Roland GS
              this.channelBank[channel] = 128;
            } else {
              // YAMAHA XG
              this.channelBank[channel] = 127;
            }
            this.percussionPart[channel] = sw;
            this.updateBankSelect(channel);
          }

          /**
           * MIDI音源のメッセージ欄に送られるsysExを解析
           *
           * @param {number[]} message
           */
          processMidiMessage(message) {
            clearTimeout(this.timer);
            /** @type {HTMLElement} */
            const dom = this.element.querySelector('.header .keys code');
            dom.innerText = message.map(e => String.fromCharCode(e)).join('');

            // 10秒後に削除
            this.timer = setTimeout(() => {
              dom.innerText = '';
            }, 50000);
          }
        }

        /**
         * @classdesc File Loader Class
         * @private
         * @author Logue <logue@hotmail.co.jp>
         */
        class Loader {
          /** キャッシュの名前空間 */
          static CACHE_NAME = 'wml';
          /**
           * コンストラクタ
           *
           * @constructor
           * @param {string} url
           * @param {HTMLDivElement} placeholder
           * @param {boolean} cache
           * @param {Function} callback
           */
          constructor(url, placeholder, cache, callback) {
            this.url = url;
            this.cache = cache;
            this.callback = callback;

            /** @type {HTMLDivElement} */
            this.alert = document.createElement('div');
            this.alert.className = 'alert alert-warning';

            /** @type {HTMLParagraphElement} */
            this.message = document.createElement('p');
            this.message.innerText = 'Now Loading...';

            /** @type {HTMLDivElement} */
            this.progressOuter = document.createElement('div');
            this.progressOuter.className = 'progress';
            this.progressOuter.role = 'progressbar';
            this.progressOuter.ariaLabel = `Loading Progress`;
            this.progressOuter.ariaValueMin = '0';
            this.progressOuter.ariaValueNow = '0';
            this.progressOuter.ariaValueMax = '100';

            /** @type {HTMLDivElement} */
            this.progress = document.createElement('div');
            this.progress.className = 'progress-bar';

            this.progressOuter.appendChild(this.progress);
            this.alert.appendChild(this.message);
            this.alert.appendChild(this.progressOuter);

            placeholder.appendChild(this.alert);
          }

          /**
           * ダウンロード中のハンドラ
           * @param {number} current
           * @param {number} total
           * @private
           */
          onProgress(current, total) {
            const percentCompleted = Math.floor((current / total) * 100);
            this.progress.style.width = `${percentCompleted}%`;
            this.progress.innerText = `${percentCompleted}%`;
          }

          /**
           * ロード完了時のハンドラ
           *
           * @param {ArrayBuffer} buffer
           * @private
           */
          onComplete(buffer) {
            this.alert.className = 'alert alert-info';
            this.message.innerText = 'Initializing...';
            this.progress.className =
              'progress-bar progress-bar-striped progress-bar-animated';
            this.progress.style.width = '100%';
            // コールバック実行
            this.callback(new Uint8Array(buffer));
          }

          /**
           * エラー時のハンドラ
           *
           * @param {Error | undefined} error エラー内容
           * @private
           */
          onError(error = undefined) {
            requestAnimationFrame(function() {
              this.alert.className = 'alert alert-danger';
              this.message.innerText =
                'An error occurred while loading SoundFont. See the console log for details. In addition, it may be cured by deleting the cache of the browser.';
              this.progressOuter.style.display = 'none';
            });
            if (error) {
              throw Error(error.message);
            }
          }

          /**
           * データ取得
           * @public
           */
          async fetch() {
            /** @type {Cache} */
            const cache = await window.caches.open(Loader.CACHE_NAME);
            /** @type {Response} */
            const cached = await cache.match(this.url);

            if (this.cache && cached) {
              // キャッシュが存在する場合、キャッシュの値を返す
              this.onComplete(await cached.arrayBuffer());
              return;
            }

            /** @type {void | Response} キャッシュがない場合Fetchで取得 */
            const response = await fetch(this.url, {
              method: 'GET',
            }).catch(e => this.onError(e));

            if (!response || (response && !response.ok)) {
              return;
            }

            /** @type {Response} キャッシュ用レスポンス */
            const cloned = response.clone();

            /** @type {number} ファイルの容量 */
            const contentLength = parseInt(response.headers.get('Content-Length'));

            /** @type {ReadableStreamDefaultReader<Uint8Array>} ファイルリーダー */
            const reader = cloned.body.getReader();

            /** @type {number} 読み込まれたチャンクの長さ */
            let receivedLength = 0;

            /** @type {Uint8Array[]} 受信したバイナリチャンクの配列(本文を構成します) */
            const chunks = [];

            // eslint-disable-next-line
            while (true) {
              // 最後のチャンクも場合、done は true。
              // value はチャンクバイトの Uint8Array
              const {
                done,
                value
              } = await reader.read();
              if (done) {
                break;
              }
              chunks.push(value);
              receivedLength += value.length;

              this.message.innerText = `Now Loading... (${receivedLength} of ${contentLength} byte)`;

              // Content lengthヘッダーが出力されている場合プログレスバーを表示
              this.onProgress(receivedLength, contentLength);
            }

            /** @type {Uint8Array} 全チャンク */
            const chunksAll = new Uint8Array(receivedLength);
            /** @type {number} 現在の読み込んだチャンク位置 */
            let position = 0;
            for (const chunk of chunks) {
              chunksAll.set(chunk, position);
              position += chunk.length;
            }

            // キャッシュへ保存
            await cache.put(this.url, response);
            // 完了時のイベントを実行
            this.onComplete(chunksAll);
          }
        }

        /**
         * WebMidiLink Class
         *
         * @author imaya
         */
        class WebMidiLink {
          /** @param {object} option */
          constructor(option = {}) {
            /** @type {number[]} */
            this.NrpnMsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.NrpnLsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.RpnMsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {number[]} */
            this.RpnLsb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            /** @type {boolean} */
            this.ready = false;
            /** @type {Synthesizer} */
            this.synth = undefined;
            /** @type {Function?} */
            this.loadCallback = () => {};
            /** @type {Function} */
            this.messageHandler = this.onmessage.bind(this);
            /** @type {boolean} */
            this.rpnMode = true;
            /** @type {object} */
            this.option = {};
            /** @type {boolean} Display synthsizer Web UI */
            this.option.drawSynth = option.drawSynth !== 'false';
            console.log(this.option);
            /** @type {boolean} Use Cache API */
            this.option.cache = option.cache || false;
            /** @type {string} CORS */
            this.option.targetOrigin = option.targetOrigin || '*';
            /** @type {'dark'|'light'|'auto'|undefined} Color mode */
            this.option.colorMode = option.colorMode || 'auto';
            /** @type {string} SoundFont URL */
            this.url =
              'https://cdn.jsdelivr.net/npm/@logue/sf2synth@latest/dist/Yamaha XG Sound Set.sf2';

            /** @type {HTMLDivElement} */
            // @ts-ignore
            this.placeholder = option.placeholder ?
              document.getElementById(option.placeholder) :
              window.document.body;
            this.setColorMode(this.option.colorMode);
            /** @type {Window} */
            this.window = null;

            if (window.opener) {
              this.window = window.opener;
            } else if (window.parent !== window) {
              this.window = window.parent;
            } else {
              this.window = window;
            }
          }

          /**
           * Setup Soundfont by URL.
           *
           * @param {string?} url SoundFont URL
           * @public
           */
          async setup(url) {
            if (url) {
              // URLが明示的に指定されていた場合
              this.url = url;
            }

            /** 読み込み */
            const loader = new Loader(
              this.url,
              this.placeholder,
              this.option.cache,
              buffer => this.setupByBuffer(buffer)
            );
            await loader.fetch();
          }

          /**
           * Get SoundFont URL.
           *
           * @return {string}
           */
          getUrl() {
            return this.url;
          }

          /**
           * Setup SoundFont by ArrayBuffer.
           *
           * @param {ArrayBuffer} buffer
           */
          setupByBuffer(buffer) {
            // DOMをクリア
            while (this.placeholder.firstChild) {
              this.placeholder.removeChild(this.placeholder.firstChild);
            }

            if (!this.synth) {
              // 読み込まれていないときシンセサイザをセットアップ
              // @ts-ignore
              this.synth = new Synthesizer(buffer);
              // 待受開始
              this.synth.start();
            } else {
              // 別のSoundFontが読み込まれたときリロード
              // @ts-ignore
              this.synth.refreshInstruments(buffer);
            }
            if (this.option.drawSynth) {
              console.log(this.option.drawSynth);
              // キーボードなどを描画
              this.placeholder.appendChild(this.synth.drawSynth());
            } else {
              /** @type {HTMLDivElement} キーボードを描画しないときはReadyだけを表示する。 */
              const readyElem = document.createElement('div');
              readyElem.className = 'alert alert-success';
              readyElem.role = 'alert';
              readyElem.innerText = 'Ready.';
              this.placeholder.appendChild(readyElem);
            }
            // シンセサイザを初期化
            this.synth.init();

            this.onReady();
          }

          /**
           * SoundFont Load Ready
           *
           * @protected
           */
          onReady() {
            // 一旦MIDI Link待受を解除
            // @ts-ignore
            window.removeEventListener('message', this.messageHandler);
            if (this.loadCallback) {
              // コールバック実行
              this.loadCallback();
            }
            // MIDI Link待ち受け開始
            // @ts-ignore
            window.addEventListener('message', this.messageHandler, false);
            // ホスト側に準備完了通知を送信
            this.window.postMessage('link,ready', this.option.targetOrigin);
          }

          /**
           * WebMidiLink信号をパース
           *
           * @param {Event} ev
           * @private
           */
          onmessage(ev) {
            /** @type {Array} */
            // @ts-ignore
            const msg = typeof ev.data.split === 'function' ? ev.data.split(',') : [];
            /** @type {string} */
            // @ts-ignore
            const type = msg !== [] ? msg.shift() : '';
            /** @type {string} */
            let command;

            switch (type) {
              case 'midi':
                this.processMidiMessage(msg.map(hex => parseInt(hex, 16)));
                break;
              case 'link':
                if (this.window === void 0) {
                  return;
                }
                command = msg.shift();
                switch (command) {
                  case 'reqpatch':
                    // TODO: dummy data
                    this.window.postMessage('link,patch', this.option.targetOrigin);
                    break;
                  case 'setpatch':
                  case 'ready':
                    this.window.postMessage('link,ready', this.option.targetOrigin);
                    // TODO: NOP
                    break;
                  case 'progress':
                    // ※この命令は、WebMidiLinkの仕様に含まれていません。
                    this.window.postMessage('link,progress', this.option.targetOrigin);
                    break;
                  default:
                    console.error('unknown link message:', command);
                    break;
                }
                break;
              default:
                console.error('unknown message type');
            }
          }

          /**
           * MIDI準備完了時のコールバック処理を登録する
           *
           * @param {Function} callback コールバック関数
           * @public
           */
          setLoadCallback(callback) {
            this.loadCallback = callback;
          }

          /**
           * MIDI信号を解析し、シンセサイザーを操作する
           *
           * @param {number[]} message
           * @protected
           */
          processMidiMessage(message) {
            /** @type {number} */
            const channel = message[0] & 0x0f;
            /** @type {Synthesizer} */
            const synth = this.synth;

            // http://amei.or.jp/midistandardcommittee/MIDI1.0.pdf
            switch (message[0] & 0xf0) {
              case 0x80: // NoteOff: 8n kk vv
                // @ts-ignore
                synth.noteOff(channel, message[1], message[2]);
                break;
              case 0x90: // NoteOn: 9n kk vv
                if (message[2] > 0) {
                  synth.noteOn(channel, message[1], message[2]);
                } else {
                  // @ts-ignore
                  synth.noteOff(channel, message[1], 0);
                }
                break;
              case 0xb0: {
                // Control Change: Bn cc dd
                /** @type {number} */
                const value = message[2];
                switch (message[1]) {
                  case 0x00: // Bank Select MSB: Bn 00 dd
                    synth.bankSelectMsb(channel, value);
                    break;
                  case 0x01: // Modulation Depth
                    synth.modulationDepth(channel, value);
                    break;
                  case 0x05: // Portament Time
                    break;
                  case 0x06: // Data Entry(MSB): Bn 06 dd
                    if (this.rpnMode) {
                      // RPN
                      switch (this.RpnMsb[channel]) {
                        case 0:
                          switch (this.RpnLsb[channel]) {
                            case 0: // Pitch Bend Sensitivity
                              synth.pitchBendSensitivity(channel, value);
                              break;
                          }
                          break;
                      }
                    } else {
                      // NRPN
                      switch (this.NrpnMsb[channel]) {
                        case 26: // Drum Instrument Level
                          synth.drumInstrumentLevel(this.NrpnLsb[channel], value);
                          break;
                      }
                    }
                    break;
                  case 0x26: // Data Entry(LSB): Bn 26 dd
                    if (this.rpnMode) {
                      // RPN
                      switch (this.RpnMsb[channel]) {
                        case 0:
                          switch (this.RpnLsb[channel]) {
                            case 0: // Pitch Bend Sensitivity
                              synth.pitchBendSensitivity(
                                channel,
                                synth.getPitchBendSensitivity(channel) + value / 100
                              );
                              break;
                          }
                          break;
                      }
                    }

                    // NRPN で LSB が必要なものは今のところない
                    break;

                  case 0x07: // Volume Change: Bn 07 dd
                    synth.volumeChange(channel, value);
                    break;
                  case 0x0a: // Panpot Change: Bn 0A dd
                    synth.panpotChange(channel, value);
                    break;
                  case 0x78: // All Sound Off: Bn 78 00]
                    synth.allSoundOff(channel);
                    break;
                  case 0x79: // Reset All Control: Bn 79 00
                    synth.resetAllControl(channel);
                    break;
                  case 0x20: // BankSelect LSB: Bn 00 dd
                    synth.bankSelectLsb(channel, value);
                    break;
                  case 0x47: // Harmonic Content
                    synth.harmonicContent(channel, value);
                    break;
                  case 0x60: //
                    // console.log(60);
                    break;
                  case 0x61: //
                    // console.log(61);
                    break;
                  case 0x62: // NRPN LSB
                    this.rpnMode = false;
                    this.NrpnLsb[channel] = value;
                    break;
                  case 0x63: // NRPN MSB
                    this.rpnMode = false;
                    this.NrpnMsb[channel] = value;
                    break;
                  case 0x64: // RPN LSB
                    this.rpnMode = true;
                    this.RpnLsb[channel] = value;
                    break;
                  case 0x65: // RPN MSB
                    this.rpnMode = true;
                    this.RpnMsb[channel] = value;
                    break;
                  case 0x40: // Hold
                    synth.hold(channel, value);
                    break;
                  case 0x0b: // Expression
                    synth.expression(channel, value);
                    break;
                  case 0x48: // DecayTyme
                    synth.decayTime(channel, value);
                    break;
                  case 0x49: // ReleaseTime
                    synth.releaseTime(channel, value);
                    break;
                  case 0x4a: // Attack time
                    synth.attackTime(channel, value);
                    break;
                  case 0x4b: // Brightness
                    synth.cutOffFrequency(channel, value);
                    break;
                  case 0x5b: // Effect1 Depth（Reverb Send Level）
                    synth.reverbDepth(channel, value);
                    break;
                }
                break;
              }
              case 0xc0: // Program Change: Cn pp
                synth.programChange(channel, message[1]);
                break;
              case 0xe0: // Pitch Bend
                synth.pitchBend(channel, message[1], message[2]);
                break;
              case 0xf0: {
                // delete checksum
                message.splice(1, 1);

                // System Exclusive Message
                // [1] F0
                // [2] <Manufacturer SysEx ID Numbers ID> https://www.amei.or.jp/report/report6.html
                // [3] <Device ID>
                // [4] <Model ID>
                // [5] <Sub ID>
                // [6] <size of parameter key>
                // [7] <size of parameter value>
                // [8] <MSB>
                // [9] <LSB>
                // [10] <data>
                // [11] <checksum> [IGNORE]
                // [12] F7 EOX [IGNORE]
                // console.log(this.dumpMessage(message));

                /**
                 * @type {number} System Exclusive Manufacture's ID Number
                 * @see {@link https://electronicmusic.fandom.com/wiki/List_of_MIDI_Manufacturer_IDs}
                 */
                const manufacturerId = message[1];
                /** @type {number} Device ID (GM extended=0x10 / ポケミク=0x79 / Any=0x7F) */
                const device = message[2];
                /** @type {number} Model ID: (GM=0x09 / GS=0x42 / XG=0x4C) */
                const model = message[3];

                if (manufacturerId === 0x7e || device === 0x09) {
                  // Gneral MIDI
                  // http://amei.or.jp/midistandardcommittee/Recommended_Practice/GM2_japanese.pdf
                  // console.log('GM:', this.dumpMessage(message));
                  // Non Realtime
                  switch (model) {
                    case 0x01:
                      // GM System On
                      synth.init('GM');
                      console.info('\x1b[34mGM System On\x1b[0m');
                      break;
                    case 0x02:
                      // GM System Off
                      console.info('\x1b[34mGM System Off\x1b[0m');
                      // Throuh
                      break;
                    case 0x03:
                      // GM2 System On
                      console.info('\x1b[34mGM (v2) System On\x1b[0m');
                      synth.init('GM2');
                      break;
                    default:
                      // @ts-ignore
                      console.log('\x1b[34mGM\x1b[0m: ' + this.dumpMessage(message));
                  }
                } else if (manufacturerId === 0x7f) {
                  // Realtime
                  if (model === 0x01) {
                    // master volume: F0 7F 7F 04 01 [value] [value] F7
                    synth.setMasterVolume(message[4] + (message[5] << 7));
                  } else {
                    // @ts-ignore
                    console.log(
                      '\x1b[34mRealtime\x1b[0m: ' + this.dumpMessage(message)
                    );
                  }
                } else if (manufacturerId === 0x7d) {
                  // smfplayer / sf2synth固有命令は、プライベート／非営利用途用のManufacturer IDである0x7Dを使用する。
                  // プログラム上意味はないが、GM互換であるため、deviceID:0x10、ModelID:0x00とする。
                  // よって、F0 7D 10 00 [...] 7Fで定義

                  if (message[4] === 0x01) {
                    // カラーモード切替
                    // F0 7D 10 00 01 [value]
                    if (message[5] === 0x01) {
                      // 明示的にライトモード
                      this.setColorMode('light');
                    } else if (message[5] === 0x02) {
                      // 明示的にダークモード
                      this.setColorMode('dark');
                    } else {
                      // OSの設定に合わせる
                      this.setColorMode('auto');
                    }
                  }
                }

                if (model === 0x42) {
                  // Roland GS
                  // http://lib.roland.co.jp/support/jp/manuals/res/1809974/SC-88VL_j.pdf
                  // deviceは10、modelIDは42固定。
                  // F0 41 10 42 12 [addr] [part] [key] [value] [checksum] F7
                  // (DeviceID = 10, ModelID = 42, CommandID = 12)

                  // QuickTime音源や、WindowsMIDI音源は、GS互換音源なのでmanufacturerIdが41とは限らない

                  /* * @param {number} GsAddress GSアドレス（未使用）
                  const GsAddress = message[6];
                  */
                  /** @type {number} GSパート番号 */
                  const GsPart = message[6] - 0x0f;
                  /** @type {number} GSのキーパラメータ */
                  const GsKey = message[7];
                  /** @type {number} GSの値 */
                  const GsValue = message[8];
                  // TODO
                  switch (GsKey) {
                    case 0x00:
                      // TEXT INSERT FOR SC (ASCI code)
                      // http://kurizill.g1.xrea.com/memorandum/midi2.htm
                      // F0 41 10 45 12 10 [page] 00 [...value] [checksum] F7
                      // ex. F0 41 10 45 12 10 00 00 [48 65 6C 6C 6F] 21 F7 = Hello

                      // device IDの値は0x45固定だがその判定処理は省略

                      if (GsPart === 0x00) {
                        // ページが0x00の場合、LCDに表示するメッセージとする
                        // @ts-ignore
                        const msg = message.splice(8);
                        // Remove F7
                        msg.pop();
                        // Remove Checksum
                        msg.pop();
                        synth.processMidiMessage(msg);
                      } else {
                        // GS音源のLCDの16x16のビットマップ画像
                        // @ts-ignore
                        console.log(
                          '\x1b[31mGS Bitmap message\x1b[0m:' +
                          this.dumpMessage(message)
                        );
                      }
                      break;
                    case 0x04:
                      // GS Master Volume:
                      // F0 41 10 42 12 40 00 04 [value] [checksum] F7
                      // console.log('GS Volume:', this.dumpMessage(message));
                      synth.setMasterVolume(GsValue * 64);
                      break;

                    case 0x15: {
                      // GS Dram part: F0 41 10 42 12 40 1[part no] [Map] [checksum] F7
                      // Notice: [sum] is ignroe in this program.

                      if (GsPart === 0) {
                        // 10 Ch.
                        synth.setPercussionPart(9, GsValue !== 0x00);
                      } else if (GsPart >= 10) {
                        // 1~9 Ch.
                        synth.setPercussionPart(GsPart - 1, GsValue !== 0x00);
                      } else {
                        // 11~16 Ch.
                        synth.setPercussionPart(GsPart, GsValue !== 0x00);
                      }
                      break;
                    }
                    case 0x19:
                      // VOLUME ON/OFF (PART LEVEL)
                      // F0 41 10 42 12 40 1[part no] 19 [value] [checksum] F7
                      console.info(
                        '\x1b[31mGS Volume On/Off\x1b[0m: ' + GsPart,
                        GsValue
                      );
                      break;
                    case 0x30:
                      // Reverb Effect
                      console.info(
                        '\x1b[31mGS Reverb\x1b[0m: ' + this.dumpMessage(message)
                      );
                      break;
                    case 0x38:
                      // Chorus Effect
                      console.info(
                        '\x1b[31mGS Chorus\x1b[0m: ' + this.dumpMessage(message)
                      );
                      break;
                    case 0x45:
                      // Bitmap icon 16x16 ?
                      console.info(
                        '\x1b[31mGS Bitmap\x1b[0m: ' + this.dumpMessage(message)
                      );
                      break;
                    case 0x7f:
                      // GS Reset: F0 41 10 42 12 40 00 7F 00 [checksum] F7
                      synth.init('GS');
                      console.info('\x1b[31mGS Reset\x1b[0m');
                      break;
                    default:
                      // @ts-ignore
                      console.log('\x1b[31mGS\x1b[0m: ' + this.dumpMessage(message));
                  }
                } else if (model === 0x4c) {
                  // YAMAHA XG
                  // F0 43 10 4C [...] F7
                  // https://jp.yamaha.com/files/download/other_assets/9/321739/read_aoyama.pdf
                  // https://jp.yamaha.com/files/download/other_assets/1/316861/MU100J1.pdf

                  // カシオとKORGはXG互換音源を作っていたためmanufacturerIdが43とは限らない

                  /** @type {number} Xg音源のキー */
                  const XgKey = message[4];
                  /** @type {number} Xg音源のパート */
                  const XgPart = message[5];

                  switch (XgKey) {
                    case 0x00:
                      // XG Reset:
                      // F0 43 1n 4C 00 00 7E 00 F7
                      if (message[6] === 0x7e) {
                        synth.init('XG');
                        console.info('\x1b[32mXG Reset\x1b[0m');
                      }
                      break;
                    case 0x02:
                      // Effect
                      // https://jp.yamaha.com/files/download/other_assets/5/321745/efctparamlist.pdf
                      // F0 43 10 4C 02 01 [type] [value] F7
                      //
                      // type
                      // 02: Reverb
                      //   リバーブエフェクトのインパルス応答を選択する
                      // 40: Variation
                      //   F0 43 10 4C 02 01 40 [type] 00 F7
                      //   インサーションエフェクトとして使用するモードと全チャンネルにかけるシステムエフェクトモード場合がある。
                      //   アンプシミュレーターやディストーション、フェイザー、ディレイなど飛び道具的なエフェクトはここに入っていた。
                      // 41: バリエーションエフェクトの種類
                      //   [value]にエフェクトの種類
                      // 5B: バリエーションエフェクトをかけるパート
                      //   F0 43 10 4C 02 01 5B [part] F7
                      //   [value]が0でインサーションエフェクト、1でシステムエフェクトモードに切り替える。
                      //   インサーションエフェクトが実装される前（MU100よりも前の機種）は、ディレイ・エフェクトで使う場合が多かった。
                      console.log(
                        '\x1b[32mXG Effect\x1b[0m: ' + this.dumpMessage(message)
                      );
                      break;
                    case 0x03:
                      // Insertion Effect
                      // F0 43 10 4C 03 [type] [value] F7
                      // MU100以降の機種で実装されている。最大２系統。１チャンネルのみ指定可能。
                      console.log(
                        '\x1b[32mXG Insertion Effect\x1b[0m: ' +
                        this.dumpMessage(message)
                      );
                      break;
                    case 0x04:
                      // XG Master Volume:
                      // F0 43 1n 4C 00 00 04 [value] F7
                      synth.setMasterVolume(message[9] * 64);
                      break;
                    case 0x06: {
                      // Text:
                      // F0 43 1n 4C 06 00 00 [text] F7
                      // ex. F0 43 1n 4C 06 00 00 48 65 6C 6C 6F 21 F7 = Hello
                      // @ts-ignore
                      const msg = message.splice(8);
                      // Remove F7
                      msg.pop();
                      synth.processMidiMessage(msg);
                      break;
                    }
                    case 0x07:
                      // Bitmap Window
                      // F0 43 10 4C 07 00 00 [bitmap] F7
                      // 音源のアイコン描画領域に描画する16x16のビットマップ画像。
                      // 7bitごとに左上から描画する。仕様がややこしいので処理しない
                      console.log(
                        '\x1b[32mXG Bitmap\x1b[0m: ' + this.dumpMessage(message)
                      );
                      break;
                    case 0x08:
                      // XG Dram Part:
                      // F0 43 10 4C 08 [partNum] 07 [map] F7
                      // 厳密には[map]は1以上の値が入り、３＋１系統までしか使えない（MU2000の場合）が、本プログラムでは制限しない。
                      synth.setPercussionPart(XgPart, message[8] !== 0x00);
                      break;

                    default:
                      // @ts-ignore
                      console.log('\x1b[32mXG\x1b[0m: ', this.dumpMessage(message));
                  }
                }
                break;
              }
              default:
                // not supported
                synth.setPercussionPart(9, true);
                break;
            }
          }

          /**
           * Dump System Exclusive Message
           *
           * @private
           * @param {number[]} messages
           * @return {string}
           */
          dumpMessage(messages) {
            const ret = [];
            let i = 0;
            for (const msg of messages) {
              let str = '';
              switch (i) {
                case 0:
                  // 青
                  str = '\x1b[35m';
                  break;
                case 1:
                case 2:
                case 3:
                  // 黄色
                  str = '\x1b[33m';
                  break;
                default:
                  // 末尾の場合は青、それ以外はシアン
                  str = messages.length - 1 === i ? '\x1b[35m' : '\x1b[36m';
                  break;
              }

              ret.push(str + msg.toString(16).toUpperCase().padStart(2, '0'));
              i++;
            }
            return ret.join(' ') + '\x1b[0m';
          }

          /**
           * Change Color mode
           *
           * @param {'dark'|'light'|'auto'|undefined} mode Color Mode
           * @public
           */
          setColorMode(mode) {
            // Mode was given
            if (mode) {
              if (mode === 'auto') {
                mode = window.matchMedia('(prefers-color-scheme: dark)').matches ?
                  'dark' :
                  'light';
              }
              // Update data-* attr on html
              document.documentElement.setAttribute('data-bs-theme', mode);
            }
            // No mode given (e.g. reset)
            else {
              document.documentElement.setAttribute('data-bs-theme', 'auto');
              // Remove data-* attr from html
              document.documentElement.removeAttribute('data-bs-theme');
            }
          }
        }

        /**
         * Web MIDI API Reciever Class.
         *
         * @author Logue <logue@hotmail.co.jp>
         */
        class WebMidiApi extends WebMidiLink {
          /**
           * @inheritdoc
           */
          constructor(option = {}) {
            super(option);
            /** @type {WebMidi.MIDIAccess} */
            this.midi = undefined;
          }

          /**
           * @inheritdoc
           * @param {string} url
           */
          async setup(url) {
            this.midi = await window.navigator.requestMIDIAccess({
              sysex: true
            });
            await super.setup(url);
          }

          /**
           * @inheritdoc
           */
          onReady() {
            if (super.loadCallback) {
              // コールバック実行
              super.loadCallback();
            }
            // Web MIDI APIを待ち受け
            this.midi.inputs.forEach(
              (
                /** @type {{ onmidimessage: (msg: WebMidi.MIDIMessageEvent) => void; }} */
                input
              ) =>
              (input.onmidimessage = msg =>
                super.processMidiMessage(Array.from(msg.data)))
            );
          }
        }

        // This file is auto-generated by the build system.
        const meta = {
          version: '0.5.7',
          date: '2023-06-08T11:44:24.137Z',
        };

        const wml = '';

        const SoundFont = {
          version: meta.version,
          build: meta.date,
          WebMidiLink,
          WebMidiApi,
          Parser,
        };

        if (!window.SoundFont) {
          // @ts-ignore
          window.SoundFont = SoundFont;
        }

        return SoundFont;

      }));
      </script>
      <script>
        "use strict";

      // @TODO:
      // - Show errors on the page.
      // - Support more sample formats:
      //   - 24-bit signed little endian integer
      //     Soundfont 2.04 files need this.
      //   - 32-bit signed little endian integer
      //     May exist in wav files.
      // - Support more formats:
      //   - .mod
      //     Adapt <https://github.com/dbrookman/trackrip>?
      //   - .it
      //     Maybe adapt <https://github.com/iamgreaser/it2everything/blob/master/munch.py>?
      //   - .xm?
      //   - .s3m?
      //   - SF3/SF4?
      // - Better validation of loop points.
      // - Make `detectFileFormat` read the actual first bytes of the file as well.
      //   This will have to return a Promise which should resolve to the detected
      //   file format.
      // - Get pitch correction info from .sf2?
      // - Add a way to load from URLs too? Doubles as a CORS checker.
      // - Add a way to specify the interpolation used for resampling.
      // - Add a way to specify the output bit depth for .wav:
      //   - 4 (IMA ADPCM)
      //   - 8
      //   - 16
      //   - 32
      //   - 32 (floating point)
      //   - 64 (floating point)
      // - Export to more formats?
      //     - .mp3 (with lamejs)
      //     - .ogg
      // - What about pitch detection?
      // - Try to load large files lazily?
      //   Will require a "skeleton" `Sample`.
      // - Make the preview match the output that will be generated.
      // - Add an option to specify the sample rate used when loading via the Web Audio API.

      const FILE_FORMAT_UNKNOWN = 0;
      const FILE_FORMAT_SF2 = 1;
      const FILE_FORMAT_WAV = 2;
      const FILE_FORMAT_JS = 3;
      const FILE_FORMAT_PLAIN_TEXT = 4;
      const FILE_FORMAT_MP3 = 5;
      const FILE_FORMAT_OGG = 6;
      const FILE_FORMAT_FLAC = 7;

      const SAMPLE_FORMAT_UNKNOWN = 0;
      const SAMPLE_FORMAT_S16 = 1;
      const SAMPLE_FORMAT_F32 = 2;
      const SAMPLE_FORMAT_U8 = 3;
      const SAMPLE_FORMAT_F64 = 4;

      const EXTENSION_RE = /\.([a-zA-Z0-9_]+)$/;

      // @TODO: Ideally this would use a JavaScript parser, but looking around, most
      // JavaScript features aren't used, so we can get away with a much cruder
      // parsing strategy.
      const SAMPLE_SCRIPT_RE = new RegExp(combineRegExps([
        /^(let|var|const)/, // 1: Variable declaration type
        /\s+([a-zA-Z_][a-zA-Z0-9_]*)/, // 2: Variable name
        /\s*=\s*\[\s*/,
        // @TODO: Probably won't need to support exponential notation here, but,
        // who knows...
        /((?:(?:-?[0-9]+\.[0-9]+),?\s*)+)/, // 3: Sample data
        /\s*\];?$/
      ]), "gm");

      function combineRegExps(regexps) {
        return regexps.map(
          regexp => typeof regexp === "string" ? regexp : regexp.source
        ).join("");
      }

      function secondsToMilliseconds(seconds) {
        return seconds * 1000;
      }

      function isWithin(x, a, b) {
        return x >= a && x <= b;
      }

      function clamp(x, a, b) {
        return x > b ? b : x < a ? a : x;
      }

      function identity(x) {
        return x;
      }

      function f64ToS16(x) {
        x = clamp(x, -1, 1);
        return x < 0 ? ((x * 0x8000) | 0) : ((x * 0x7FFF) | 0);
      }

      function s16ToF64(x) {
        x = clamp(x, -32768, 32767);
        return x >= 0x8000 ? (x / 0x8000) : (x / 0x7FFF);
      }

      function f64ToS8(x) {
        x = clamp(x, -1, 1);
        return x < 0 ? ((x * 0x80) | 0) : ((x * 0x7F) | 0);
      }

      function s8ToF64(x) {
        x = clamp(x, -128, 127);
        return x >= 0x80 ? (x / 0x80) : (x / 0x7F);
      }

      function f64ToU8(x) {
        x = clamp(x, -1, 1);
        return x < 0 ? ((x * 0x7F + 0x7F) | 0) : ((x * 0x80 + 0x7F) | 0);
      }

      function u8ToF64(x) {
        x = clamp(x, 0, 255);
        return x / 127 - 1;
      }

      function s16ToS8(x) {
        return f64ToS8(s16ToF64(x));
      }

      function s8ToS16(x) {
        return f64ToS16(s8ToF64(x));
      }

      function s16ToU8(x) {
        return f64ToU8(s16ToF64(x));
      }

      function u8ToS16(x) {
        return f64ToS16(u8ToF64(x));
      }

      function getSampleFormatName(format) {
        switch (format) {
          case SAMPLE_FORMAT_S16:
            return "16-bit signed integer";
          case SAMPLE_FORMAT_F32:
            return "32-bit floating point";
          case SAMPLE_FORMAT_U8:
            return "8-bit unsigned integer";
          case SAMPLE_FORMAT_F64:
            return "64-bit floating point";
          default:
            return "Unknown";
        }
      }

      class Sample {
        constructor(name, format, sampleRate, data, loopStart, loopEnd) {
          this.name = name;
          this.format = format;
          this.sampleRate = sampleRate;
          this.data = data;
          this.loopStart = loopStart;
          this.loopEnd = loopEnd;
          if (
            !isWithin(this.loopStart, 0, this.data.length) ||
            !isWithin(this.loopEnd, 0, this.data.length) ||
            this.loopEnd <= this.loopStart ||
            (this.loopEnd - this.loopStart) < 2
          ) {
            this.loopStart = 0;
            this.loopEnd = this.data.length;
          }
          this._cachedAudioBuffer = null;
        }

        getConverter(outputFormat) {
          const possibleConversions = [
            // [input format, output format, function]
            [SAMPLE_FORMAT_S16, SAMPLE_FORMAT_S16, identity],
            [SAMPLE_FORMAT_S16, SAMPLE_FORMAT_F32, s16ToF64],
            [SAMPLE_FORMAT_S16, SAMPLE_FORMAT_U8, s16ToU8],
            [SAMPLE_FORMAT_S16, SAMPLE_FORMAT_F64, s16ToF64],

            [SAMPLE_FORMAT_F32, SAMPLE_FORMAT_S16, f64ToS16],
            [SAMPLE_FORMAT_F32, SAMPLE_FORMAT_F32, identity],
            [SAMPLE_FORMAT_F32, SAMPLE_FORMAT_U8, f64ToU8],
            [SAMPLE_FORMAT_F32, SAMPLE_FORMAT_F64, identity],

            [SAMPLE_FORMAT_U8, SAMPLE_FORMAT_S16, u8ToS16],
            [SAMPLE_FORMAT_U8, SAMPLE_FORMAT_F32, u8ToF64],
            [SAMPLE_FORMAT_U8, SAMPLE_FORMAT_U8, identity],
            [SAMPLE_FORMAT_U8, SAMPLE_FORMAT_F64, u8ToF64],

            [SAMPLE_FORMAT_F64, SAMPLE_FORMAT_S16, f64ToS16],
            [SAMPLE_FORMAT_F64, SAMPLE_FORMAT_F32, identity],
            [SAMPLE_FORMAT_F64, SAMPLE_FORMAT_U8, f64ToU8],
            [SAMPLE_FORMAT_F64, SAMPLE_FORMAT_F64, identity],
          ];

          const inputFormat = this.format;
          for (const tuple of possibleConversions) {
            if (tuple == null) continue;
            const [from, to, fn] = tuple;
            if (from === inputFormat && to === outputFormat) return fn;
          }

          const inputFormatName = getSampleFormatName(inputFormat);
          const outputFormatName = getSampleFormatName(outputFormat);
          throw new Error(`Can't convert from ${inputFormatName} to ${outputFormatName}`);
        }

        getBufferSource(audioContext) {
          const sampleRate = Math.max(8000, this.sampleRate);
          const loopStart = this.loopStart;
          const loopEnd = this.loopEnd;
          if (this._cachedAudioBuffer == null) {
            const data = this.data;
            const converted = new Float32Array(data.length);
            const converter = this.getConverter(SAMPLE_FORMAT_F32);
            for (let i = 0; i < data.length; i++) {
              converted[i] = converter(data[i]);
            }
            const buffer = audioContext.createBuffer(1, converted.length, sampleRate);
            const channelData = buffer.getChannelData(0);
            channelData.set(converted);
            this._cachedAudioBuffer = buffer;
          }
          const source = audioContext.createBufferSource();
          source.buffer = this._cachedAudioBuffer;
          const playbackRate = 1;
          source.playbackRate.value = playbackRate;
          source.loopStart = loopStart / sampleRate;
          source.loopEnd = loopEnd / sampleRate;
          source.loop = true;
          return source;
        }
      }

      class SampleGroup {
        constructor(name) {
          this.name = name;
          this.samples = [];
        }

        addSample(sample) {
          this.samples.push(sample);
        }
      }

      class Collection {
        constructor(name) {
          this.name = name;
          this.sampleGroups = [];
        }

        addSampleGroup(group) {
          this.sampleGroups.push(group);
        }
      }

      let loadedCollection = null;
      let selectedSampleGroup = null;
      let selectedSample = null;
      let hasMultipleSamplesSelected = false;
      let shouldResample = false;
      let shouldExportSamplesWithInstrumentName = true;
      let zipNameCounter = 0;

      let playingSample = null;
      let stopPlayingSample = null;

      let playingSource = null;
      let audioContext = null;
      let sampleLoadingAudioContext = null;
      let sampleLoadingSampleRate = 44100;

      const filePicker = document.body.querySelector("#file-picker");
      const overlay = document.body.querySelector(".overlay");
      const overlayCloseButton = document.body.querySelector(".overlay .close-button");
      const supportedFormatsLink = document.body.querySelector(".supported-formats-link");
      const sampleListArea = document.body.querySelector(".sample-list-area");
      const sampleListCollectionFilenameDisplay = document.body.querySelector(".sample-list-collection-filename");
      const sampleList = document.body.querySelector(".sample-list");
      const sampleInfoContainer = document.body.querySelector(".sample-info-container");
      const exportArea = document.body.querySelector(".export-area");
      const resampleBox = document.body.querySelector(".resample-box");
      const instrumentNameBox = document.body.querySelector(".instrument-name-box");
      const outputSampleRateRow = document.body.querySelector(".output-sample-rate-row");
      const outputSampleRateStepper = document.body.querySelector(".output-sample-rate");
      const outputSampleInfoContainer = document.body.querySelector(".output-sample-info-container");
      const playNoteButton = document.body.querySelector(".play-note");
      const exportAsWavButton = document.body.querySelector(".export-as-wav");
      const exportAsZipButton = document.body.querySelector(".export-as-zip");
      let generatedWavLink = null;
      let generatedZipLink = null;

      function playSample(outputSampleRate, group, sample) {
        playingSample = sample;
        let source = sample.getBufferSource(audioContext);
        playingSource = source;
        let gain = audioContext.createGain();
        gain.connect(audioContext.destination);
        source.connect(gain);
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
        source.start(audioContext.currentTime);
        stopPlayingSample = () => {
          playingSource = null;
          const end = audioContext.currentTime + 0.1;
          gain.gain.setTargetAtTime(0, end, 0.01);
          source.stop(end + 1);
        };
        refreshPlayNoteButton();
      }

      function stopSample() {
        if (playingSample != null) {
          stopPlayingSample();
          playingSample = null;
          stopPlayingSample = null;
        }
        refreshPlayNoteButton();
      }

      function refreshPlayNoteButton() {
        if (playingSample != null) {
          playNoteButton.innerText = "Stop";
        } else {
          playNoteButton.innerText = "Play";
        }
      }

      function prepareNameForOutput(name) {
        // @TODO: Need to check what browsers generally do here.
        return name.replace(/\//g, "_");
      }

      function createWavFile(shouldResample, outputSampleRate, sample) {
        const sampleData = sample.data;
        const sampleRate = sample.sampleRate;
        const sampleFormat = sample.format;
        let loopStart = sample.loopStart;
        let loopEnd = sample.loopEnd;
        const shouldExportLoopRegion = loopStart !== 0 || loopEnd !== sampleData.length;
        let bitDepth = null;
        switch (sampleFormat) {
          case SAMPLE_FORMAT_S16:
            bitDepth = "16";
            break;
          case SAMPLE_FORMAT_F32:
            bitDepth = "32f";
            break;
          case SAMPLE_FORMAT_U8:
            bitDepth = "8";
            break;
          case SAMPLE_FORMAT_F64:
            bitDepth = "64";
            break;
          default:
            throw new Error("Unknown sample format");
        }
        const outputBitDepth = bitDepth;
        const channelAmount = 1;

        const wav = new wavefile.WaveFile();
        wav.fromScratch(channelAmount, sampleRate, bitDepth, Array.from(sampleData));
        if (shouldResample) {
          wav.toSampleRate(outputSampleRate);
          loopStart = Math.floor((loopStart / sampleRate) * outputSampleRate);
          loopEnd = Math.floor((loopEnd / sampleRate) * outputSampleRate);
        }
        if (outputBitDepth !== bitDepth) wav.toBitDepth(outputBitDepth);
        if (shouldExportLoopRegion) {
          wav.smpl.chunkId = "smpl";
          wav.smpl.loops.push({
            dwName: 0,
            dwType: 0,
            dwStart: loopStart,
            dwEnd: loopEnd,
            dwFraction: 0,
            dwPlayCount: 0,
          });
          wav.smpl.dwNumSampleLoops = wav.smpl.loops.length;
        }
        return wav.toBuffer().buffer;
      }

      function exportAsWav(shouldResample, outputSampleRate, sample, group, useInstrumentName) {
        const prefix = useInstrumentName && group.name != null ? prepareNameForOutput(group.name) + " - " : "";
        const name = `${prefix}${prepareNameForOutput(sample.name)}.wav`;
        const wavData = createWavFile(shouldResample, outputSampleRate, sample);
        generatedWavLink.download = name;
        const url = URL.createObjectURL(new Blob([wavData], {
          type: "audio/wav"
        }));
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, secondsToMilliseconds(60));
        generatedWavLink.href = url;
        setTimeout(function() {
          generatedWavLink.dispatchEvent(new MouseEvent("click"));
        }, 0);
      }

      function exportAsZip(shouldResample, outputSampleRate, samples, useInstrumentName) {
        const dirStructure = Object.create(null);

        for (const [group, sample] of samples) {
          const prefix = useInstrumentName && group.name != null ? prepareNameForOutput(group.name) + " - " : "";
          let name = `${prefix}${prepareNameForOutput(sample.name)}.wav`;

          if (dirStructure[name] != null) {
            let uniqueId = 1;
            let attempts = 0;
            do {
              const newName = `${prefix}${prepareNameForOutput(sample.name)}__${uniqueId}.wav`;
              uniqueId++;
              if (dirStructure[newName] == null) {
                name = newName;
                break;
              }
              attempts++;
            } while (attempts < 10000);
          }

          const wavData = createWavFile(shouldResample, outputSampleRate, sample);

          dirStructure[name] = new Uint8Array(wavData);
        }

        const collectionName = loadedCollection.name == null ? "" : loadedCollection.name;
        const collectionNameWithoutExtension = collectionName.replace(EXTENSION_RE, "");
        const zipName = collectionName === "" ? `extracted${zipNameCounter}.zip` : `${collectionNameWithoutExtension}_extracted${zipNameCounter}.zip`;
        zipNameCounter++;
        const zipData = fflate.zipSync(dirStructure, {
          level: 0, // No compression.
        });

        generatedZipLink.download = zipName;
        const url = URL.createObjectURL(new Blob([zipData], {
          type: "application/zip"
        }));
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, secondsToMilliseconds(60));
        generatedZipLink.href = url;
        setTimeout(function() {
          generatedZipLink.dispatchEvent(new MouseEvent("click"));
        }, 0);
      }

      const supportedFormatsLinkEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click": {
              event.preventDefault();
              const currentStyle = window.getComputedStyle(overlay);
              if (currentStyle.display === "none") {
                overlay.style.display = "";
              } else {
                overlay.style.display = "none";
              }
              break;
            }
          }
        },
      };

      const overlayEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click": {
              overlay.style.display = "none";
              break;
            }
          }
        },
      };

      const overlayCloseButtonEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click": {
              overlay.style.display = "none";
              break;
            }
          }
        },
      };

      function getCurrentSampleListSelection() {
        let result = null;
        if (sampleList.selectedOptions.length > 0) {
          result = [];
          for (const selectedOption of sampleList.selectedOptions) {
            const sampleGroupElement = selectedOption.parentNode;
            let groupIndex = 0;
            if (sampleGroupElement !== sampleList) {
              groupIndex = +sampleGroupElement.dataset.index;
            }
            const sampleIndex = +selectedOption.value;
            const group = loadedCollection.sampleGroups[groupIndex];
            const sample = group.samples[sampleIndex];
            result.push([group, sample]);
          }
        }
        return result;
      }

      const sampleListEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "keydown": {
              if (event.ctrlKey && event.key === "a") {
                // If Ctrl+A is pressed, select every sample.
                event.preventDefault();
                for (const option of sampleList.options) {
                  option.selected = true;
                }
                sampleList.dispatchEvent(new Event("change"));
              }
              break;
            };
          case "change": {
            const selection = getCurrentSampleListSelection();
            if (selection != null) {
              stopSample();
              if (selection.length === 1) {
                playNoteButton.style.display = "";
                exportAsWavButton.style.display = "";
                exportAsZipButton.style.display = "none";

                const [group, sample] = selection[0];
                selectedSampleGroup = group;
                selectedSample = sample;
                hasMultipleSamplesSelected = false;
                refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
              } else {
                playNoteButton.style.display = "none";
                exportAsWavButton.style.display = "none";
                exportAsZipButton.style.display = "";

                selectedSampleGroup = null;
                selectedSample = null;
                hasMultipleSamplesSelected = true;
                refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
              }
            }
            break;
          }
          }
        },
      };

      const resampleBoxEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "input": {
              shouldResample = resampleBox.checked;
              refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
              break;
            }
          }
        },
      };

      const outputSampleRateStepperEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "input": {
              refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
              break;
            }
          }
        },
      };

      const instrumentNameBoxHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "input": {
              shouldExportSamplesWithInstrumentName = instrumentNameBox.checked;
              break;
            }
          }
        },
      };

      const playNoteEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click": {
              if (playingSample != null) {
                stopSample();
              } else {
                stopSample();
                const selection = getCurrentSampleListSelection();
                if (selection != null && selection.length === 1) {
                  const [group, sample] = selection[0];
                  const outputSampleRate = +outputSampleRateStepper.value;
                  playSample(outputSampleRate, group, sample);
                }
              }
              break;
            }
          }
        },
      };

      const exportAsWavEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click": {
              stopSample();
              const selection = getCurrentSampleListSelection();
              if (selection != null && selection.length === 1) {
                const [group, sample] = selection[0];
                const outputSampleRate = +outputSampleRateStepper.value;
                exportAsWav(shouldResample, outputSampleRate, sample, group, shouldExportSamplesWithInstrumentName);
              }
              break;
            }
          }
        },
      };

      const exportAsZipEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "click":
              stopSample();
              const selection = getCurrentSampleListSelection();
              if (selection != null) {
                const samples = selection.map(([group, sample]) => [group, sample]);
                const outputSampleRate = +outputSampleRateStepper.value;
                exportAsZip(shouldResample, outputSampleRate, samples, shouldExportSamplesWithInstrumentName);
              }
              break;
          }
        },
      };

      function cleanName(name) {
        // console.log(JSON.stringify([name, [...name].map(x => x.charCodeAt(0))]));
        return name.replace(/\0[\s\S]*$/gm, "").trim();
      }

      function loadSf2(file) {
        file.arrayBuffer().then((arrayBuffer) => {
          stopSample();
          loadedCollection = new Collection(file.name);
          zipNameCounter = 0;
          selectedSampleGroup = null;
          selectedSample = null;
          hasMultipleSamplesSelected = false;
          const parser = new SoundFont.Parser(new Uint8Array(arrayBuffer), {
            // Should make the parser not modify the samples.
            // See `SoundFont.Parser.adjustSampleData`.
            sampleRate: 0,
          });
          const getModGenAmount = (generator, enumeratorType) => {
            return (
              generator[enumeratorType] ?
              generator[enumeratorType].amount :
              parser.getGeneratorTable()[enumeratorType]
            );
          };
          parser.parse();
          const presets = parser.createPreset();
          const instruments = parser.createInstrument();
          const samplesSeen = new Map();
          for (let presetIndex = 0; presetIndex < presets.length; presetIndex++) {
            const preset = presets[presetIndex];
            const presetName = cleanName(preset.name);
            // There's an EOP sentinel as well. Shouldn't really matter.
            if (typeof preset.instrument !== "number") {
              continue;
            }
            const instrument = instruments[preset.instrument];
            const instrumentName = cleanName(instrument.name);
            if (instrumentName === "EOI") {
              break;
            }
            const sampleGroup = new SampleGroup(presetName);
            const samples = [];
            instrument.info.forEach(info => {
              const generator = info.generator;
              if (!generator.sampleID) return;
              const sampleId = getModGenAmount(generator, "sampleID");
              if (samplesSeen.has(sampleId)) {
                return;
              }
              samplesSeen.set(sampleId, true);
              const sampleHeader = parser.sampleHeader[sampleId];
              const name = cleanName(sampleHeader.sampleName);
              const sampleRate = sampleHeader.sampleRate;
              const data = parser.sample[sampleId];
              const sampleFormat = SAMPLE_FORMAT_S16;
              const loopStart = (
                sampleHeader.startLoop
                // @TODO: Is this necessary?
                // + getModGenAmount(generator, "startloopAddrsCoarseOffset") * 32768
                // + getModGenAmount(generator, "startloopAddrsOffset")
              );
              const loopEnd = (
                sampleHeader.endLoop
                // @TODO: Is this necessary?
                // + getModGenAmount(generator, "endloopAddrsCoarseOffset") * 32768
                // + getModGenAmount(generator, "endloopAddrsOffset")
              );
              samples.push(new Sample(name, sampleFormat, sampleRate, data, loopStart, loopEnd));
            });
            for (let sampleIndex = 0; sampleIndex < samples.length; sampleIndex++) {
              const sample = samples[sampleIndex];
              sampleGroup.addSample(sample);
            }
            if (sampleGroup.samples.length > 0) {
              loadedCollection.addSampleGroup(sampleGroup);
            }
          }
          refreshSampleList(loadedCollection);
          refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
        });
      }

      function createSampleFromWav(name, arrayBuffer) {
        const wav = new wavefile.WaveFile();
        wav.fromBuffer(new Uint8Array(arrayBuffer));
        const sampleRate = wav.fmt.sampleRate;
        let TypedArray = null;
        let sampleFormat = null;
        switch (wav.bitDepth) {
          case "4": {
            sampleFormat = SAMPLE_FORMAT_S16;
            wav.fromIMAADPCM("16");
            TypedArray = Int16Array;
            break;
          }
          case "8": {
            sampleFormat = SAMPLE_FORMAT_U8;
            TypedArray = Uint8Array;
            break;
          }
          case "8m": {
            sampleFormat = SAMPLE_FORMAT_S16;
            wav.fromMuLaw("16");
            TypedArray = Int16Array;
            break;
          }
          case "8a": {
            sampleFormat = SAMPLE_FORMAT_S16;
            wav.fromALaw("16");
            TypedArray = Int16Array;
            break;
          }
          case "16": {
            sampleFormat = SAMPLE_FORMAT_S16;
            TypedArray = Int16Array;
            break;
          }
          case "32f": {
            sampleFormat = SAMPLE_FORMAT_F32;
            TypedArray = Float32Array;
            break;
          }
          case "64": {
            sampleFormat = SAMPLE_FORMAT_F64;
            TypedArray = Float64Array;
            break;
          }
          default: {
            throw new Error(`Unsupported bit depth: ${wav.bitDepth}`);
          }
        }
        let data = wav.getSamples(false, TypedArray);
        if (wav.fmt.numChannels === 1) {
          // Nothing to do here.
        } else if (wav.fmt.numChannels === 2) {
          const l = data[0];
          const r = data[1];
          const length = l.length;
          data = new TypedArray(length);
          for (let i = 0; i < length; i++) data[i] = (l[i] + r[i]) * 0.5;
        } else {
          // wav.fmt.numChannels > 2
          // @TODO: What about quad/5.1/etc.?
          data = data[0];
        }
        let loopStart = 0;
        let loopEnd = data.length;
        for (const loopDescriptor of wav.smpl.loops) {
          loopStart = loopDescriptor.dwStart;
          loopEnd = loopDescriptor.dwEnd;
          // We only support the first loop descriptor.
          break;
        }
        return new Sample(name, sampleFormat, sampleRate, data, loopStart, loopEnd);
      }

      function loadWavs(files) {
        loadedCollection = new Collection("wav files");
        zipNameCounter = 0;
        const sampleGroup = new SampleGroup("wav files");
        loadedCollection.addSampleGroup(sampleGroup);
        for (const file of files) {
          file.arrayBuffer().then((arrayBuffer) => {
            stopSample();
            const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
            selectedSampleGroup = null;
            selectedSample = null;
            hasMultipleSamplesSelected = false;
            const name = nameWithoutExtension;
            const sample = createSampleFromWav(name, arrayBuffer);
            sampleGroup.addSample(sample);
            refreshSampleList(loadedCollection);
            refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
          });
        }
      }

      function loadWav(file) {
        file.arrayBuffer().then((arrayBuffer) => {
          stopSample();
          const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
          loadedCollection = new Collection(file.name);
          zipNameCounter = 0;
          selectedSampleGroup = null;
          selectedSample = null;
          hasMultipleSamplesSelected = false;
          const sampleGroup = new SampleGroup(null);
          const name = nameWithoutExtension;
          const sample = createSampleFromWav(name, arrayBuffer);
          sampleGroup.addSample(sample);
          loadedCollection.addSampleGroup(sampleGroup);
          refreshSampleList(loadedCollection);
          refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
        });
      }

      function loadSampleScript(file) {
        file.text().then((contents) => {
          stopSample();
          loadedCollection = new Collection(file.name);
          zipNameCounter = 0;
          selectedSampleGroup = null;
          selectedSample = null;
          hasMultipleSamplesSelected = false;
          const sampleGroup = new SampleGroup(file.name);
          // This is the format used in:
          // - UltraBox (https://ultraabox.github.io)
          // - Pandora's Box (https://paandorasbox.github.io)
          let match = null;
          do {
            match = SAMPLE_SCRIPT_RE.exec(contents);
            if (match != null) {
              const name = match[2];
              const sampleRate = 44100;
              const sampleFormat = SAMPLE_FORMAT_F64;
              const rawSampleData = match[3].split(/,\s*/);
              const sampleDataSize = rawSampleData.length;
              const data = new Float64Array(sampleDataSize);
              for (let i = 0; i < sampleDataSize; i++) {
                const value = rawSampleData[i];
                // @TODO: What should be done about array holes? Convert to 0?
                data[i] = Number(value);
              }
              const loopStart = 0;
              const loopEnd = data.length;
              const sample = new Sample(name, sampleFormat, sampleRate, data, loopStart, loopEnd);
              sampleGroup.addSample(sample);
            }
          } while (match != null);
          if (sampleGroup.samples.length > 0) {
            loadedCollection.addSampleGroup(sampleGroup);
          }
          refreshSampleList(loadedCollection);
          refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
        });
      }

      function createSampleFromTextFile(name, contents) {
        const sampleRate = 8000;
        const sampleFormat = SAMPLE_FORMAT_F64;
        // This is the format used in:
        // - Pandora's Archive (https://pandoras-box-archive.neptendo.repl.co)
        // @TODO: This assumes no other whitespace exists.
        const rawValues = contents.trim().split("\n");
        const dataSize = rawValues.length;
        const data = new Float64Array(dataSize);
        for (let i = 0; i < dataSize; i++) {
          data[i] = Number(rawValues[i]);
        }
        let loopStart = 0;
        let loopEnd = data.length;
        const sample = new Sample(name, sampleFormat, sampleRate, data, loopStart, loopEnd);
        return sample;
      }

      function loadSampleTextFiles(files) {
        loadedCollection = new Collection("text files");
        zipNameCounter = 0;
        const sampleGroup = new SampleGroup("text files");
        loadedCollection.addSampleGroup(sampleGroup);
        for (const file of files) {
          file.text().then((contents) => {
            stopSample();
            const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
            selectedSampleGroup = null;
            selectedSample = null;
            hasMultipleSamplesSelected = false;
            const name = nameWithoutExtension;
            const sample = createSampleFromTextFile(name, contents);
            sampleGroup.addSample(sample);
            refreshSampleList(loadedCollection);
            refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
          });
        }
      }

      function loadSampleTextFile(file) {
        file.text().then((contents) => {
          stopSample();
          const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
          loadedCollection = new Collection(file.name);
          zipNameCounter = 0;
          selectedSampleGroup = null;
          selectedSample = null;
          hasMultipleSamplesSelected = false;
          const sampleGroup = new SampleGroup(null);
          const name = nameWithoutExtension;
          const sample = createSampleFromTextFile(name, contents);
          sampleGroup.addSample(sample);
          loadedCollection.addSampleGroup(sampleGroup);
          refreshSampleList(loadedCollection);
          refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
        });
      }

      function createSampleFromDecodedAudioData(name, audioBuffer) {
        const sampleRate = 44100;
        const sampleFormat = SAMPLE_FORMAT_F32;
        const length = audioBuffer.length;
        let data = null;
        // @TODO: Ideally this probably should use ChannelMergerNode.
        // https://www.w3.org/TR/webaudio/#down-mix
        switch (audioBuffer.numberOfChannels) {
          case 1: {
            // Mono
            data = audioBuffer.getChannelData(0);
          }
          break;
        case 2: {
          // Stereo
          data = new Float32Array(length);
          const l = audioBuffer.getChannelData(0);
          const r = audioBuffer.getChannelData(1);
          for (let i = 0; i < length; i++) data[i] = (l[i] + r[i]) * 0.5;
        }
        break;
        case 4: {
          // Quad
          data = new Float32Array(length);
          const l = audioBuffer.getChannelData(0);
          const r = audioBuffer.getChannelData(1);
          const sl = audioBuffer.getChannelData(2);
          const sr = audioBuffer.getChannelData(3);
          for (let i = 0; i < length; i++)
            data[i] = (l[i] + r[i] + sl[i] + sr[i]) * 0.25;
        }
        break;
        case 6: {
          // 5.1
          data = new Float32Array(length);
          const l = audioBuffer.getChannelData(0);
          const r = audioBuffer.getChannelData(1);
          const c = audioBuffer.getChannelData(2);
          const sl = audioBuffer.getChannelData(4);
          const sr = audioBuffer.getChannelData(5);
          for (let i = 0; i < length; i++) data[i] = (
            Math.SQRT1_2 * (l[i] + r[i]) + c[i] + 0.5 * (sl[i] + sr[i])
          );
        }
        break;
        }
        const loopStart = 0;
        const loopEnd = data.length;
        return new Sample(name, sampleFormat, sampleRate, data, loopStart, loopEnd);
      }

      function loadFilesViaWebAudioOrWavefile(files) {
        loadedCollection = new Collection("audio files");
        zipNameCounter = 0;
        const sampleGroup = new SampleGroup("audio files");
        loadedCollection.addSampleGroup(sampleGroup);
        for (const file of files) {
          // @TODO: The files should come with the format instead.
          const detectedFileFormat = detectFileFormat(file);
          if (detectedFileFormat === FILE_FORMAT_WAV) {
            file.arrayBuffer().then((arrayBuffer) => {
              stopSample();
              const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
              selectedSampleGroup = null;
              selectedSample = null;
              hasMultipleSamplesSelected = false;
              const name = nameWithoutExtension;
              const sample = createSampleFromWav(name, arrayBuffer);
              sampleGroup.addSample(sample);
              refreshSampleList(loadedCollection);
              refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
            });
          } else {
            file
              .arrayBuffer()
              .then((arrayBuffer) => {
                return sampleLoadingAudioContext.decodeAudioData(arrayBuffer);
              })
              .then((audioBuffer) => {
                stopSample();
                const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
                selectedSampleGroup = null;
                selectedSample = null;
                hasMultipleSamplesSelected = false;
                const name = nameWithoutExtension;
                const sample = createSampleFromDecodedAudioData(name, audioBuffer);
                sampleGroup.addSample(sample);
                refreshSampleList(loadedCollection);
                refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
              });
          }
        }
      }

      function loadFileViaWebAudio(file) {
        file
          .arrayBuffer()
          .then((arrayBuffer) => {
            return sampleLoadingAudioContext.decodeAudioData(arrayBuffer);
          })
          .then((audioBuffer) => {
            stopSample();
            const nameWithoutExtension = file.name.replace(EXTENSION_RE, "");
            loadedCollection = new Collection(file.name);
            zipNameCounter = 0;
            selectedSampleGroup = null;
            selectedSample = null;
            hasMultipleSamplesSelected = false;
            const sampleGroup = new SampleGroup(null);
            const name = nameWithoutExtension;
            const sample = createSampleFromDecodedAudioData(name, audioBuffer);
            sampleGroup.addSample(sample);
            loadedCollection.addSampleGroup(sampleGroup);
            refreshSampleList(loadedCollection);
            refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
          });
      }

      function detectFileFormat(file) {
        const mimetype = file.type;

        const name = file.name;
        const extensionMatch = name.match(EXTENSION_RE);
        const extension = extensionMatch != null ? extensionMatch[1].toLowerCase() : "";
        const nameWithoutExtension = name.replace(EXTENSION_RE, "");

        if (extension === "sf2") return FILE_FORMAT_SF2;
        if (mimetype === "audio/x-wav" || extension === "wav") return FILE_FORMAT_WAV;
        if (mimetype === "application/javascript" || extension === "js") return FILE_FORMAT_JS;
        if (mimetype === "plain/text" || extension === "txt") return FILE_FORMAT_PLAIN_TEXT;
        if (mimetype === "audio/mpeg" || extension === "mp3") return FILE_FORMAT_MP3;
        if (
          mimetype === "audio/ogg" ||
          extension === "ogg" ||
          extension === "opus"
        ) return FILE_FORMAT_OGG;
        if (mimetype === "audio/flac" || extension === "flac") return FILE_FORMAT_FLAC;

        return FILE_FORMAT_UNKNOWN;
      }

      function tryToLoadCollectionFile(files) {
        const supportedFiles = [];
        const detectedFileFormats = new Set();
        for (const file of files) {
          const detectedFileFormat = detectFileFormat(file);
          if (detectedFileFormat !== FILE_FORMAT_UNKNOWN) {
            detectedFileFormats.add(detectedFileFormat);
            supportedFiles.push(file);
          }
        }
        if (supportedFiles.length > 1 && detectedFileFormats.size === 1) {
          // If we receive many files all of a type that we load
          // as just one sample, create a sample group for those.
          if (detectedFileFormats.has(FILE_FORMAT_WAV)) {
            loadWavs(supportedFiles);
            return;
          } else if (
            detectedFileFormats.has(FILE_FORMAT_MP3) ||
            detectedFileFormats.has(FILE_FORMAT_OGG) ||
            detectedFileFormats.has(FILE_FORMAT_FLAC)
          ) {
            loadFilesViaWebAudioOrWavefile(supportedFiles);
            return;
          } else if (detectedFileFormats.has(FILE_FORMAT_PLAIN_TEXT)) {
            loadSampleTextFiles(supportedFiles);
            return;
          }
        } else if (supportedFiles.length > 1) {
          // If we receive many files, all of which are supported by the
          // Web Audio API, then create a sample group for those.
          let onlyHasWebAudioCompatibleFiles = true;
          for (const detectedFileFormat of detectedFileFormats) {
            if (!(
                detectedFileFormat === FILE_FORMAT_WAV ||
                detectedFileFormat === FILE_FORMAT_MP3 ||
                detectedFileFormat === FILE_FORMAT_OGG ||
                detectedFileFormat === FILE_FORMAT_FLAC
              )) {
              onlyHasWebAudioCompatibleFiles = false;
              break;
            }
          }
          if (onlyHasWebAudioCompatibleFiles) {
            loadFilesViaWebAudioOrWavefile(supportedFiles);
            return;
          }
        }
        for (const file of supportedFiles) {
          const detectedFileFormat = detectFileFormat(file);
          switch (detectedFileFormat) {
            case FILE_FORMAT_SF2:
              loadSf2(file);
              break;
            case FILE_FORMAT_WAV:
              loadWav(file);
              break;
            case FILE_FORMAT_JS:
              loadSampleScript(file);
              break;
            case FILE_FORMAT_PLAIN_TEXT:
              loadSampleTextFile(file);
              break;
            case FILE_FORMAT_MP3:
            case FILE_FORMAT_OGG:
            case FILE_FORMAT_FLAC:
              loadFileViaWebAudio(file);
              break;
            default:
              console.warn("Unknown file format:", file);
              break;
          }
          // We only support loading one collection file at a time.
          break;
        }
      }

      const filePickerEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "change":
              tryToLoadCollectionFile(filePicker.files);
              break;
          }
        },
      };

      const windowEventHandler = {
        handleEvent: (event) => {
          switch (event.type) {
            case "dragover": {
              event.preventDefault();
              event.dataTransfer.dropEffect = "move";
              break;
            }
            case "drop": {
              event.preventDefault();
              const files = event.dataTransfer.files;
              filePicker.files = event.dataTransfer.files;
              tryToLoadCollectionFile(files);
              break;
            }
          }
        },
      };

      function refreshSampleList(collection) {
        sampleList.innerHTML = "";

        if (collection == null) {
          sampleListArea.style.display = "none";
        } else {
          sampleListArea.style.display = "";
          sampleListCollectionFilenameDisplay.innerText = collection.name;
          const onlyHasOneUntitledGroup = (
            collection.sampleGroups.length === 1 &&
            collection.sampleGroups[0].name == null
          );
          for (let groupIndex = 0; groupIndex < collection.sampleGroups.length; groupIndex++) {
            const group = collection.sampleGroups[groupIndex];
            let optionParent = sampleList;
            let optionGroup = null;
            if (!onlyHasOneUntitledGroup) {
              optionGroup = document.createElement("optgroup");
              optionGroup.label = group.name;
              optionGroup.dataset.index = groupIndex;
              optionParent = optionGroup;
            }
            for (let sampleIndex = 0; sampleIndex < group.samples.length; sampleIndex++) {
              const sample = group.samples[sampleIndex];
              const option = document.createElement("option");
              option.value = sampleIndex;
              option.innerText = sample.name;
              optionParent.appendChild(option);
            }
            if (!onlyHasOneUntitledGroup) sampleList.appendChild(optionGroup);
          }
        }
      }

      function renderInfoRows(container, rows) {
        container.innerHTML = "";
        for (const row of rows) {
          if (row == null) continue;
          const [label, value] = row;
          if (value == null) continue;
          const rowElement = document.createElement("li");
          const labelElement = document.createElement("strong");
          labelElement.innerText = label;
          const valueElement = document.createElement("span");
          valueElement.innerText = value;
          rowElement.appendChild(labelElement);
          rowElement.appendChild(document.createTextNode(" "));
          rowElement.appendChild(valueElement);
          container.appendChild(rowElement);
        }
      }

      function refreshSampleInfo(group, sample, hasMultipleSamplesSelected) {
        let instrumentName = null;
        let name = null;
        let format = null;
        let sampleRate = null;
        let length = null;
        let loopStart = null;
        let loopEnd = null;

        if (hasMultipleSamplesSelected) {
          outputSampleInfoContainer.style.display = "none";
          exportArea.style.display = "";
          sampleInfoContainer.innerHTML = "";
          const n = sampleList.selectedOptions.length;
          const message = document.createTextNode(`There are ${n} samples selected.`);
          sampleInfoContainer.appendChild(message);
        } else {
          if (sample != null) {
            if (group != null) {
              instrumentName = group.name;
            }
            name = sample.name;
            format = getSampleFormatName(sample.format);
            sampleRate = sample.sampleRate;
            length = sample.data.length;
            loopStart = sample.loopStart;
            loopEnd = sample.loopEnd;
          }

          renderInfoRows(sampleInfoContainer, [
            ["Instrument:", instrumentName],
            ["Name:", name],
            ["Format:", format],
            ["Sample Rate:", sampleRate],
            ["Length (in samples):", length],
            ["Loop start (in samples):", loopStart],
            ["Loop end (in samples):", loopEnd],
          ]);

          if (sample == null) {
            exportArea.style.display = "none";
          } else {
            exportArea.style.display = "";
          }
          if (!shouldResample) {
            outputSampleInfoContainer.style.display = "none";
          } else {
            outputSampleInfoContainer.style.display = "";
            const newSampleRate = +outputSampleRateStepper.value;
            renderInfoRows(outputSampleInfoContainer, [
              ["New loop start:", Math.floor((loopStart / sampleRate) * newSampleRate)],
              ["New loop end:", Math.floor((loopEnd / sampleRate) * newSampleRate)],
            ]);
          }
        }

        if (!shouldResample) {
          outputSampleRateRow.style.display = "none";
        } else {
          outputSampleRateRow.style.display = "";
        }
      }

      function main() {
        audioContext = new AudioContext({
          sampleRate: 44100
        });
        sampleLoadingAudioContext = new AudioContext({
          sampleRate: sampleLoadingSampleRate
        });

        generatedWavLink = document.createElement("a");
        generatedWavLink.download = "";
        generatedWavLink.href = "";
        generatedZipLink = document.createElement("a");
        generatedZipLink.download = "";
        generatedZipLink.href = "";

        outputSampleRateStepper.value = "44100";
        resampleBox.checked = shouldResample;
        instrumentNameBox.checked = shouldExportSamplesWithInstrumentName;

        refreshSampleList(loadedCollection);
        refreshSampleInfo(selectedSampleGroup, selectedSample, hasMultipleSamplesSelected);
        refreshPlayNoteButton();

        supportedFormatsLink.addEventListener("click", supportedFormatsLinkEventHandler);
        overlay.addEventListener("click", overlayEventHandler);
        overlayCloseButton.addEventListener("click", overlayCloseButtonEventHandler);
        sampleList.addEventListener("change", sampleListEventHandler);
        sampleList.addEventListener("keydown", sampleListEventHandler);
        resampleBox.addEventListener("input", resampleBoxEventHandler);
        instrumentNameBox.addEventListener("input", instrumentNameBoxHandler);
        outputSampleRateStepper.addEventListener("input", outputSampleRateStepperEventHandler);
        playNoteButton.addEventListener("click", playNoteEventHandler);
        exportAsWavButton.addEventListener("click", exportAsWavEventHandler);
        exportAsZipButton.addEventListener("click", exportAsZipEventHandler);
        filePicker.addEventListener("change", filePickerEventHandler);
        window.addEventListener("dragover", windowEventHandler);
        window.addEventListener("drop", windowEventHandler);
      }

      main();
      
    </script>

  </body>

</html>