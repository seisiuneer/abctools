<html>
  
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <link rel="profile" href="http://gmpg.org/xfn/11">
    <title>ABC Phrase-by-Phrase Tune Builder</title>
    <link rel='dns-prefetch' href='//fonts.googleapis.com' />
    <link rel='dns-prefetch' href='//s.w.org' />
    <link rel='preconnect' href='https://secureservercdn.net' crossorigin />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="ABC Phrase-by-Phrase Tune Builder" />
    <meta property="og:description" content="ABC Phrase-by-Phrase Tune Builder." />
    <meta property="og:url" content="https://michaeleskin.com/tools/phrase_builder.html" />
    <meta property="og:site_name" content="ABC Phrase-by-Phrase Tune Builder" />
    <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png" />
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
    <meta name="viewport" content="width=860">
    <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">
    <link rel="manifest" href="https://michaeleskin.com/abctools/img/abc-manifest.json">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>
    
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-VM0N9HL3MK');
    </script>

    <style>
      
      textarea {
      width:600px;height:200px
      }

      body {
      background-color: #ffffff;
      }

      select{
      margin-left:24px;
      }

      textarea#input {
      width: 100%;
      margin-bottom: 0px;
      }

      textarea#output {
      width: 100%;
      }

      p {
      font-size:12pt;
      font-family:"Helvetica";
      line-height: 24px;
      margin-bottom:0px;
      }

      h1 {
      font-size:18pt;
      font-family:"Helvetica";
      margin-bottom:0px;
      }

      h2 {
      font-size:14pt;
      font-family:"Helvetica";
      margin-bottom:18px;
      }

      h4 {
      font-size:14pt;
      font-family:"Helvetica";
      margin-bottom:8px;
      }

      hr {
      margin-top:24px;
      margin-bottom:24px;
      }

      body {
      padding:20px;
      }

      .image_holder{
      text-align: center;
      width:240px;
      height:240px;
      margin-left:auto;
      margin-right:auto;
      }

      #maindiv{
      position: absolute;
      left: 50%;
      margin-right: -50%;
      transform: translate(-50%, 0%);
      text-align: left;
      width: 800px;
      background-color: white;
      }

      .inputbox{
        position:absolute;
        left:170px;
      }

      .recommended{
        position:absolute;
        left:300px;
      }

      select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100' fill='%238C98F2'><polygon points='0,0 100,0 50,50'/></svg>") no-repeat;
      background-size: 12px;
      background-position: calc(100% - 10px) center;
      background-repeat: no-repeat;
      background-color: #efefef;
      color:black;
      }

      #tablature_options{
      font-size:11pt;
      font-family:"Helvetica";
      height:32px;
      width:205px;
      margin-left:0px;
      }

      #layout{
      font-size:11pt;
      font-family:"Helvetica";
      height:32px;
      width:85px;
      margin-left:0px;
      margin-right:24px;
      }

      #root_scale{
      font-size:11pt;
      font-family:"Helvetica";
      height:32px;
      width:80px;
      margin-left:0px;
      }

      #phraseLength{
      font-size:12pt;
      font-family:"Helvetica";
      width:60px;
      padding:5px;
      }

      #phrasePadding{
      font-size:12pt;
      font-family:"Helvetica";
      width:60px;
      padding:5px;
      }


      .btn {
        --color: #000000;
        --background-color: #d8d8d8;
        --border-color: darken(#d8d8d8, 7.5%);
        color: var(--color);
        font-family: helvetica !important;
        font-size: 11pt !important;
        background-color: var(--background-color);
        padding: 0.7rem 0.7rem;
        padding-top: 0.8rem;
        border: solid 1px var(--border-color);
        outline: none;
        position: relative;
        border-radius: 0.5rem;
        user-select: none;
        box-shadow: 0 0.1rem 0.1rem rgba(0, 0, 0, 0.25), 0 -0.1rem 0.5rem rgba(0, 0, 0, 0.1) inset;
        transition: box-shadow 64ms ease-out;
        -webkit-appearance:none;
      }

      .btn:after {
        content: "";
        background-color: #ffffff;
        width: 75%;
        height: 12.5%;
        position: absolute;
        top: 0.15rem;
        left: 12.5%;
        border-radius: 50%;
        filter: blur(0.15rem);
        transition: opacity 64ms ease-out;
      }

      .btn:active {
        box-shadow: 0 0 0 rgba(0, 0, 0, 0.4), 0 0.4rem 1rem rgba(0, 0, 0, 0.3) inset;
      }
      .btn:active:after {
        opacity: 0;
      }

      .btn-info {
        --color: #ffffff;
        --background-color: #0091ea;
        --border-color: #0079c4;
      }
      .btn-info:active {
        --color: #ececec;
      }
      .btn-success {
        --color: #ffffff;
        --background-color: #00c853;
        --border-color: #00a243;
      }
      .btn-success:active {
        --color: #ececec;
      }
      .btn-warning {
        --color: #3e2723;
        --background-color: #ffc400;
        --border-color: #d9a700;
      }
      .btn-warning:active {
        --color: #261815;
      }
      .btn-error {
        --color: #ffffff;
        --background-color: #d50000;
        --border-color: #af0000;
      }
      .btn-error:active {
        --color: #ececec;
      }
      .btn-dark {
        --color: #ffffff;
        --background-color: #303030;
        --border-color: #1d1d1d;
      }
      .btn-dark:active {
        --color: #ececec;
      }


      .btn-controls{
        --color: black;
        --background-color: lavender;
      }

      .btn-generate{
        --color: black;
        --background-color: #BBFFBB;
      }


      /* For modal dialog prompt replacement */
      .modal_flat_background { background-color: #000; opacity: 0.4; }
      .modal_flat_main { border: 1px solid #333; box-shadow: 0px 0px 15px -2px rgba(0,0,0,0.75);  }

      /* font size only */
      .modal_flat_main, .modal_flat_main input, .modal_flat_main button {  font-size: 16px; }

      .modal_flat_main input, .modal_flat_main button {  padding: 5px; box-sizing: border-box; }
      .modal_flat_inner { padding: 30px; background: #fff; color: #000; }
      .modal_flat_content { font-family:"Helvetica"; margin: 20px 0px;}
      .modal_flat_input { margin: 20px 0px;}
      .modal_flat_buttons { text-align:center;margin-top: 40px; }
      .modal_flat_main button { background-color: #ccc; color: #000; padding: 10px 20px; border: 0px; cursor: pointer; outline: none; width: 100px;  }
      .modal_flat_cancel {margin-left: 5px;}
  </style>
  </head>
  <body>
    
	<div id="maindiv">
	      
	  <div>
	    <div style="text-align: center;">
	      <h1 style="margin-top:0px;">ABC Phrase-by-Phrase Tune Builder</h1>
	      <h2>For use with the ABC Transcription Tools "Tune Trainer"</h2>
	      
	      <hr>

	      <!-- New button to show instructions in a modal -->
	      <p style="margin-top:16px;">
	        <button class="btn btn-controls" onclick="showInstructionsModal();">
	          Instructions
	        </button>
	      </p>
	    </div>

	    <!-- Instructions are now hidden here and only used as modal content -->
	    <div id="instructions" style="display:none;">
	      <h1 style="text-align: center;">Instructions</h1>
	      <p>This utility walks through all the tunes in an ABC tunebook, flattens all tune repeats, divides the tunes in to specified measure number phrases and inserts the same number of full measure rests after each phrase.</p>
	      <p>This makes it easy to do "call-and-response" style practice using the ABC Transcription Tools "Tune Trainer".</p>
	      <p>The utility works best on tunes that have complete measures inside of repeat bars.</p>
	      <p>You may need to rework the ABC for tunes with partial measures inside of repeat bars to use them with this tool.</p>
	      <p>Partial measure pickups before the first full bar in a tune will be stripped.</p>
	      <p>1)&nbsp;Click <strong>Open an existing .ABC file</strong> to open a file or paste a ABC tune into the <strong>Original ABC Tunes</strong> box below.</p>
	      <p>2)&nbsp;Enter your desired phrase length in <strong>Phrase length in measures</strong> (default is 2).</p>
        <p>3)&nbsp;If you want additional full measure padding between the phrases, enter a number into <strong>Additional full-measure rest padding between phrases</strong></p>
	      <p>4)&nbsp;Click <strong>Generate Phrase-by-Phrase ABC Version</strong>.</p>
	      <p>5)&nbsp;The generated phrase-by-phrase ABC version will be shown in the <strong>Expanded Phrase-by-Phrase ABC Version</strong> box.</p>
	      <p>6)&nbsp;Save, Copy or Open the results:</p>
	      <p>- Click <strong>Save to a file</strong> to save the phrase-by-phrase ABC version to a file.</p>
	      <p>- Click <strong>Copy to the clipboard</strong> to copy the phrase-by-phrase ABC version to the system clipboard for pasting into other applications.</p>
	      <p>- Click <strong>Open in the ABC Transcription Tools</strong> to open the phrase-by-phrase ABC version in my <a href="https://michaeleskin.com/abctools/abctools.html" target="_blank">ABC Transcription Tools</a></p>
	      <p>If the share link generated to directly open the tunes is too long to open, you will be presented with an alert explaining the issue.</p>
	      <p>If this happens, click <strong>Copy to the clipboard</strong> and then paste the ABC into the ABC Transcription Tools.</p>
	    </div>
	  </div>
      
      <hr id="abcinput">
      
      <div style="text-align:left">
        
        <h4>Original ABC Tunes:</h4>
        
        <div style="margin-top:28px;margin-bottom:36px;">
          <p>
            <input type="file" id="selectabcfile" accept=".abc,.txt,.ABC,.TXT"  hidden/>
            <label class="abcupload btn btn-controls" for="selectabcfile" title="Opens an existing ABC file">Open an existing .ABC file</label>
          </p>
        </div>

        <p>
          <textarea id="input" placeholder="Enter one or more ABC tunes here" spellcheck="false" autocorrect="off" autocapitalize="none">
          </textarea>
        </p>
      
        <p>
          Phrase length in measures:&nbsp;&nbsp;<input type="number" id="phraseLength" value="2"/>
        </p>

        <p>
          Additional full-measure rest padding between phrases:&nbsp;&nbsp;<input type="number" id="phrasePadding" value="0"/>
        </p>    

        <p style="margin-top:24px"><button id="generateShareLink" class="btn btn-generate" onClick="UI_GeneratePhraseByPhrase();">Generate Phrase-by-Phrase Version</button></p>
        
        <div style="margin-bottom: 8px;">
          <h4>Expanded Phrase-by-Phrase ABC Version:</h4>
        </div>
        
        <textarea id="output" placeholder="Expanded phrase-by-phrase ABC versions will appear here" spellcheck="false" autocorrect="off" autocapitalize="none"></textarea>
        
        <h4>Options for opening directly in the ABC Transcription Tools:</h4>
        
        <p>

          <span style="">Tablature option:&nbsp;&nbsp;</span>
          
          <select id="tablature_options">
            
            <option value="noten">&nbsp;&nbsp;Standard notation only</option>
            <option value="notenames">&nbsp;&nbsp;Note names</option>
            <option value="mandolin">&nbsp;&nbsp;Mandolin</option>
            <option value="gdad">&nbsp;&nbsp;GDAD Bouzouki</option>
            <option value="cgda">&nbsp;&nbsp;CGDA Mandola</option>
            <option value="cgdae">&nbsp;&nbsp;CGDAE Bouzouki</option>
            <option value="dgdae">&nbsp;&nbsp;DGDAE Bouzouki</option>
            <option value="guitare">&nbsp;&nbsp;Standard tuned guitar</option>
            <option value="guitard">&nbsp;&nbsp;DADGAD tuned guitar</option>
            <option value="uke">&nbsp;&nbsp;Ukulele</option>
            <option value="whistle">&nbsp;&nbsp;Whistle</option>
            
          </select>
          
        </p>

        <p><input type="checkbox" id="addAutoPlay">&nbsp;&nbsp;Add Auto-Play </p>
      
        <p style="margin-top:20px;text-align: center;">
          
          <button id="copybutton" class="btn btn-controls" onClick="copyOutputToClipboard();">Copy to the clipboard</button>
          
          <button style="margin-left:24px;" class="btn btn-controls" onClick="saveOutput();">Save to a file</button>
          
          <button style="margin-left:24px;" class="btn btn-controls" onClick="testOutput();">Open in the ABC Transcription Tools</button>
          
        </p>
        
      </div>
                  
      <hr>
      
      <div style="text-align: center;">
        
        <p style="text-align: center">Complete source code for this utility may be found on GitHub</p>
        
        <p style="text-align: center"> <a href="https://github.com/seisiuneer/abctools/tree/main/tools" target="_blank">ABC Phrase-by-Phrase Tune Builder on Github</a></p>
        
        <hr style="margin-bottom:50px">
        
      </div>
      
    </div>
    
  </body>
  
  <script type="text/javascript" src="lz-string.min.js?v=2"></script>
  <script type="text/javascript" src="pako.min.js?v=1"></script>
  <script type="text/javascript" src="daypilot-modal.min-3.10.1.js?v=2"></script>

  <script>

//
// Flatten repeats and break tune into phrases for the Tune Trainer
//
function processAbcPhrases(abcText, phraseBars, phrasePadding) {

  if (!Number.isInteger(phraseBars) || phraseBars <= 0) {
    return abcText;
  }

  if (!Number.isInteger(phrasePadding) || phrasePadding < 0) {
    return abcText;
  }

  // Strip all ! at the end of lines
  abcText = abcText.replace(/!+$/gm, "");

  // Strip all \ at the end of lines
  abcText = abcText.replace(/\\$/gm, "");

  // Normalize line endings
  let norm = abcText.replace(/\r\n/g, "\n");

  // Ignore any text before the first X:
  const firstX = norm.search(/^\s*X\s*:/m);
  if (firstX === -1) {
    return abcText;
  }
  norm = norm.slice(firstX);

  const lines = norm.split("\n");

  const tunes = [];
  let cur = [];

  for (const ln of lines) {
    if (/^\s*X\s*:/i.test(ln)) {
      if (cur.length > 0) {
        tunes.push(cur.join("\n").trim());
      }
      cur = [ln];
    } else {
      cur.push(ln);
    }
  }
  if (cur.length > 0) {
    tunes.push(cur.join("\n").trim());
  }

  const outputs = tunes
    .map(t => t.trim())
    .filter(t => t.length > 0)
    .map(t => processSingleTune(t, phraseBars, phrasePadding));

  return outputs.join("\n");

  // ------------------------------------------------------------
  // Process a single tune
  // ------------------------------------------------------------
  function processSingleTune(abcText, phraseBars, phrasePadding) {
    const lines = abcText.replace(/\r\n/g, "\n").split("\n");

    // Reject multiple voices
    for (const ln of lines) {
      if (/^\s*V\s*:/i.test(ln)) {
        return abcText;
      }
    }

    // ---- Separate header and body ----
    let headerLines = [];
    let bodyLines = [];
    let inBody = false;
    let sawK = false;

    for (const ln of lines) {

      const trimmed = ln.trim();

      if (!inBody) {
        // Still in header region
        if (/^\s*K\s*:/i.test(trimmed)) {
          sawK = true;
          headerLines.push(trimmed);
          continue;
        }

        if (!sawK) {
          // Before K:, everything is header
          headerLines.push(trimmed);
        } else {
          // After K:, still treat % / %% / field lines / blanks as header
          if (
            /^\s*[%]/.test(trimmed) ||          // % or %%
            /^\s*[A-Za-z]\s*:/.test(trimmed) || // another field line
            /^\s*$/.test(trimmed)               // blank
          ) {
            headerLines.push(trimmed);
          } else {
            // First real music line -> body starts here
            inBody = true;
            bodyLines.push(trimmed);
          }
        }
      } else {
        // ---- We are in the body (music region) ----

        // Skip any % line after the header (e.g. %newpage)
        if (/^\s*%/.test(trimmed)) {
          continue;
        }

        bodyLines.push(trimmed);
      }
    }

    if (!sawK) {
      return abcText;
    }

    // Only offer barsperstaff if no padding
    if (phrasePadding == 0){
      headerLines.push("%");
      headerLines.push("% Remove the x from the start of the next line to display");
      headerLines.push("% the ABC with alternating staves of notation and rests:");
      headerLines.push("%");
      headerLines.push("%%xbarsperstaff "+phraseBars);
      headerLines.push("%%stretchlast 1");
      headerLines.push("%");
      headerLines.push("% If there is a partial measure pickup before the tune, to use");
      headerLines.push("% barsperstaff you will need to manually delete the pickup from the ABC.");
      headerLines.push("%");
    }

    const header = headerLines.join("\n");
    let body = bodyLines.join("\n").trim();

    if (!body) {
      return abcText; // no notes, just return tune as-is
    }

    // ---- Extract M: and L: for pickup/rest calculations ----
    // Handle numeric meters AND M:C / M:C|
    const mLineMatch = abcText.match(/^\s*M\s*:\s*([^\r\n]+)/im);
    if (!mLineMatch) {
      return abcText;
    }

    const mValueRaw = mLineMatch[1].trim();
    let meterNum, meterDen;

    if (/^C\|$/i.test(mValueRaw)) {
      // Cut time: M:C|  -> 2/2
      meterNum = 2;
      meterDen = 2;
    } else if (/^C$/i.test(mValueRaw)) {
      // Common time: M:C  -> 4/4
      meterNum = 4;
      meterDen = 4;
    } else {
      // Standard numeric meter like 4/4, 6/8, etc.
      const mMatch = mValueRaw.match(/^(\d+)\s*\/\s*(\d+)$/);
      if (!mMatch) {
        // Unrecognized meter format, bail out and leave tune unchanged
        return abcText;
      }
      meterNum = parseInt(mMatch[1], 10);
      meterDen = parseInt(mMatch[2], 10);
    }

    const lMatch = abcText.match(/^\s*L\s*:\s*([\d]+)\/([\d]+)/im);
    let lNum, lDen;
    if (lMatch) {
      lNum = parseInt(lMatch[1], 10);
      lDen = parseInt(lMatch[2], 10);
    } else {
      // ABC default
      lNum = 1;
      lDen = 8;
    }

    // ---- One-bar rest string ----
    const oneBarRest = computeOneBarRest(meterNum, meterDen, lNum, lDen);

    // ---- Normalize [1/[2 endings to |1/|2 ----
    body = normalizeEndings(body);

    // ---- Parse body into measures ----
    const measures = parseMeasures(body);

    // ---- Expand repeats & first/second endings ----
    let flatMeasures = expandRepeatsAndEndings(measures);

    // ---- Regroup into full-length bars (only a single initial pickup may remain partial)
    let fullBarMeasures = resegmentIntoFullBars(flatMeasures, meterNum, meterDen, lNum, lDen);

    // ---- Detect if the very first note measure is a partial pickup ----
    const hasPickup = detectInitialPickupMeasure(fullBarMeasures, meterNum, meterDen, lNum, lDen);

    // ---- Insert phrase-length rest measures after each phrase ----
    let phrasedMeasures = injectPhraseRests(fullBarMeasures, phraseBars, phrasePadding, oneBarRest, hasPickup);

    // ---- Clear any internal |]; final |] will be added in rebuild ----
    phrasedMeasures = phrasedMeasures.map(m =>
      m.bar === "|]" ? { ...m, bar: "|" } : m
    );

    // ---- Rebuild body ----
    const newBody = rebuildBodyFromMeasures(phrasedMeasures, phraseBars, phrasePadding, hasPickup);

    return header + "\n" + newBody;
  }

  /* ----------------- Helper: compute one bar rest ------------------ */

  function computeOneBarRest(mNum, mDen, lNum, lDen) {
    const unitsPerBar = (mNum * lDen) / (mDen * lNum);

    if (!Number.isFinite(unitsPerBar) || unitsPerBar <= 0) {
      // Fallback
      return "z4";
    }

    const rounded = Math.round(unitsPerBar);
    if (Math.abs(unitsPerBar - rounded) > 1e-6) {
      // Non-integer bar length in L: units – fallback
      return "z4";
    }

    if (rounded === 1) return "z";
    return "z" + rounded; // e.g. z4 for 2/4 with L:1/8
  }

  /* ----------------- Helper: note length parsing ------------------ */

  function parseAbcLength(s, pos) {
    let numStr = "";
    while (pos < s.length && /\d/.test(s[pos])) {
      numStr += s[pos++];
    }

    let num = numStr ? parseInt(numStr, 10) : 1;
    let denom = 1;

    let slashCount = 0;
    while (pos < s.length && s[pos] === "/") {
      slashCount++;
      pos++;
    }

    if (slashCount > 0) {
      denom = Math.pow(2, slashCount);
    }

    const value = num / denom;
    return { value, newPos: pos };
  }

  /**
   * Compute the length (in L: units) of a measure's notes.
   * Ignores decorations, chords, grace notes, etc.
   * Simple support for triplets: (3ABC = 3 notes in the time of 2.
   */
  function computeMeasureUnits(text) {
    let s = text || "";

    // Remove grace notes { ... }
    s = s.replace(/\{[^}]*\}/g, "");

    let pos = 0;
    let totalUnits = 0;

    let tupletNotesLeft = 0;
    let tupletFactor = 1; // multiply note length by this inside tuplet

    while (pos < s.length) {
      const ch = s[pos];

      // Whitespace or simple decorations
      if (
        /\s/.test(ch) ||
        ch === "!" || ch === "\"" ||
        ch === "[" || ch === "]"
      ) {
        pos++;
        continue;
      }

      // Tuplet start: (3 -> next 3 notes in the time of 2
      if (ch === "(") {
        const next = s[pos + 1];
        if (next && /[2-9]/.test(next)) {
          const n = parseInt(next, 10);
          if (n === 3) {
            tupletNotesLeft = 3;
            tupletFactor = 2 / 3; // 3 notes in time of 2
          } else {
            tupletNotesLeft = 0;
            tupletFactor = 1;
          }
          pos += 2;
          continue;
        } else {
          pos++;
          continue;
        }
      }

      // Accidentals
      if (ch === "^" || ch === "_" || ch === "=") {
        pos++;
        continue;
      }

      if (/[A-Ga-gzZxY]/.test(ch)) {
        pos++;
        // Skip octave marks , ' ’
        while (pos < s.length && /[,'’]/.test(s[pos])) pos++;

        const { value: baseUnits, newPos } = parseAbcLength(s, pos);
        pos = newPos;

        let lengthUnits = baseUnits;
        if (tupletNotesLeft > 0) {
          lengthUnits *= tupletFactor;
          tupletNotesLeft--;
          if (tupletNotesLeft === 0) {
            tupletFactor = 1;
          }
        }

        totalUnits += lengthUnits;
        continue;
      }

      // Anything else: skip
      pos++;
    }

    return totalUnits;
  }

  /* ----------------- Helper: detect initial pickup measure ------------------ */

  function detectInitialPickupMeasure(measures, mNum, mDen, lNum, lDen) {
    const unitsPerBar = (mNum * lDen) / (mDen * lNum);
    const EPS = 1e-6;

    const firstNoteIdx = measures.findIndex(
      (m) => m.notes && m.notes.trim().length > 0
    );
    if (firstNoteIdx === -1) return false;

    const firstLen = computeMeasureUnits(measures[firstNoteIdx].notes || "");
    if (firstLen > EPS && firstLen < unitsPerBar - EPS) {
      // true => there is a pickup at the very start of the tune
      return true;
    }
    return false;
  }

  /* ----------------- Helper: normalize [1/[2 and spaced endings ------ */

  function normalizeEndings(body) {
    let out = body;

    // Collapse spaces between barlines and 1/2 so parseMeasures sees |1, |2, :|1, :|2
    out = out.replace(/(\|\s+)([12])/g, "|$2");
    out = out.replace(/(:\|\s+)([12])/g, ":|$2");

    // Convert [1 / [2 forms to |1 / |2 so they’re also recognized
    out = out.replace(/(\||:)\[([12])/g, "$1$2");
    out = out.replace(/(^|\s)\[([12])/g, "$1|$2");

    return out;
  }

  /* ----------------- Helper: parse measures (no original newlines) ---- */

  function parseMeasures(body) {
    const measures = [];
    let cur = "";

    function pushMeasure(barToken) {
      const notes = cur.replace(/\s+$/g, ""); // trim right
      measures.push({
        notes,
        bar: barToken
      });
      cur = "";
    }

    let i = 0;
    while (i < body.length) {
      const ch = body[i];

      // Normalize original newlines to at most a single space
      if (ch === "\n" || ch === "\r") {
        if (cur && !/\s$/.test(cur)) {
          cur += " ";
        }
        i++;
        continue;
      }

      if (ch === "|") {
        const next = body[i + 1] || "";

        if (next === ":") {
          pushMeasure("|:");
          i += 2;
        } else if (next === "|") {
          pushMeasure("||");
          i += 2;
        } else if (next === "1" || next === "2") {
          pushMeasure("|" + next);
          i += 2;
        } else if (next === "]") {
          pushMeasure("|]");
          i += 2;
        } else {
          pushMeasure("|");
          i += 1;
        }
      } else if (ch === ":") {
        const next = body[i + 1] || "";
        const next2 = body[i + 2] || "";

        if (next === "|") {
          if (next2 === "1" || next2 === "2") {
            pushMeasure(":|" + next2);
            i += 3;
          } else {
            pushMeasure(":|");
            i += 2;
          }
        } else {
          cur += ch;
          i++;
        }
      } else {
        cur += ch;
        i++;
      }
    }

    if (cur.trim().length > 0) {
      const notes = cur.replace(/\s+$/g, "");
      measures.push({ notes, bar: "" });
    }

    return measures;
  }

  /* ----------------- Helper: normalize bars for playback --------------- */

  function normalizeBarPlayback(bar) {
    if (!bar) return bar;
    if (bar === "||") return "|";
    if (
      bar === "|1" || bar === "|2" ||
      bar === ":|1" || bar === ":|2" ||
      bar === ":|"
    ) {
      return "|";
    }
    if (bar.indexOf(":|") !== -1) {
      // handles combined tokens like ":|2"
      return "|";
    }
    return bar;
  }

  /* ----------------- Helper: expand repeats & endings ------------------ */

  function expandRepeatsAndEndings(measures) {
    // Find first explicit start repeat |:
    const firstStartIdx = measures.findIndex(m => m.bar === "|:");

    // No explicit start repeats anywhere → all :| are "repeat from section start"
    if (firstStartIdx === -1) {
      return expandUnmatchedEndRepeats(measures);
    }

    // Prefix (before the first |:) may contain orphan :| repeats (A parts)
    const prefix = measures.slice(0, firstStartIdx);
    const suffix = measures.slice(firstStartIdx);

    const expandedPrefix = expandUnmatchedEndRepeats(prefix);
    const expandedSuffix = expandWithExplicitStarts(suffix);

    return expandedPrefix.concat(expandedSuffix);
  }

  // ----- Smarter handling of :| with 1st/2nd endings and no |: -----

  function expandUnmatchedEndRepeats(measures) {
    const out = [];
    const n = measures.length;
    let i = 0;
    let sectionStart = 0;

    function copySimple(start, end) {
      for (let j = start; j <= end; j++) {
        const m = measures[j];
        out.push({
          notes: m.notes,
          bar: normalizeBarPlayback(m.bar)
        });
      }
    }

    while (i < n) {
      const bar = measures[i].bar || "";
      if (bar.indexOf(":|") !== -1) {
        // We reached the end (i) of a repeating block [sectionStart..i].
        const start = sectionStart;
        const end = i;

        // Look for |1 and |2 within this block
        let marker1 = -1;
        let marker2 = -1;
        for (let j = start; j <= end; j++) {
          const b = measures[j].bar || "";
          if (marker1 === -1 && b.indexOf("1") !== -1) {
            marker1 = j;
          }
          if (marker2 === -1 && b.indexOf("2") !== -1) {
            marker2 = j;
          }
          if (marker1 !== -1 && marker2 !== -1) break;
        }

        // Try to find second-ending notes AFTER the :|2 bar if marker2 == end
        let secondStart = -1;
        let secondEnd = -1;

        if (marker2 !== -1) {
          if (marker2 === end && end + 1 < n) {
            // Typical Cooley's-style: |1 ... :|2 <2nd-ending-notes>...
            secondStart = end + 1;

            // Extend second ending until strong boundary
            let j = secondStart;
            while (j < n) {
              const b = measures[j].bar || "";
              if (
                j > secondStart &&
                (b.indexOf(":|") !== -1 || measures[j].bar === "|:" || b === "||" || b === "|]")
              ) {
                break;
              }
              secondEnd = j;
              if (b === "||" || b === "|]") {
                j++;
                break;
              }
              j++;
            }
            if (secondEnd === -1) {
              secondEnd = secondStart;
            }
          } else if (marker2 + 1 <= end) {
            // Weird but possible: |2 is inside the section and second-ending notes follow it
            secondStart = marker2 + 1;
            secondEnd = end;
          }
        }

        // If we can't sensibly identify a 1st+2nd ending, fall back to simple double repeat
        if (marker1 === -1 || marker2 === -1 || secondStart === -1) {
          copySimple(start, end);
          copySimple(start, end);
          i = end + 1;
          sectionStart = i;
          continue;
        }

        // ABC semantics: "1" attaches to the following bar, so the measure
        // that carries "|1" belongs to the body; first-ending notes begin at marker1+1.
        const bodyStart = start;
        const bodyEnd = marker1;
        const firstStart = marker1 + 1;
        const firstEnd = end;

        if (firstStart > firstEnd || firstStart >= n) {
          // Degrade to simple repeat
          copySimple(start, end);
          copySimple(start, end);
          i = end + 1;
          sectionStart = i;
          continue;
        }

        // --- First pass: body + first ending
        for (let j = bodyStart; j <= bodyEnd; j++) {
          out.push({
            notes: measures[j].notes,
            bar: normalizeBarPlayback(measures[j].bar)
          });
        }
        for (let j = firstStart; j <= firstEnd; j++) {
          out.push({
            notes: measures[j].notes,
            bar: normalizeBarPlayback(measures[j].bar)
          });
        }

        // --- Second pass: body + second ending
        for (let j = bodyStart; j <= bodyEnd; j++) {
          out.push({
            notes: measures[j].notes,
            bar: normalizeBarPlayback(measures[j].bar)
          });
        }
        for (let j = secondStart; j <= secondEnd; j++) {
          out.push({
            notes: measures[j].notes,
            bar: normalizeBarPlayback(measures[j].bar)
          });
        }

        // Advance past the second-ending measures
        i = secondEnd + 1;
        sectionStart = i;
      } else {
        i++;
      }
    }

    // Any leftover measures after the last :|
    if (sectionStart < n) {
      for (let j = sectionStart; j < n; j++) {
        const m = measures[j];
        out.push({
          notes: m.notes,
          bar: normalizeBarPlayback(m.bar)
        });
      }
    }

    return out;
  }

  // ----- EXPLICIT |: HANDLING + buffering of unmatched segments -----

  function expandWithExplicitStarts(measures) {
    const out = [];
    const n = measures.length;

    function isStrongEnd(bar) {
      return !!bar && (bar.indexOf(":|") !== -1 || bar === "||" || bar === "|]");
    }

    // Buffer for regions *without* explicit |:
    let buffer = [];

    function flushBuffer() {
      if (!buffer.length) return;
      const expanded = expandUnmatchedEndRepeats(buffer);
      for (const m of expanded) {
        out.push(m);
      }
      buffer = [];
    }

    function simpleRepeat(startIdx, repeatStart, repeatEndIdx) {
      // |: becomes |
      out.push({ notes: measures[startIdx].notes, bar: "|" });
      for (let j = repeatStart; j <= repeatEndIdx; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }
      for (let j = repeatStart; j <= repeatEndIdx; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }
    }

    let i = 0;

    while (i < n) {
      const m = measures[i];

      if (m.bar !== "|:") {
        // Part of a non-explicit segment; buffer it.
        buffer.push({ notes: m.notes, bar: m.bar });
        i++;
        continue;
      }

      // We hit an explicit |:; first flush any buffered unmatched segment.
      flushBuffer();

      const startIdx = i;
      const repeatStart = i + 1;

      // 1) Find the local end of this repeat block (first strong end after |:)
      let repeatEndIdx = -1;
      for (let j = repeatStart; j < n; j++) {
        if (isStrongEnd(measures[j].bar)) {
          repeatEndIdx = j;
          break;
        }
      }

      if (repeatEndIdx === -1) {
        // Malformed: treat |: as normal bar and continue
        out.push({ notes: m.notes, bar: "|" });
        i++;
        continue;
      }

      // 2) Search for |1 and |2 markers
      let marker1 = -1;
      let marker2 = -1;

      for (let j = repeatStart; j <= repeatEndIdx; j++) {
        const b = measures[j].bar || "";
        if (marker1 === -1 && b.indexOf("1") !== -1) {
          marker1 = j;
        }
        if (marker2 === -1 && b.indexOf("2") !== -1) {
          marker2 = j;
        }
        if (marker1 !== -1 && marker2 !== -1) break;
      }

      // If we didn't find a 2 in the block, look just after it
      if (marker2 === -1) {
        for (let j = repeatEndIdx + 1; j < n; j++) {
          const b = measures[j].bar || "";
          if (measures[j].bar === "|:") break;    // next repeat start
          if (isStrongEnd(b)) break;              // next strong break
          if (b.indexOf("2") !== -1) {
            marker2 = j;
            break;
          }
        }
      }

      // 3) No |1 marker -> simple |: ... :| repeat
      if (marker1 === -1) {
        simpleRepeat(startIdx, repeatStart, repeatEndIdx);
        i = repeatEndIdx + 1;
        continue;
      }

      // NOTE: In ABC, the "1" attaches to the *following* bar.
      // The measure that carries "|1" belongs to the BODY, and
      // the first-ending notes start in the next measure.
      const bodyStart = repeatStart;
      const bodyEnd = Math.max(bodyStart, marker1); // body includes the marker1 measure

      const firstEndingStart = marker1 + 1;
      const firstEndingEnd = repeatEndIdx; // up to the :| (or ||, etc.)

      if (firstEndingStart > firstEndingEnd || firstEndingStart >= n) {
        // No usable first ending; degrade to a simple repeat
        simpleRepeat(startIdx, repeatStart, repeatEndIdx);
        i = repeatEndIdx + 1;
        continue;
      }

      // Still no |2 marker -> treat as simple repeat of everything
      if (marker2 === -1) {
        simpleRepeat(startIdx, repeatStart, repeatEndIdx);
        i = repeatEndIdx + 1;
        continue;
      }

      // In ABC, the "2" also attaches to the following bar, so the
      // second-ending notes begin at marker2 + 1.
      let secondEndingStart = marker2 + 1;
      if (secondEndingStart >= n) {
        simpleRepeat(startIdx, repeatStart, repeatEndIdx);
        i = repeatEndIdx + 1;
        continue;
      }

      let secondEndingEnd = -1;
      for (let j = secondEndingStart; j < n; j++) {
        const b = measures[j].bar || "";
        if (isStrongEnd(b) || (j > secondEndingStart && measures[j].bar === "|:")) {
          secondEndingEnd = j;
          break;
        }
      }
      if (secondEndingEnd === -1) {
        secondEndingEnd = n - 1;
      }

      // 4) Expand: body + firstEnding, body + secondEnding
      out.push({ notes: measures[startIdx].notes, bar: "|" }); // |: becomes |

      // body
      for (let j = bodyStart; j <= bodyEnd; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }
      // first ending
      for (let j = firstEndingStart; j <= firstEndingEnd; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }

      // body again
      for (let j = bodyStart; j <= bodyEnd; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }
      // second ending
      for (let j = secondEndingStart; j <= secondEndingEnd; j++) {
        out.push({
          notes: measures[j].notes,
          bar: normalizeBarPlayback(measures[j].bar)
        });
      }

      i = secondEndingEnd + 1;
    }

    // Flush any leftover unmatched segment after the last |:
    flushBuffer();

    return out;
  }

  /* ----------------- Helper: resegment into full bars ------------------ */
  // After repeats are flattened:
  // - Turn the entire tune into a single sequence of note "events" (in order).
  // - Re-bucket that sequence into bars of length unitsPerBar.
  // - Allow at most one partial: an initial pickup at the very start of the tune.
  // - Avoid ever exceeding unitsPerBar; do NOT glue a short bar to a full bar.
  function resegmentIntoFullBars(measures, mNum, mDen, lNum, lDen) {
    const unitsPerBar = (mNum * lDen) / (mDen * lNum);
    const EPS = 1e-6;

    // 1) Flatten all note-bearing measures into a linear sequence of events.
    //    Ignore original bar tokens here; they were only needed for repeats.
    const events = [];
    for (const m of measures) {
      const notes = (m.notes || "").trim();
      if (!notes) continue;

      const len = computeMeasureUnits(notes);
      if (!Number.isFinite(len) || len <= 0) continue;

      events.push({ notes, len });
    }

    const out = [];
    let pickupHandled = false;
    let curNotes = "";
    let curLen = 0;

    function flushCur() {
      if (curNotes.trim()) {
        out.push({
          notes: curNotes.trim(),
          bar: "|"
        });
      }
      curNotes = "";
      curLen = 0;
    }

    for (let idx = 0; idx < events.length; idx++) {
      const ev = events[idx];
      const notes = ev.notes;
      const len = ev.len;

      const isFull = Math.abs(len - unitsPerBar) <= EPS;
      const isPartial = len < unitsPerBar - EPS;

      // Tune-level pickup: only allowed as the very first short event
      if (
        !pickupHandled &&
        out.length === 0 &&
        curLen === 0 &&
        isPartial
      ) {
        out.push({
          notes,
          bar: "|"
        });
        pickupHandled = true;
        continue;
      }

      if (curLen === 0) {
        // No partial in progress
        if (isFull || len > unitsPerBar + EPS) {
          // Treat as a full bar on its own
          out.push({
            notes,
            bar: "|"
          });
        } else {
          // Start a new partial bar
          curNotes = notes;
          curLen = len;
        }
      } else {
        // We have a partial bar in progress
        if (isPartial) {
          const sum = curLen + len;
          if (sum <= unitsPerBar + EPS) {
            // Combine partial+partial if they fit into one bar
            curNotes = curNotes + " " + notes;
            curLen = sum;
            if (Math.abs(curLen - unitsPerBar) <= EPS) {
              flushCur();
            }
          } else {
            // Would overshoot -> flush current partial, start anew
            flushCur();
            if (isFull || len > unitsPerBar + EPS) {
              out.push({
                notes,
                bar: "|"
              });
            } else {
              curNotes = notes;
              curLen = len;
            }
          }
        } else {
          // Current event is a full bar while a partial is open:
          // close the partial as its own (short) bar, then add this full bar.
          flushCur();
          out.push({
            notes,
            bar: "|"
          });
        }
      }
    }

    // Any leftover (normally zero or a single short bar at the end)
    flushCur();

    return out;
  }

  /* ----------------- Helper: phrase rest injection ------------------ */

  function injectPhraseRests(measures, phraseBars, phrasePadding, oneBarRest, hasPickup) {
    const result = [];

    let firstNoteIdx = measures.findIndex(
      (m) => m.notes && m.notes.trim().length > 0
    );
    if (firstNoteIdx === -1) {
      return measures.slice();
    }

    // If hasPickup, skip counting this first partial bar.
    let phraseStartIndex = firstNoteIdx + (hasPickup ? 1 : 0);
    if (phraseStartIndex >= measures.length) {
      phraseStartIndex = measures.length;
    }

    let barCounter = 0;

    for (let idx = 0; idx < measures.length; idx++) {
      const m = measures[idx];
      result.push({ ...m });

      const hasNotes = m.notes && m.notes.trim().length > 0;
      const hasBar = !!m.bar;

      const countable =
        idx >= phraseStartIndex &&
        hasBar &&
        hasNotes;

      if (countable) {
        barCounter++;

        if (barCounter === phraseBars) {
          for (let k = 0; k < (phraseBars + phrasePadding); k++) {
            result.push({
              notes: oneBarRest,
              bar: "|"
            });
          }
          barCounter = 0;
        }
      }
    }

    return result;
  }

  /* ----------------- Helper: rebuild body with wrapping & final |] ---- */

  function rebuildBodyFromMeasures(measures, phraseBars, phrasePadding, hasPickup) {

    // Drop measures that have no notes
    measures = measures.filter((m) => {
      const hasNotes = m.notes && m.notes.trim().length > 0;
      const hasBar = !!m.bar;
      if (!hasNotes && hasBar) return false;
      if (!hasNotes && !hasBar) return false;
      return true;
    });

    if (!measures.length) {
      return "\n";
    }

    // Force final bar to |]
    const lastIdx = measures.length - 1;
    measures[lastIdx].bar = "|]";

    let out = "";
    let barCount = 0;

    let firstLine = true;

    // If we have a pickup, allow an extra bar on the first line

    let maxBarsThisLine = (phraseBars * 2) + phrasePadding;

    if (hasPickup){
      maxBarsThisLine += 1;
    }

    measures.forEach((m, idx) => {
      const notes = m.notes.trim() || "";
      let bar = m.bar || "";

      if (bar === "||") bar = "|";

      if (notes) {
        if (out && !/\s|\|$/.test(out[out.length - 1])) {
          out += " ";
        }
        out += notes;
      }

      if (bar) {
        out += bar;
        barCount++;

        if (barCount === maxBarsThisLine && idx < measures.length - 1) {
          out += "\n";
          barCount = 0;

          if (firstLine) {
            firstLine = false;
            maxBarsThisLine = (phraseBars * 2) + phrasePadding;
          }
        }
      }
    });

    out = out.replace(/\s{2,}/g, " ");

    return out.trim() + "\n";
  }

}

// 
// Strip all the chords in the ABC
//
function StripChords(theNotes) {

  function match_callback(match) {

    // Don't strip tab annotations, only chords
    if ((match.indexOf('"_') == -1) && (match.indexOf('"^') == -1)) {

      // Try and avoid stripping long text strings that aren't chords
      if (match.length > 9) {
        return match;
      } else
        // If there are spaces in the match, also probably not a chord
        if (match.indexOf(" ") != -1) {
          return match;
        }
      else {
        return "";
      }
    } else {
      return match;
    }

  }

  // Strip out chord markings and not text annotations
  var searchRegExp = /"[^"]*"/gm

  const output = theNotes
    .split('\n')
    .map(line => {
      // If line starts with one of the forbidden prefixes, skip replacement
      if (/^[XTMKLQWZRCAOPNGHBDFSIV]:/.test(line) || /^%/.test(line)) {
        return line;
      } else {
        return line.replace(searchRegExp, match_callback);
      }
    })
    .join('\n');

  // Replace the ABC
  return output;

}

/* ----------------- Share link generation for sending output to the ABC Transcription Tools ---- */

// Compression mode ids
var COMPRESSION_MODE_LZW = 0;      // existing LZ-String / LZW
var COMPRESSION_MODE_DEFLATE = 1;  // new Deflate+Base64URL

function generateShareLink(abcText,shareName,tablatureOption,addAutoPlay) {

    // Base64/Base64URL helpers for Deflate mode
    function bytesToBase64(bytes) {
        var binary = "";
        var len = bytes.length;
        for (var i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function bytesToBase64URL(bytes) {
      return bytesToBase64(bytes)
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");
    }

    // LZW compression wrapper (existing behavior)
    function compressABC_LZW(abcText) {
        return LZString.compressToEncodedURIComponent(abcText);
    }

    // Deflate-based compression
    function compressABC_Deflate(abcText) {
      if (typeof pako === "undefined") {
          throw new Error("pako (Deflate library) is not loaded.");
      }
      var encoder = new TextEncoder();
      var utf8Bytes = encoder.encode(abcText);
      var deflated = pako.deflate(utf8Bytes, { level: 6 });
      return bytesToBase64URL(deflated);
    }

    var baseUrl = "https://michaeleskin.com/abctools/abctools.html";

    // Choose compression mode (replace this with your own UI code as required)
    var compressionMode = COMPRESSION_MODE_LZW;

    var url = "";
    if (compressionMode === COMPRESSION_MODE_DEFLATE) {
        // Deflate-based link: def=...
        var defEncoded = compressABC_Deflate(abcText);
        url = baseUrl + "?def=" + defEncoded + "&format=" + tablatureOption + "&ssp=0&name=" + shareName;
        if (addAutoPlay){
            url += "&play=1";
        }
        else{
            url += "&editor=1";        	
        }
    } else {
        // Existing LZW behavior: lzw=...
        var abcInLZW = compressABC_LZW(abcText);
        url = baseUrl + "?lzw=" + abcInLZW + "&format="+tablatureOption+"&ssp=0&name=" + shareName;
        if (addAutoPlay){
            url += "&play=1";
        }
       else{
            url += "&editor=1";        	
        }
    }

    // Limit URLs to 8100 characters
    if (url.length > 8100) {
        return null;
    }

    return url;

  }

// Globals

// Suggested filename for save
var gSaveFilename = "";

//
// Main processor
//

//
// Create a centered prompt string
//
function makeCenteredPromptString(thePrompt) {
  return '<p style="font-size:12pt;line-height:18pt;font-family:helvetica;text-align:center">' + thePrompt + '</p>';
}

function UI_GeneratePhraseByPhrase(){

	var phraseBars = document.getElementById("phraseLength").value;

	phraseBars = parseInt(phraseBars);

	if ((phraseBars <= 0) || (isNaN(phraseBars))){

		var thePrompt = makeCenteredPromptString("Phrase length must be a positive integer");
	    
	    DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

	    return;
	}

  var phrasePadding = document.getElementById("phrasePadding").value;

  phrasePadding = parseInt(phrasePadding);

  if ((phrasePadding < 0) || (isNaN(phrasePadding))){

    var thePrompt = makeCenteredPromptString("Phrase padding must be greater or equal to zero");
      
      DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

      return;
  }

  var originalAbcText = document.getElementById("input").value;

  originalAbcText = StripChords(originalAbcText);

  originalAbcText = originalAbcText.replaceAll("!","");

  var flattened = processAbcPhrases(originalAbcText, phraseBars, phrasePadding);
  
  document.getElementById("output").value = flattened;

}

function GenerateShareLink(){

    // Get the source ABC
    var abcText = document.getElementById('output').value;

    if (abcText.length == 0) {
		
		var thePrompt = makeCenteredPromptString("No ABC to process!")

        DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

        return;
    }

    // Auto-play requested?
    var addAutoPlay = false;

    if  (document.getElementById('addAutoPlay').checked){

        addAutoPlay = true;
    
    }

    // Get the tablature option from the dropdown
    var tablatureOption = document.getElementById('tablature_options').value;

    //
    // Generate the Share Link
    //
    var url = generateShareLink(abcText,"Phrase_by_Phrase",tablatureOption,addAutoPlay)

    if (url == null){
	   
	   var thePrompt = makeCenteredPromptString("ABC text is too long to generate a Share Link!\n\nInstead, copy and paste the phrase-by-phrase results into the ABC Transcription Tools.");
       
       DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

        // clear size display
        var sz = document.getElementById("linkSize");
        if (sz) {
            sz.innerHTML = "";
        }
    }
    else{
		return url;       
    }
}

//
// Save the Output to a file
//
function saveOutput() {

    var theData = document.getElementById("output").value;

    if (theData.length == 0) {

	   var thePrompt = makeCenteredPromptString("Nothing to save!");

        DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

        return;
    }

    if (gSaveFilename == ""){
        gSaveFilename = "phrase_by_phrase_tune.abc";
    }

    var thePlaceholder = gSaveFilename;


    var thePrompt = "Please enter a filename for your saved ABC file:";

    DayPilot.Modal.prompt(thePrompt, thePlaceholder, {
        theme: "modal_flat",
        top: 194,
        autoFocus: false
    }).then(function(args) {

        var fname = args.result;

        // If the user pressed Cancel, exit
        if (fname == null) {
            return null;
        }

        // Strip out any naughty HTML tag characters
        fname = fname.replace(/[^a-zA-Z0-9_\-. ]+/ig, '');

        if (fname.length == 0) {
            return null;
        }

        // Give it a good extension
        if ((!gIsAndroid) && (!gIsIOS)) {

            if ((!fname.endsWith(".abc")) && (!fname.endsWith(".ABC"))) {

                // Give it a good extension
                fname = fname.replace(/\..+$/, '');
                fname = fname + ".abc";

            }
        } else {
            // iOS and Android have odd rules about text file saving
            // Give it a good extension
            fname = fname.replace(/\..+$/, '');
            fname = fname + ".txt";

        }

        var a = document.createElement("a");

        document.body.appendChild(a);

        a.style = "display: none";

        var blob = new Blob([theData], {
                type: "text/plain"
            });

        var url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = fname;
        a.click();

        document.body.removeChild(a);

        setTimeout(function() {
            window.URL.revokeObjectURL(url);
        }, 1000);

    });

}


//
// Copy the output text are to the clipboard 
// 
function copyOutputToClipboard() {

    var textToCopy = document.getElementById('output').value;

    if (textToCopy.length == 0) {

	    var thePrompt = makeCenteredPromptString("Nothing to copy!")

        DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

        return;

    }

    copyToClipboard(textToCopy);

    // Give some feedback
    document.getElementById("copybutton").innerHTML = "Copied!";

    setTimeout(function() {

        document.getElementById("copybutton").innerHTML = "Copy to the clipboard";

    }, 1250);
}

//
// Copy to Clipboard Polyfill
//
function copyToClipboard(textToCopy) {

    //
    // Put this in a try/catch just to be safe
    //
    try {

        // navigator clipboard api needs a secure context (https)
        if (navigator.clipboard && window.isSecureContext) {

            // navigator clipboard api method'
            return navigator.clipboard.writeText(textToCopy);

        } else {

            // text area method

            let textArea = document.createElement("textarea");

            textArea.value = textToCopy;

            // make the textarea out of viewport
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";

            document.body.appendChild(textArea);

            textArea.focus();
            textArea.select();

            return new Promise((res, rej) => {
                // here the magic happens
                document.execCommand('copy') ? res() : rej();
                textArea.remove();
            });
        }

    } catch (error) {

        console.log("CopyToClipboard error: " + error);

    }
}

//
// Generate and open an ABC Transcription Tools Share URL for the output
//
function testOutput() {

	var theOutput = document.getElementById("output").value;

	if (theOutput.length == 0){

		var thePrompt = makeCenteredPromptString("Nothing to open");

        DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });	
        return;	
	}

    var url = GenerateShareLink();

    if (url.length > 8100) {

	   var thePrompt = makeCenteredPromptString("Output too long to test!");

        DayPilot.Modal.alert(thePrompt, {
            theme: "modal_flat",
            top: 150
        });

        return;
    }

    // Open the transcription tools with the share link
    var w = window.open(url);

}

function showInstructionsModal() {
  var instr = document.getElementById("instructions");
  if (!instr) return;

  var html = instr.innerHTML;

  DayPilot.Modal.alert(html, {
    theme: "modal_flat",
    top: 50,
    width:800
  });
}

//
// Are we on iOS?
//
function isIOS() {
    if (/iPad|iPhone|iPod/.test(navigator.platform)) {
        return true;
    } else {
        return navigator.maxTouchPoints &&
            navigator.maxTouchPoints > 2 &&
            /MacIntel/.test(navigator.platform);
    }
}

//
// Are we on an iPhone?
//
function isIPhone() {
    if (/iPad|iPhone|iPod/.test(navigator.platform)) {
        return true;
    } else {
        return false;
    }
}

//
// Are we on an iPad?
//
function isIPad() {
    return navigator.maxTouchPoints &&
        navigator.maxTouchPoints > 2 &&
        /MacIntel/.test(navigator.platform);
}

//
// Are we on Android?
//
function isAndroid() {
    if (/Android/i.test(navigator.userAgent)) {
        return true;
    } else {
        return false;
    }
}

//
// Are we on Safari?
//
function isSafari(){

    if (/Safari/i.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor)) {
        return true;
    }
    else{
        return false;
    }
}

//
// Are we on Chrome?
//
function isChrome(){

    if (/chrome|chromium|crios/i.test(navigator.userAgent)) {
        return true;
    }
    else{
        return false;
    }
}

//
// Globals
//
var gIsIOS = false;
var gIsAndroid = false;
var gIsSafari = false;
var gIsChrome = false;

//
// Initialization 
//
function DoStartup() {

    var theValue = "";
    theValue += "X: 1\n";
    theValue += "T: The Kesh\n";
    theValue += "R: Jig\n";
    theValue += "M: 6/8\n";
    theValue += "L: 1/8\n";
    theValue += "K: Gmaj\n";
    theValue += "C: Traditional\n";
    theValue += '|:GAG GAB|ABA ABd|edd gdd|edB dBA|\n';
    theValue += 'GAG GAB|ABA ABd|edd gdB|AGF G3:|\n';
    theValue += '|:BAB dBd|ege dBA|BAB dBG|ABA AGA|\n';
    theValue += 'BAB dBd|ege dBd|gfg aga|bgf g3:|\n';

    document.getElementById('input').value = theValue;
    document.getElementById('output').value = "";

    // Reset file selectors
    var fileElement = document.getElementById('selectabcfile');

    fileElement.value = "";

    // Are we on iOS?
    gIsIOS = false;
    if (isIOS()) {
        gIsIOS = true;
    }

    // Are we on Android?
    gIsAndroid = false;

    if (isAndroid()) {
        gIsAndroid = true;
    }

    if (gIsIOS) {
        document.getElementById("selectabcfile").removeAttribute("accept");
    }

    // Are we on Safari?
    gIsSafari = false;
    if (isSafari()){
        gIsSafari = true;
    }

    // Are we on Chrome?
    gIsChrome = false;

    if (!gIsSafari){
        if (isChrome()){
            gIsChrome = true;
        }
    }

    //
    // Setup the file import control
    //
    document.getElementById("selectabcfile").onchange = () => {

        let fileElement = document.getElementById("selectabcfile");

        let file = fileElement.files[0];

        gSaveFilename = file.name;

        // Trim any whitespace
        gSaveFilename = gSaveFilename.trim();

        // Strip out any naughty HTML tag characters
        gSaveFilename = gSaveFilename.replace(/[^a-zA-Z0-9_\-. ]+/ig, '');

        // Replace any spaces
        gSaveFilename = gSaveFilename.replace(/\s/g, '_');

        // Strip the extension
        gSaveFilename = gSaveFilename.replace(/\..+$/, '');
       
        // Clean up the notation while the new file is loading
        document.getElementById('input').value = "";

        const reader = new FileReader();

        reader.addEventListener('load', (event) => {

            document.getElementById('input').value = event.target.result;

            // Reset file selectors
            let fileElement = document.getElementById('selectabcfile');

            fileElement.value = "";


        });

        reader.readAsText(file);

    }

}

//
// Wait for the document to be ready, then fire a function
//

function WaitForReady(fn) {

    if (document.readyState !== 'loading') {
        fn();
        return;
    }

    document.addEventListener('DOMContentLoaded', fn);

}

//
// Wait for the document to be ready, then startup
//

WaitForReady(DoStartup);

</script>
  
</html>
