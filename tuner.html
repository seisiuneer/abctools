<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <meta property="og:type" content="website" />
  <meta property="og:title" content="Chromatic Tuner" />
  <meta property="og:description" content="Simple chromatic instrument tuner (ET, adjustable A4 reference)." />
  <meta property="og:url" content="https://michaeleskin.com/abctools/tuner.html" />
  <meta property="og:site_name" content="Chromatic Tuner" />
  <meta property="og:image" content="https://michaeleskin.com/abctools/img/abc-icon.png" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="https://michaeleskin.com/abctools/img/abc-ms-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="57x57" href="https://michaeleskin.com/abctools/img/abc-apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://michaeleskin.com/abctools/img/abc-apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://michaeleskin.com/abctools/img/abc-apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://michaeleskin.com/abctools/img/abc-apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://michaeleskin.com/abctools/img/abc-apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://michaeleskin.com/abctools/img/abc-apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://michaeleskin.com/abctools/img/abc-apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://michaeleskin.com/abctools/img/abc-apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://michaeleskin.com/abctools/img/abc-apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192" href="https://michaeleskin.com/abctools/img/abc-android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://michaeleskin.com/abctools/img/abc-favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://michaeleskin.com/abctools/img/abc-favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://michaeleskin.com/abctools/img/abc-favicon-16x16.png">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VM0N9HL3MK"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-VM0N9HL3MK');
  </script>

  <title>Chromatic Tuner</title>

  <style>
    :root{
      --accent:#00f2ff;
      --bg:#0f0f0f;
      --panel:#1a1a1a;
      --text:#e0e0e0;
      --ui-max: 700px;
    }

    body{
      font-family:'Segoe UI',sans-serif;
      background:var(--bg);
      color:var(--text);
      margin:0;
      padding:20px;
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    #tuner-ui{
      background:var(--panel);
      border-radius:16px;
      padding:22px;
      box-shadow:0 20px 50px rgba(0,0,0,0.7);
      width:100%;
      text-align:center;
      border:1px solid #333;
      position:relative;
      max-width: var(--ui-max);
    }

    /* Troubleshooting (?) button */
    #help-btn{
      position:absolute;
      top:8px;
      left:8px;
      width:52px;
      height:52px;
      border: 0px;
      color:#e8e8e8;
      font-weight:900;
      font-size:1.75rem;
      line-height:52px;
      text-align:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    @media (hover: hover) and (pointer: fine) {
      #help-btn{ transition: filter 125ms ease; }
      #help-btn:hover{ filter: brightness(1.5); }
      #help-btn:active{ filter: brightness(1.0); }
    }

    /* Small subtle volume level meter:
       - vertically centered to the title row (same vertical center as the H1)
       - right edge is exactly 22px from the right edge of #tuner-ui */
    #level-meter{
      position:absolute;
      top:22px;
      height:10px;
      right:22px;
      width:86px;
      border-radius:3px;
      background:#0a0a0a;
      border:1px solid #2f2f2f;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
      overflow:hidden;
      opacity:0.55;
      pointer-events:none;
      transform: translateY(calc((1.6rem * 1.1 - 10px) / 2));
    }
    #level-meter-fill{
      height:100%;
      width:0%;
      background:var(--accent);
      opacity:0.65;
      transition: width 80ms linear;
    }

    /* Troubleshooting modal */
    #troubleshoot-overlay{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.65);
      z-index:9999;
      padding:16px;
      box-sizing:border-box;
    }
    #troubleshoot-modal{
      max-width:600px;
      width:100%;
      margin:0 auto;
      background:var(--panel);
      border:1px solid #333;
      border-radius:16px;
      box-shadow:0 20px 50px rgba(0,0,0,0.7);
      padding:18px;
      box-sizing:border-box;
      position:relative;
      top:3vh;
      text-align:left;
    }
    #troubleshoot-title{
      font-size:1.25rem;
      font-weight:900;
      margin:10px 0 10px 0;
      color:#e0e0e0;
    }
    #troubleshoot-body{
      font-size:1.0rem;
      line-height:1.45;
      color:#e0e0e0;
      margin:0 0 14px 0;
    }
    #troubleshoot-close{
      width:100%;
      margin-top:12px;
      margin-bottom:12px;
      padding:14px 18px;
      border:1px solid #333;
      font-weight:900;
      cursor:pointer;
      transition:.2s;
      font-size:1.15rem;
      background:var(--accent);
      color:#FEFEFE;
      background-color: black;
    }
    @media (max-width: 600px) {
      #help-btn{
        top:0px;
        left:0px;
      }
      #troubleshoot-modal{
        top:3vh;
      }
      #troubleshoot-close{
        font-size:1.2rem;
        padding:16px 18px;
        border-radius:14px;
      }

      /* keep the meter subtle & tucked in on small screens */
      #level-meter{
        width:74px;
        height:9px;
        opacity:0.5;
        right:22px;
        transform: translateY(calc((1.25rem * 1.1 - 9px) / 2));
      }
    }

    /* Only dim the "live" area (note+delta+meter) */
    #tuner-live{
      transition: opacity 125ms ease, filter 125ms ease;
    }
    /* Slower fade-to-dark (dimmed), quick fade-to-light (undimmed) */
    #tuner-live.dimmed{
      opacity: 0.3;
      filter: saturate(0.85);
      transition-duration: 550ms, 550ms; /* opacity, filter */
    }

    /* Three dropdowns side-by-side; stacked on mobile */
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      margin:10px 0 10px;
      align-items:start;
    }

    label{
      display:block;
      font-size:0.85rem;
      color:#bbb;
      margin-bottom:6px;
      text-align:left;
    }
    select{
      width:100%;
      background:#0b0b0b;
      color:#e8e8e8;
      border:1px solid #333;
      border-radius:10px;
      padding:10px 10px;
      font-size:0.95rem;
    }

    .note-display{
      font-size:5rem;
      color:#fff;
      line-height:1;
      margin:0;
      text-shadow:0 0 20px var(--accent);
      font-weight:900;
      margin-top: 32px;
    }

    .freq-display{
      font-size:1.35rem;
      color:#FEFEFE;
      font-family:ui-monospace, Menlo, Consolas, monospace;
      margin-top:10px;
      margin-bottom:10px;
      line-height:1.35;
      font-weight:800;
    }

    .meter-box{
      width:100%;
      height:80px;
      background:#000;
      position:relative;
      border-radius:10px;
      margin:14px 0 8px;
      border:1px solid #333;
      overflow:hidden;
    }

    /* Strobe layer (hidden unless strobe mode) */
    #strobe-layer{
      position:absolute;
      inset:0;
      display:none;
      z-index:1;
      overflow:hidden;
      pointer-events:none;
      opacity:0.95;

      /* subtle dark base like the reference */
      background:#050a2a;

      /* soft edge shading */
      box-shadow: inset 0 0 18px rgba(0,0,0,0.55);
    }

    /* Initially dim strobe before audio is started */
    body.not-started #strobe-layer{
      opacity:0.25;
      filter:saturate(0.85);
    }

    /* Horizontal-style strobe look:
       - vertical cyan/navy stripes (like a rotated version of the far-right bar)
       - hard edges (no blur)
       - slight “gloss” overlay to match the app-like feel */
    #strobe-pattern{
      position:absolute;
      inset:-40px;
      will-change: background-position;

      --strobe-cyan: #21c7ff;
      --strobe-navy: #07104a;

      /* one 32px “tile”: 16px navy + 16px cyan (wider segments) */
      background-image:
        linear-gradient(
          90deg,
          var(--strobe-navy) 0px,
          var(--strobe-navy) 16px,
          var(--strobe-cyan) 16px,
          var(--strobe-cyan) 32px
        ),
        linear-gradient(
          180deg,
          rgba(255,255,255,0.10) 0%,
          rgba(255,255,255,0.03) 18%,
          rgba(0,0,0,0.10) 55%,
          rgba(0,0,0,0.18) 100%
        );

      background-repeat: repeat, no-repeat;
      background-size: 32px 100%, 100% 100%;
      background-position: 0px 0px, 0px 0px;
    }

    /* Center reference line for strobe mode */
    #strobe-center{
      position:absolute;
      left:50%;
      top:0;
      height:100%;
      width:2px;
      background:var(--accent);
      opacity:0.30;
    }

    #needle{
      width:3px;
      height:100%;
      background:#ff3e3e;
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      transition:left .10s ease-out, background-color .10s ease-out;
      z-index:2;
    }

    /* Additionally dim the whole needle area (meter + labels) before START, but only in needle mode */
    body.not-started.mode-needle .meter-box{
      opacity:0.25;
    }
    body.not-started.mode-needle .meter-labels{
      opacity:0.25;
    }

    .center-mark{
      position:absolute;
      left:50%;
      width:2px;
      height:100%;
      background:var(--accent);
      opacity:.55;
      z-index:1;
    }

    .edge-mark{
      position:absolute;
      top:0;
      height:100%;
      width:1px;
      background:#444;
      opacity:0.9;
      z-index:1;
    }
    .edge-left{ left:0%; }
    .edge-right{ left:100%; }

    .tick-mark{
      position:absolute;
      top:0;
      height:100%;
      width:1px;
      background:#2b2b2b;
      opacity:0.8;
      z-index:1;
    }

    .meter-labels{
      display:flex;
      justify-content:space-between;
      font-family:ui-monospace, Menlo, Consolas, monospace;
      font-size:0.9rem;
      color:#bbb;
      margin-top:8px;
      padding:0 2px;
    }

    /* Hide needle reference marks/labels when in strobe mode */
    body.mode-strobe .meter-labels{ display:none !important; }
    body.mode-strobe .center-mark,
    body.mode-strobe .edge-mark,
    body.mode-strobe .tick-mark{ display:none !important; }
    body.mode-strobe #strobe-center{ display:none !important; }

    /* Mic / permission error banner */
    #mic-error{
      display:none;                 /* JS toggles */
      margin: 10px 0 4px;
      padding: 12px 12px;
      border-radius: 12px;
      text-align: left;
      font-weight: 800;
      font-size: 0.98rem;
      line-height: 1.35;
      color: #ffecec;
      background: #3a0f12;
      border: 1px solid #7a2b30;
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      grid-column: 1 / -1; /* allow banner to span all columns if it ends up in the grid */
    }

    button{
      padding:14px 18px;
      border:none;
      border-radius:10px;
      font-weight:900;
      cursor:pointer;
      transition:.2s;
      width:100%;
      margin-top:12px;
      font-size:1.15rem;
    }
    .btn-main{ background:var(--accent); color:#000; }

    @media (hover: hover) and (pointer: fine) {
      #start-btn.btn-main{ transition: filter 125ms ease; }
      #start-btn.btn-main:hover{ filter: brightness(1.75); }
      #start-btn.btn-main:active{ filter: brightness(1.0); }
    }

    .select-wrap{ position: relative; }
    .select-wrap select{
      -webkit-appearance:none;
      -moz-appearance:none;
      appearance:none;
      padding-right:46px;
      background-image:none;
    }
    .select-wrap::after{
      content:"▾";
      position:absolute;
      right:14px;
      top:50%;
      transform:translateY(-50%);
      pointer-events:none;
      color:#e8e8e8;
      font-size:0.95rem;
      line-height:1;
      opacity:0.85;
    }
    .select-wrap select::-ms-expand{ display:none; }

    @media (max-width: 600px) {
      body{ padding:12px; }
      #tuner-ui{ padding:16px; border-radius:14px; }
      #tuner-ui h1{ font-size:1.25rem !important; margin:0 0 12px 0 !important; }
      label{ font-size:0.9rem; margin-bottom:8px; }
      select{ font-size:1.05rem; padding:14px 12px; border-radius:12px; }
      .select-wrap select{ padding-right:52px; }
      .select-wrap::after{ right:18px; font-size:1.1rem; opacity:0.9; }
      .note-display{ font-size:5rem; margin-top:2px;margin-top:24px; }
      .freq-display{ font-size:1.35rem; margin-bottom:10px; }
      .meter-box{ height:64px; margin:18px 0 8px; border-radius:12px; }
      button{ font-size:1.2rem; padding:16px 18px; border-radius:14px; }

      .row{
        grid-template-columns: 1fr; /* stack on mobile */
      }
    }
  </style>
</head>

<body>
  <div id="tuner-ui">

    <!-- Help / Troubleshooting button -->
    <div id="help-btn" title="Troubleshooting">?</div>

    <!-- Small subtle volume meter (top right) -->
    <div id="level-meter" title="Input level">
      <div id="level-meter-fill"></div>
    </div>

    <!-- Troubleshooting modal (hidden by default) -->
    <div id="troubleshoot-overlay" aria-hidden="true">
      <div id="troubleshoot-modal" role="dialog" aria-modal="true" aria-label="Troubleshooting">
        <div id="troubleshoot-title" style="text-align:center;">Troubleshooting</div>
        <div id="troubleshoot-body">
          <br/>You must grant the browser microphone permission for this tool to work.<br/><br/>
          The audio input level is displayed in a bar at the top right of the tool.<br/><br/>
          <b>If no audio is detected or the audio input meter is maxed out and no notes are getting recognized:</b><br/><br/>
          First, I recommend that you adjust your system's microphone level settings.<br/><br/>
          You can also reduce/boost the microphone signal level from within the tool using the options on the <b>Input level adjustment</b> dropdown.<br/><br/>
          On Windows systems, you may need to also disable any automatic microphone noise reduction being done by the system audio drivers.<br/><br/>
          To the noise reduction system, continuous tones may be mistaken for background noise (fans, AC hum, etc.) and filtered out.<br/><br/>
          Open the Windows settings and search for Microphone settings, make any required changes to the settings, then reload the tuner tab in the browser.
          <br/><br/>
        </div>
        <button id="troubleshoot-close" type="button">CLOSE</button>
      </div>
    </div>

    <h1 style="margin: 0 0 16px 0; font-size: 1.6rem; line-height:1.1; font-weight: 900; letter-spacing: 0.4px; color: #e0e0e0; text-align: center;" title="This utility was developed by Michael Eskin - https://michaeleskin.com">
      Chromatic Tuner
    </h1>

    <div class="row">

      <div>
        <label for="displaymode">&nbsp;&nbsp;Display mode</label>
        <div class="select-wrap">
          <select id="displaymode">
            <option value="needle" selected>Needle</option>
            <option value="strobe">Strobe</option>
          </select>
        </div>
      </div>

      <div>
        <label for="a4ref">&nbsp;&nbsp;A4 reference (Hz)</label>
        <div class="select-wrap">
          <select id="a4ref">
            <option value="438">438</option>
            <option value="439">439</option>
            <option value="440" selected>440</option>
            <option value="441">441</option>
            <option value="442">442</option>
            <option value="443">443</option>
            <option value="444">444</option>
            <option value="445">445</option>
            <option value="446">446</option>
          </select>
        </div>
      </div>

      <div>
        <label for="inputboost">&nbsp;&nbsp;Input level adjustment</label>
        <div class="select-wrap">
          <select id="inputboost">
            <option value="0.125">-18 dB</option>
            <option value="0.25">-12 dB</option>
            <option value="0.5">-6 dB</option>
            <option value="0.7079">-3 dB</option>
            <option value="1.0" selected>0 dB</option>
            <option value="1.4125">+3 dB</option>
            <option value="2.0">+6 dB</option>
            <option value="4.0">+12 dB</option>
            <option value="8.0">+18 dB</option>
          </select>
        </div>
      </div>

    </div>

    <!-- Mic error message (hidden by default) -->
    <div id="mic-error" style="display:none;"></div>

    <!-- Everything below dims during silence -->
    <div id="tuner-live">
      <div id="note" class="note-display">--</div>
      <div id="freq" class="freq-display">-- cents</div>

      <div class="meter-box" title="In Needle mode shows cents relative to equal temperament (ET). Range: -50 to +50 cents.&nbsp;&nbsp;In Strobe mode, stripes moves left if note is flat, right if sharp.&nbsp;&nbsp;Strobe stops when note is in tune.">
        <!-- Strobe overlay (only visible in strobe mode) -->
        <div id="strobe-layer" aria-hidden="true">
          <div id="strobe-pattern"></div>
          <div id="strobe-center"></div>
        </div>

        <div class="center-mark"></div>

        <div class="edge-mark edge-left"></div>
        <div class="edge-mark edge-right"></div>

        <!-- tick marks for ±50c range: every 10c -->
        <div class="tick-mark" style="left:10%;"></div>
        <div class="tick-mark" style="left:20%;"></div>
        <div class="tick-mark" style="left:30%;"></div>
        <div class="tick-mark" style="left:40%;"></div>
        <div class="tick-mark" style="left:60%;"></div>
        <div class="tick-mark" style="left:70%;"></div>
        <div class="tick-mark" style="left:80%;"></div>
        <div class="tick-mark" style="left:90%;"></div>

        <div id="needle"></div>
      </div>

      <!-- UPDATED LABELS FOR ±50c -->
      <div class="meter-labels">
        <div>-50 cents</div>
        <div>0</div>
        <div>+50 cents</div>
      </div>
    </div>

    <button id="start-btn" class="btn-main" type="button">START</button>
  </div>

<script>
  // ---------- LocalStorage keys ----------
  const LS_KEY_A4REF = "abctools_tuner_a4ref_hz";
  const LS_KEY_BOOST = "abctools_tuner_input_boost_v2";
  const LS_KEY_MODE  = "abctools_tuner_display_mode_v1";

  // ---------- Audio nodes ----------
  let audioCtx = null;
  let streamSource = null;
  let analyserPitch = null;
  let timeDataPitch = null;

  /* Optional user-selected input boost (all platforms) */
  let userBoostGainNode = null;
  let gUserBoostGain = 1.0;

  /* iOS-only input gain to address low mic levels on iOS */
  let inputGainNode = null;

  /* iOS-only compressor to lift quiet sustained tones */
  let iosCompressorNode = null;

  function isIOS(){
    const ua = navigator.userAgent || "";
    const iOSUA = /iPad|iPhone|iPod/.test(ua);
    const iPadOS = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
    return iOSUA || iPadOS;
  }
  const IOS_INPUT_GAIN = 3.0;

  // ---------- iOS/Safari: ensure AudioContext is running ----------
  async function ensureAudioContextRunning() {
    if (!audioCtx) return;
    try {
      if (audioCtx.state === "suspended") await audioCtx.resume();
    } catch (e) { /* ignore */ }
  }

  // ---------- Utils ----------
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
  function median(arr){
    if (!arr || !arr.length) return null;
    const s = arr.slice().sort((a,b)=>a-b);
    return s[Math.floor(s.length/2)];
  }
  function rmsOfArray(buf){
    let sum = 0;
    for (let i=0;i<buf.length;i++){ const v = buf[i]; sum += v*v; }
    return Math.sqrt(sum / buf.length);
  }

  function freqToMidi(freq){ return 12 * (Math.log2(freq / gA4RefHz)) + 69; }
  function midiToFreq(midi){ return gA4RefHz * Math.pow(2, (midi - 69) / 12); }
  function centsBetween(fA, fB){ return 1200 * Math.log2(fA / fB); }

  function midiToNoteName(midi){
    const pc = ((midi % 12) + 12) % 12;
    const octave = Math.floor(midi / 12) - 1;
    return NOTES[pc] + octave;
  }
  function fmtCentsSigned(c){
    if (c == null || !isFinite(c)) return "--";
    const v = Math.round(c * 10) / 10;
    return (v > 0 ? "+" : "") + v.toFixed(1);
  }

  // ---------- UI ----------
  const tunerLive = document.getElementById('tuner-live');
  const needle = document.getElementById('needle');
  const noteEl = document.getElementById('note');
  const deltaEl = document.getElementById('freq');

  // Strobe UI
  const strobeLayer = document.getElementById('strobe-layer');
  const strobePattern = document.getElementById('strobe-pattern');
  let gDisplayMode = "needle";

  // Strobe state
  let strobePhasePx = 0;
  let strobeLastT = performance.now();
  const STROBE_PX_PER_CENT = 7.0;     // tuning feel; px/sec per cent
  const STROBE_MAX_PX_PER_SEC = 420;  // clamp to prevent extreme blur

  function resetStrobe(){
    strobePhasePx = 0;
    strobeLastT = performance.now();
    if (strobePattern) strobePattern.style.backgroundPosition = "0px 0px";
  }

  function setBodyModeClasses(){
    document.body.classList.toggle("mode-strobe", gDisplayMode === "strobe");
    document.body.classList.toggle("mode-needle", gDisplayMode !== "strobe");
  }

  function applyDisplayModeFromUI(){
    const sel = document.getElementById("displaymode");
    if (!sel) return;
    const v = String(sel.value || "needle");
    gDisplayMode = (v === "strobe") ? "strobe" : "needle";

    setBodyModeClasses();

    if (strobeLayer){
      strobeLayer.style.display = (gDisplayMode === "strobe") ? "block" : "none";
      strobeLayer.setAttribute("aria-hidden", (gDisplayMode === "strobe") ? "false" : "true");
    }
    if (needle){
      needle.style.display = (gDisplayMode === "strobe") ? "none" : "block";
    }
    resetStrobe();
  }

  function updateStrobe(detuneCents){
    if (gDisplayMode !== "strobe") return;
    if (!strobePattern) return;

    const now = performance.now();
    const dt = Math.max(0, Math.min(0.06, (now - strobeLastT) / 1000)); // clamp dt
    strobeLastT = now;

    // Move pattern proportional to detune; sign indicates direction
    let pxPerSec = (detuneCents || 0) * STROBE_PX_PER_CENT;
    pxPerSec = clamp(pxPerSec, -STROBE_MAX_PX_PER_SEC, STROBE_MAX_PX_PER_SEC);

    strobePhasePx += pxPerSec * dt;

    // Keep numbers bounded
    if (strobePhasePx > 100000) strobePhasePx -= 100000;
    if (strobePhasePx < -100000) strobePhasePx += 100000;

    const px = Math.round(strobePhasePx);
    strobePattern.style.backgroundPosition = `${px}px 0, 0 0`;
  }

  // Small level meter
  const levelMeterFill = document.getElementById('level-meter-fill');
  let levelMeterSmoothed = 0; // 0..1
  const LEVEL_METER_ALPHA = 0.25; // higher = snappier
  function setLevelMeter01(x){
    if (!levelMeterFill) return;
    const v = Math.max(0, Math.min(1, x || 0));
    levelMeterSmoothed = (LEVEL_METER_ALPHA * v) + ((1 - LEVEL_METER_ALPHA) * levelMeterSmoothed);
    levelMeterFill.style.width = Math.round(levelMeterSmoothed * 100) + "%";
  }

  // Troubleshooting modal wiring
  const helpBtn = document.getElementById('help-btn');
  const troubleshootOverlay = document.getElementById('troubleshoot-overlay');
  const troubleshootClose = document.getElementById('troubleshoot-close');

  function openTroubleshooting(){
    if (!troubleshootOverlay) return;
    troubleshootOverlay.style.display = "block";
    troubleshootOverlay.setAttribute("aria-hidden", "false");
  }
  function closeTroubleshooting(){
    if (!troubleshootOverlay) return;
    troubleshootOverlay.style.display = "none";
    troubleshootOverlay.setAttribute("aria-hidden", "true");
  }

  if (helpBtn){
    helpBtn.addEventListener("click", openTroubleshooting);
    helpBtn.addEventListener("touchstart", (e) => { e.preventDefault(); openTroubleshooting(); }, { passive:false });
  }
  if (troubleshootClose){
    troubleshootClose.addEventListener("click", closeTroubleshooting);
  }
  if (troubleshootOverlay){
    troubleshootOverlay.addEventListener("click", (e) => {
      if (e.target === troubleshootOverlay) closeTroubleshooting();
    });
  }
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeTroubleshooting();
  });

  const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

  // ---------- Settings ----------
  let gA4RefHz = 440;

  // Pitch analysis
  const PITCH_FFT_SIZE = 4096;
  const RMS_SILENCE = 0.020;

  // --- Adaptive thresholding (RMS gate) ---
  let noiseFloorRms = 0;
  let noiseFloorPrimed = false;
  let adaptiveRmsGate = RMS_SILENCE;

  const GATE_CALIBRATION_FRAMES = 30;
  let gateCalibrationFramesLeft = GATE_CALIBRATION_FRAMES;

  const NOISE_FLOOR_ALPHA = 0.06;
  const NOISE_FLOOR_ALPHA_FAST = 0.25;

  // iOS: more permissive gate
  const GATE_MULTIPLIER = isIOS() ? 2.0 : 3.0;
  const GATE_OFFSET     = isIOS() ? 0.0015 : 0.003;
  const GATE_MIN        = isIOS() ? 0.0030 : 0.006;

  const SILENCE_FRAMES_TO_RESET_FAST = 1;
  const DEEP_SILENCE_FACTOR = 0.45;

  // iOS: only learn the floor during calibration when actually quiet
  const IOS_CALIBRATION_QUIET_MAX_RMS = 0.030;

  function resetAdaptiveGate(){
    noiseFloorRms = 0;
    noiseFloorPrimed = false;
    adaptiveRmsGate = RMS_SILENCE;
    gateCalibrationFramesLeft = GATE_CALIBRATION_FRAMES;
  }

  function updateAdaptiveGate(rms){
    if (gateCalibrationFramesLeft > 0) {

      if (isIOS() && rms > IOS_CALIBRATION_QUIET_MAX_RMS) {
        return;
      }

      const a = NOISE_FLOOR_ALPHA_FAST;

      if (!noiseFloorPrimed) {
        noiseFloorRms = rms;
        noiseFloorPrimed = true;
      } else {
        noiseFloorRms = (a * rms) + ((1 - a) * noiseFloorRms);
      }

      gateCalibrationFramesLeft--;
    } else {
      const quietBand = adaptiveRmsGate * 1.15;

      if (rms <= quietBand) {
        const a = NOISE_FLOOR_ALPHA;

        if (!noiseFloorPrimed) {
          noiseFloorRms = rms;
          noiseFloorPrimed = true;
        } else {
          noiseFloorRms = (a * rms) + ((1 - a) * noiseFloorRms);
        }
      }
    }

    const floor = noiseFloorPrimed ? noiseFloorRms : rms;
    adaptiveRmsGate = Math.max(GATE_MIN, (floor * GATE_MULTIPLIER) + GATE_OFFSET);
  }

  // Needle scale: -/+50 cents
  const MAX_CENTS_DISPLAY = 50;

  // Stability
  let pitchHistory = [];
  const PITCH_HIST_FRAMES = 15;
  const PITCH_NEED_FRAMES = 8;

  // Reset behavior
  let silentFrames = 0;
  const SILENCE_FRAMES_TO_RESET = 4;
  let lastDetectedMidi = null;

  // Ranges
  const NEEDLE_IN_TUNE_CENTS = 3.5;
  const NEEDLE_SNAP_CENTS = 1.0;
  const NEEDLE_NEAR_CENTS = 8.0;

  // Visual smoothing (needle)
  const NEEDLE_SMOOTH_ALPHA = 0.20;
  let visualCentsSmoothed = 0;
  let visualSmoothingPrimed = false;

  // Colors
  const NEEDLE_COLOR_OUT  = "#ff3e3e";
  const NEEDLE_COLOR_NEAR = "#ffd34d";
  const NEEDLE_COLOR_IN   = "#28a745";

  // Microphone error handling
  const micErrorEl = document.getElementById('mic-error');

  function escapeHTML(s){
    return String(s).replace(/[&<>"']/g, ch => ({
      "&":"&amp;",
      "<":"&lt;",
      ">":"&gt;",
      '"':"&quot;",
      "'":"&#39;"
    }[ch]));
  }

  function showMicError(html){
    if (!micErrorEl) return;
    micErrorEl.innerHTML = html;
    micErrorEl.style.display = "block";
  }

  function hideMicError(){
    if (!micErrorEl) return;
    micErrorEl.innerHTML = "";
    micErrorEl.style.display = "none";
  }

  function micErrorMessageFromException(err){
    const name = (err && err.name) ? err.name : "";
    const base = "Microphone access failed.";

    if (name === "NotAllowedError" || name === "PermissionDeniedError") {
      return "Microphone access permission was denied.<br/><br/>Reload the page, click <b>START</b>, and allow microphone access when asked by your browser.";
    }
    if (name === "NotFoundError" || name === "DevicesNotFoundError") {
      return "No microphone was found.<br/><br/>Please connect/select a microphone and try again.";
    }
    if (name === "NotReadableError" || name === "TrackStartError") {
      return "Your microphone is in use by another app or unavailable.<br/><br/>Close other apps using the mic and try again.";
    }
    if (name === "OverconstrainedError" || name === "ConstraintNotSatisfiedError") {
      return "Your browser could not satisfy the microphone constraints.<br/><br/>Try again, or try a different browser/device.";
    }
    if (name === "SecurityError") {
      return "Microphone access is blocked by the browser security policy.<br/><br/>Please open this page via HTTPS and try again.";
    }

    return (err && err.message)
      ? `${base}<br/>${escapeHTML(err.message)}`
      : base;
  }

  // Once started, dim live area when no sound is detected
  let tunerStarted = false;


  // ---------- UI helpers ----------
  function setDimmed(on){
    if (!tunerStarted) return;
    tunerLive.classList.toggle("dimmed", !!on);
  }

  function setNeedleCents(cents){
    const c = (cents == null) ? 0 : clamp(cents, -MAX_CENTS_DISPLAY, MAX_CENTS_DISPLAY);
    const pos = 50 + (c / MAX_CENTS_DISPLAY) * 50;
    needle.style.left = clamp(pos, 0, 100) + "%";
  }

  function setNeedleColorByCents(cents){
    const a = Math.abs(cents || 0);

    if (a <= NEEDLE_IN_TUNE_CENTS) {
      needle.style.backgroundColor = NEEDLE_COLOR_IN;
    } else if (a <= NEEDLE_NEAR_CENTS) {
      needle.style.backgroundColor = NEEDLE_COLOR_NEAR;
    } else {
      needle.style.backgroundColor = NEEDLE_COLOR_OUT;
    }
  }

  function applySnapIfNeeded(cents){
    if (!isFinite(cents)) return cents;
    return (Math.abs(cents) <= NEEDLE_SNAP_CENTS) ? 0 : cents;
  }

  function resetNeedleSmoothing(){
    visualSmoothingPrimed = false;
  }

  function applyVisualNeedleSmoothing(cents){
    if (!isFinite(cents)) return cents;

    const target = clamp(cents, -MAX_CENTS_DISPLAY, MAX_CENTS_DISPLAY);

    if (!visualSmoothingPrimed){
      visualCentsSmoothed = target;
      visualSmoothingPrimed = true;
      return target;
    }

    visualCentsSmoothed = (NEEDLE_SMOOTH_ALPHA * target) + ((1 - NEEDLE_SMOOTH_ALPHA) * visualCentsSmoothed);
    return visualCentsSmoothed;
  }

  function clearDisplay(){
    noteEl.innerText = "--";
    deltaEl.innerHTML = "-- cents";
    setNeedleCents(0);
    setNeedleColorByCents(0);

    pitchHistory = [];
    lastDetectedMidi = null;
    silentFrames = 0;
    resetNeedleSmoothing();

    resetAdaptiveGate();

    levelMeterSmoothed = 0;
    setLevelMeter01(0);

    resetStrobe();
  }

  // ---------- Gain helper ----------
  function setUserBoostGainFromUI(){
    const sel = document.getElementById("inputboost");
    if (!sel) return;
    const v = parseFloat(sel.value);
    gUserBoostGain = (isFinite(v) && v > 0) ? v : 1.0;

    if (userBoostGainNode) {
      try { userBoostGainNode.gain.value = gUserBoostGain; } catch(e){ /* ignore */ }
    }
  }

  // ---------- LocalStorage save/restore ----------
  function restoreSettingsFromLocalStorage(){
    try{
      const mode = localStorage.getItem(LS_KEY_MODE);
      const a4 = localStorage.getItem(LS_KEY_A4REF);
      const boost = localStorage.getItem(LS_KEY_BOOST);

      const modeSel = document.getElementById("displaymode");
      if (modeSel && mode && modeSel.querySelector(`option[value="${CSS.escape(mode)}"]`)) {
        modeSel.value = mode;
      }

      const a4Sel = document.getElementById("a4ref");
      if (a4Sel && a4 && a4Sel.querySelector(`option[value="${CSS.escape(a4)}"]`)) {
        a4Sel.value = a4;
      }

      const boostSel = document.getElementById("inputboost");
      if (boostSel && boost && boostSel.querySelector(`option[value="${CSS.escape(boost)}"]`)) {
        boostSel.value = boost;
      }
    } catch(e){
      /* ignore */
    }
  }

  function saveSettingsToLocalStorage(){
    try{
      const modeSel = document.getElementById("displaymode");
      const a4Sel = document.getElementById("a4ref");
      const boostSel = document.getElementById("inputboost");
      if (modeSel) localStorage.setItem(LS_KEY_MODE, String(modeSel.value));
      if (a4Sel) localStorage.setItem(LS_KEY_A4REF, String(a4Sel.value));
      if (boostSel) localStorage.setItem(LS_KEY_BOOST, String(boostSel.value));
    } catch(e){
      /* ignore */
    }
  }

  // ---------- YIN Pitch ----------
  function yinPitch(buffer, sampleRate, minFreq, maxFreq, threshold) {
    const halfSize = Math.floor(buffer.length / 2);

    const minTau = Math.floor(sampleRate / maxFreq);
    const maxTau = Math.floor(sampleRate / minFreq);
    if (maxTau >= halfSize) return null;

    const d = new Float32Array(maxTau + 1);
    for (let tau = 1; tau <= maxTau; tau++) {
      let sum = 0;
      for (let i = 0; i < halfSize; i++) {
        const delta = buffer[i] - buffer[i + tau];
        sum += delta * delta;
      }
      d[tau] = sum;
    }

    const cmnd = new Float32Array(maxTau + 1);
    cmnd[0] = 1;
    let runningSum = 0;
    for (let tau = 1; tau <= maxTau; tau++) {
      runningSum += d[tau];
      cmnd[tau] = d[tau] * tau / (runningSum || 1e-12);
    }

    let tauEstimate = -1;
    for (let tau = Math.max(2, minTau); tau <= maxTau; tau++) {
      if (cmnd[tau] < threshold && cmnd[tau] < cmnd[tau - 1]) {
        while (tau + 1 <= maxTau && cmnd[tau + 1] < cmnd[tau]) tau++;
        tauEstimate = tau;
        break;
      }
    }
    if (tauEstimate === -1) return null;

    const probability = 1 - cmnd[tauEstimate];
    if (probability < 0.75) return null;

    const x0 = tauEstimate > 1 ? tauEstimate - 1 : tauEstimate;
    const x2 = tauEstimate + 1 <= maxTau ? tauEstimate + 1 : tauEstimate;
    const s0 = cmnd[x0], s1 = cmnd[tauEstimate], s2 = cmnd[x2];

    const denom = (2 * s1 - s2 - s0);
    let betterTau = tauEstimate;
    if (Math.abs(denom) > 1e-12) {
      const delta = (s2 - s0) / (2 * denom);
      betterTau = tauEstimate + delta;
    }

    const freq = sampleRate / betterTau;
    if (!(freq > 0) || freq < minFreq || freq > maxFreq) return null;

    return { freq, probability };
  }

  // ---------- Main tick ----------
  function tick(){
    if (!audioCtx || !analyserPitch) {
      requestAnimationFrame(tick);
      return;
    }

    analyserPitch.getFloatTimeDomainData(timeDataPitch);
    const rms = rmsOfArray(timeDataPitch);

    setLevelMeter01(clamp(rms / 0.10, 0, 1));

    updateAdaptiveGate(rms);

    if (rms < adaptiveRmsGate){
      setDimmed(true);

      // Freeze strobe naturally (no updates while gated)
      strobeLastT = performance.now();

      const isDeepSilence = (rms < (adaptiveRmsGate * DEEP_SILENCE_FACTOR));

      silentFrames++;

      const framesNeeded = isDeepSilence ? SILENCE_FRAMES_TO_RESET_FAST : SILENCE_FRAMES_TO_RESET;

      if (silentFrames === framesNeeded) {
        pitchHistory = [];
        lastDetectedMidi = null;
        resetNeedleSmoothing();
        resetStrobe();

        if (!isIOS()) {
          resetAdaptiveGate();
        }
      }

      ensureAudioContextRunning();
      requestAnimationFrame(tick);
      return;
    }

    silentFrames = 0;
    setDimmed(false);

    const yin = yinPitch(timeDataPitch, audioCtx.sampleRate, 55, 2000, 0.12);

    if (yin && yin.freq){
      const midiFloatNow = freqToMidi(yin.freq);
      const midiNow = Math.round(midiFloatNow);

      if (lastDetectedMidi !== null && midiNow !== lastDetectedMidi) {
        pitchHistory = [];
        resetNeedleSmoothing();
        resetStrobe();
      }
      lastDetectedMidi = midiNow;

      pitchHistory.push(yin.freq);
      while (pitchHistory.length > PITCH_HIST_FRAMES) pitchHistory.shift();

      if (pitchHistory.length >= PITCH_NEED_FRAMES){
        const f0 = median(pitchHistory);

        if (f0 && isFinite(f0) && f0 > 0){
          const midiFloat = freqToMidi(f0);
          const midi = Math.round(midiFloat);
          const note = midiToNoteName(midi);
          const ideal = midiToFreq(midi);

          // raw cents for strobe motion
          const centsRaw = centsBetween(f0, ideal);

          // snapped cents for display + needle behavior
          let cents = applySnapIfNeeded(centsRaw);

          noteEl.innerText = note;
          deltaEl.innerHTML = `${fmtCentsSigned(cents)} cents`;

          // Strobe motion (use raw, not snapped, so it never "sticks" incorrectly)
          const STROBE_STOP_CENTS = 1.0;
          const centsForStrobe = (Math.abs(centsRaw) <= STROBE_STOP_CENTS) ? 0 : centsRaw;
          updateStrobe(centsForStrobe);

          // Needle visuals only when needle mode (needle hidden in strobe mode)
          const visualCents = applyVisualNeedleSmoothing(cents);
          setNeedleCents(visualCents);
          setNeedleColorByCents(cents);
        }
      }
    }

    ensureAudioContextRunning();
    requestAnimationFrame(tick);
  }

  // ---------- Start ----------
  async function startAudio(){
    hideMicError();

    // ensure current dropdown values are applied
    setUserBoostGainFromUI();
    applyDisplayModeFromUI();

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await ensureAudioContextRunning();

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        autoGainControl: false,
        echoCancellation: false,
        noiseSuppression: false
      }
    });
    await ensureAudioContextRunning();

    const track = stream.getAudioTracks()[0];
    if (track && track.applyConstraints) {
      try {
        await track.applyConstraints({
          autoGainControl: false,
          echoCancellation: false,
          noiseSuppression: false
        });
      } catch (e) { /* ignore */ }
    }

    streamSource = audioCtx.createMediaStreamSource(stream);

    analyserPitch = audioCtx.createAnalyser();
    analyserPitch.fftSize = PITCH_FFT_SIZE;
    timeDataPitch = new Float32Array(analyserPitch.fftSize);

    userBoostGainNode = audioCtx.createGain();
    userBoostGainNode.gain.value = gUserBoostGain;

    if (isIOS()) {
      inputGainNode = audioCtx.createGain();
      inputGainNode.gain.value = IOS_INPUT_GAIN;

      iosCompressorNode = audioCtx.createDynamicsCompressor();
      iosCompressorNode.threshold.value = -48;
      iosCompressorNode.knee.value = 30;
      iosCompressorNode.ratio.value = 12;
      iosCompressorNode.attack.value = 0.003;
      iosCompressorNode.release.value = 0.25;

      streamSource.connect(userBoostGainNode);
      userBoostGainNode.connect(inputGainNode);
      inputGainNode.connect(iosCompressorNode);
      iosCompressorNode.connect(analyserPitch);
    } else {
      streamSource.connect(userBoostGainNode);
      userBoostGainNode.connect(analyserPitch);
    }

    const silentGain = audioCtx.createGain();
    silentGain.gain.value = 0;
    analyserPitch.connect(silentGain);
    silentGain.connect(audioCtx.destination);

    clearDisplay();

    tunerStarted = true;
    document.body.classList.remove("not-started");
    setDimmed(true);

    requestAnimationFrame(tick);
  }

  document.getElementById('start-btn').onclick = async () => {
    try{
      const btn = document.getElementById('start-btn');
      btn.disabled = true;
      btn.innerText = "STARTING…";
      await startAudio();
      btn.style.display = "none";
    }catch(err){
      console.error(err);

      showMicError(micErrorMessageFromException(err));

      const btn = document.getElementById('start-btn');
      btn.disabled = false;
      btn.innerText = "START";
      tunerStarted = false;
      setDimmed(false);
    }
  };

  // Display mode dropdown
  const displayModeSelect = document.getElementById('displaymode');
  if (displayModeSelect) {
    displayModeSelect.addEventListener('change', () => {
      applyDisplayModeFromUI();
      saveSettingsToLocalStorage();
      // no other state changes
    });
  }

  // A4 reference
  const a4RefSelect = document.getElementById('a4ref');
  if (a4RefSelect) {
    gA4RefHz = parseFloat(a4RefSelect.value) || 440;

    a4RefSelect.addEventListener('change', () => {
      gA4RefHz = parseFloat(a4RefSelect.value) || 440;

      saveSettingsToLocalStorage();

      pitchHistory = [];
      lastDetectedMidi = null;
      silentFrames = 0;
      resetNeedleSmoothing();
      resetStrobe();
      clearDisplay();
    });
  }

  // Input boost dropdown
  const inputBoostSelect = document.getElementById('inputboost');
  if (inputBoostSelect) {
    setUserBoostGainFromUI();
    inputBoostSelect.addEventListener('change', () => {
      setUserBoostGainFromUI();
      saveSettingsToLocalStorage();
      // Don't clear display/state; this is a live diagnostic/boost.
    });
  }

  // Restore saved settings before initial wiring applies values
  restoreSettingsFromLocalStorage();

  // Initial state: before START, allow strobe to be visible (if selected) but dim it
  document.body.classList.add("not-started");

  // Apply restored values to runtime vars immediately
  if (a4RefSelect){
    gA4RefHz = parseFloat(a4RefSelect.value) || 440;
  }
  setUserBoostGainFromUI();
  applyDisplayModeFromUI();

  // iOS/Safari resume
  function addIOSResumeGestures() {
    const handler = async () => {
      if (audioCtx) await ensureAudioContextRunning();
    };
    window.addEventListener("touchstart", handler, { passive: true });
    window.addEventListener("mousedown", handler, { passive: true });
    window.addEventListener("keydown", handler, { passive: true });

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && audioCtx) ensureAudioContextRunning();
    });
  }
  if (isIOS()){
    addIOSResumeGestures();
  }

  clearDisplay();
</script>
</body>
</html>
